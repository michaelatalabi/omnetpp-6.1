//
// Generated file, do not edit! Created by opp_msgtool 6.1 from common/LteControlInfo.msg.
//

#ifndef __SIMU5G_LTECONTROLINFO_M_H
#define __SIMU5G_LTECONTROLINFO_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0601
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace simu5g {

class LteControlInfo;
class FlowControlInfo;
class UserControlInfo;

}  // namespace simu5g

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/TagBase_m.h" // import inet.common.TagBase

#include "common/LteCommon_m.h" // import common.LteCommon


namespace simu5g {

/**
 * Class generated from <tt>common/LteControlInfo.msg:52</tt> by opp_msgtool.
 * <pre>
 * //
 * // \@class LteControlInfo
 * // \@brief Base class for FlowControlInfo and UserControlInfo
 * //
 * // This class contains information present in both Flow and User ControlInfo:
 * // - Source MAC Node ID
 * // - Destination MAC Node ID
 * //
 * class LteControlInfo extends inet::TagBase
 * {
 *     MacNodeId sourceId = NODEID_NONE;                    // Source MacNodeId
 *     MacNodeId destId = NODEID_NONE;                      // Destination MacNodeId
 *     unsigned short direction \@enum(Direction);            // Traffic Direction (UL, DL, D2D)
 *     MacNodeId d2dTxPeerId = NODEID_NONE;
 *     MacNodeId d2dRxPeerId = NODEID_NONE;
 * 
 *     //# Traffic Control Information
 * 
 *     unsigned short application \@enum(ApplicationType) = 0;    // Application Type
 *     unsigned short traffic \@enum(LteTrafficClass) = 0;        // Lte Traffic Type
 * 
 *     //# RLC Control Information
 * 
 *     unsigned short rlcType \@enum(LteRlcType) = 0;            // RLC Traffic Type
 * 
 *     //# Connection Information
 * 
 *     uint16 lcid = 0;                                        // Logical Connection Identifier
 *     int32 multicastGroupId = -1;                        // Identifier for a multicast group (it is in range [0:[2^28)-1] )
 *                                                         // For unicast communications, this field is -1
 * }
 * </pre>
 */
class LteControlInfo : public ::inet::TagBase
{
  protected:
    MacNodeId sourceId = NODEID_NONE;
    MacNodeId destId = NODEID_NONE;
    unsigned short direction = 0;
    MacNodeId d2dTxPeerId = NODEID_NONE;
    MacNodeId d2dRxPeerId = NODEID_NONE;
    unsigned short application = 0;
    unsigned short traffic = 0;
    unsigned short rlcType = 0;
    uint16_t lcid = 0;
    int32_t multicastGroupId = -1;

  private:
    void copy(const LteControlInfo& other);

  protected:
    bool operator==(const LteControlInfo&) = delete;

  public:
    LteControlInfo();
    LteControlInfo(const LteControlInfo& other);
    virtual ~LteControlInfo();
    LteControlInfo& operator=(const LteControlInfo& other);
    virtual LteControlInfo *dup() const override {return new LteControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const MacNodeId& getSourceId() const;
    virtual MacNodeId& getSourceIdForUpdate() { return const_cast<MacNodeId&>(const_cast<LteControlInfo*>(this)->getSourceId());}
    virtual void setSourceId(const MacNodeId& sourceId);

    virtual const MacNodeId& getDestId() const;
    virtual MacNodeId& getDestIdForUpdate() { return const_cast<MacNodeId&>(const_cast<LteControlInfo*>(this)->getDestId());}
    virtual void setDestId(const MacNodeId& destId);

    virtual unsigned short getDirection() const;
    virtual void setDirection(unsigned short direction);

    virtual const MacNodeId& getD2dTxPeerId() const;
    virtual MacNodeId& getD2dTxPeerIdForUpdate() { return const_cast<MacNodeId&>(const_cast<LteControlInfo*>(this)->getD2dTxPeerId());}
    virtual void setD2dTxPeerId(const MacNodeId& d2dTxPeerId);

    virtual const MacNodeId& getD2dRxPeerId() const;
    virtual MacNodeId& getD2dRxPeerIdForUpdate() { return const_cast<MacNodeId&>(const_cast<LteControlInfo*>(this)->getD2dRxPeerId());}
    virtual void setD2dRxPeerId(const MacNodeId& d2dRxPeerId);

    virtual unsigned short getApplication() const;
    virtual void setApplication(unsigned short application);

    virtual unsigned short getTraffic() const;
    virtual void setTraffic(unsigned short traffic);

    virtual unsigned short getRlcType() const;
    virtual void setRlcType(unsigned short rlcType);

    virtual uint16_t getLcid() const;
    virtual void setLcid(uint16_t lcid);

    virtual int32_t getMulticastGroupId() const;
    virtual void setMulticastGroupId(int32_t multicastGroupId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LteControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LteControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/LteControlInfo.msg:88</tt> by opp_msgtool.
 * <pre>
 * //
 * // \@class FlowControlInfo
 * // \@brief contains information flowing from LteIp to Mac
 * //
 * // It contains the following information:
 * // - IP Control Informations: the four tuple, a sequence number and
 * //   the header size (IP + Transport) to be used by pdcp ROHC.
 * // - Traffic Control Informations: Application, Direction, Traffic
 * // - RLC Control Informations: the traffic type (TM, UM, AM)
 * // - Connection information: Logical CID
 * //
 * class FlowControlInfo extends LteControlInfo
 * {
 *     uint32 srcAddr = 0;                     // source IP
 *     uint32 dstAddr = 0;                     // destination IP
 *     uint16 typeOfService = 0;               // IP Type Of Service
 *     unsigned int sequenceNumber = 0;        // packet sequence number
 *     int headerSize = 0;                     // IP + Transport header size (used by pdcp ROHC)
 *     bool useNR = false;                     // flag for sending this packet using NR
 * }
 * </pre>
 */
class FlowControlInfo : public ::simu5g::LteControlInfo
{
  protected:
    uint32_t srcAddr = 0;
    uint32_t dstAddr = 0;
    uint16_t typeOfService = 0;
    unsigned int sequenceNumber = 0;
    int headerSize = 0;
    bool useNR = false;

  private:
    void copy(const FlowControlInfo& other);

  protected:
    bool operator==(const FlowControlInfo&) = delete;

  public:
    FlowControlInfo();
    FlowControlInfo(const FlowControlInfo& other);
    virtual ~FlowControlInfo();
    FlowControlInfo& operator=(const FlowControlInfo& other);
    virtual FlowControlInfo *dup() const override {return new FlowControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSrcAddr() const;
    virtual void setSrcAddr(uint32_t srcAddr);

    virtual uint32_t getDstAddr() const;
    virtual void setDstAddr(uint32_t dstAddr);

    virtual uint16_t getTypeOfService() const;
    virtual void setTypeOfService(uint16_t typeOfService);

    virtual unsigned int getSequenceNumber() const;
    virtual void setSequenceNumber(unsigned int sequenceNumber);

    virtual int getHeaderSize() const;
    virtual void setHeaderSize(int headerSize);

    virtual bool getUseNR() const;
    virtual void setUseNR(bool useNR);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FlowControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FlowControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/LteControlInfo.msg:108</tt> by opp_msgtool.
 * <pre>
 * //
 * // \@class UserControlInfo
 * // \@brief contains information flowing from Mac to Phy
 * //
 * // It contains the following information:
 * // - H-ARQ Control Information
 * // - PHY Control Informations: Broadcast, Corruption, Type,
 * //   txMode, Resource blocks used, RemoteSet
 * //
 * class UserControlInfo extends LteControlInfo
 * {
 *     \@customize(true);
 * 
 *     bool isNr = false;
 *     double carrierFrequency = NaN;       // carrier frequency
 * 
 *     //# H-ARQ Control Information
 * 
 *     unsigned char acid = 0;              // H-ARQ process identifier
 *     unsigned char cw = 0;                // H-ARQ codeword identifier
 *     unsigned char txNumber = 0;          // number of (re)transmissions for the same pdu (1, 2, 3, 4)
 *     bool ndi = true;                     // new data indicator (new data overwrites a process content if present)
 * 
 *     //# PHY Control Informations
 * 
 *     bool isCorruptible = false;                         // Frame is corruptible
 *     bool isBroadcast = false;                           // Broadcast packet
 *     bool deciderResult = false;                         // Decider result
 *     double blerTh = NaN;                                // Calculated BLER threshold for this transmission
 *     double blerValue = NaN;                             // Extracted BLER for this transmission (blerValue > blerTh ==> corrupted)
 *     unsigned short txMode \@enum(TxMode) = 0;             // Traffic Type
 *     unsigned int frameType \@enum(LtePhyFrameType) = 0;   // Frame Type
 *     double txPower = NaN;                               //Transmission Power
 *     double d2dTxPower = NaN;                            // D2D Transmission Power (used for feedback reporting of D2D links
 *     // blocks granted on all Remotes, all Bands
 *     unsigned int totalGrantedBlocks = 0;
 * 
 *     unsigned int grantId = 0;                           // grantId related to the grand that allowed the sending of a MEC PDU (used only for MAC PDU sent by UEs)
 * 
 *     //#
 *     //# Follows a list of elements only present in
 *     //# the customized class (see LteControlInfo.h):
 *     //#
 *     //# RemoteSet ru;                                // Remote Antenna Set
 *     //# RbMap grantedBlocks;                        // Blocks allocated per Remote, per Band.
 * }
 * </pre>
 *
 * UserControlInfo_Base is only useful if it gets subclassed, and UserControlInfo is derived from it.
 * The minimum code to be written for UserControlInfo is the following:
 *
 * <pre>
 * class UserControlInfo : public UserControlInfo_Base
 * {
 *   private:
 *     void copy(const UserControlInfo& other) { ... }

 *   public:
 *     UserControlInfo() : UserControlInfo_Base() {}
 *     UserControlInfo(const UserControlInfo& other) : UserControlInfo_Base(other) {copy(other);}
 *     UserControlInfo& operator=(const UserControlInfo& other) {if (this==&other) return *this; UserControlInfo_Base::operator=(other); copy(other); return *this;}
 *     virtual UserControlInfo *dup() const override {return new UserControlInfo(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from UserControlInfo_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(UserControlInfo)
 * </pre>
 */
class UserControlInfo_Base : public ::simu5g::LteControlInfo
{
  protected:
    bool isNr_ = false;
    double carrierFrequency = NaN;
    unsigned char acid = 0;
    unsigned char cw = 0;
    unsigned char txNumber = 0;
    bool ndi = true;
    bool isCorruptible_ = false;
    bool isBroadcast_ = false;
    bool deciderResult = false;
    double blerTh = NaN;
    double blerValue = NaN;
    unsigned short txMode = 0;
    unsigned int frameType = 0;
    double txPower = NaN;
    double d2dTxPower = NaN;
    unsigned int totalGrantedBlocks = 0;
    unsigned int grantId = 0;

  private:
    void copy(const UserControlInfo_Base& other);

  protected:
    bool operator==(const UserControlInfo_Base&) = delete;
    // make constructors protected to avoid instantiation
    UserControlInfo_Base();
    UserControlInfo_Base(const UserControlInfo_Base& other);
    // make assignment operator protected to force the user override it
    UserControlInfo_Base& operator=(const UserControlInfo_Base& other);

  public:
    virtual ~UserControlInfo_Base();
    virtual UserControlInfo_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class UserControlInfo");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool isNr() const;
    virtual void setIsNr(bool isNr);

    virtual double getCarrierFrequency() const;
    virtual void setCarrierFrequency(double carrierFrequency);

    virtual unsigned char getAcid() const;
    virtual void setAcid(unsigned char acid);

    virtual unsigned char getCw() const;
    virtual void setCw(unsigned char cw);

    virtual unsigned char getTxNumber() const;
    virtual void setTxNumber(unsigned char txNumber);

    virtual bool getNdi() const;
    virtual void setNdi(bool ndi);

    virtual bool isCorruptible() const;
    virtual void setIsCorruptible(bool isCorruptible);

    virtual bool isBroadcast() const;
    virtual void setIsBroadcast(bool isBroadcast);

    virtual bool getDeciderResult() const;
    virtual void setDeciderResult(bool deciderResult);

    virtual double getBlerTh() const;
    virtual void setBlerTh(double blerTh);

    virtual double getBlerValue() const;
    virtual void setBlerValue(double blerValue);

    virtual unsigned short getTxMode() const;
    virtual void setTxMode(unsigned short txMode);

    virtual unsigned int getFrameType() const;
    virtual void setFrameType(unsigned int frameType);

    virtual double getTxPower() const;
    virtual void setTxPower(double txPower);

    virtual double getD2dTxPower() const;
    virtual void setD2dTxPower(double d2dTxPower);

    virtual unsigned int getTotalGrantedBlocks() const;
    virtual void setTotalGrantedBlocks(unsigned int totalGrantedBlocks);

    virtual unsigned int getGrantId() const;
    virtual void setGrantId(unsigned int grantId);
};


}  // namespace simu5g


namespace omnetpp {

template<> inline simu5g::LteControlInfo *fromAnyPtr(any_ptr ptr) { return check_and_cast<simu5g::LteControlInfo*>(ptr.get<cObject>()); }
template<> inline simu5g::FlowControlInfo *fromAnyPtr(any_ptr ptr) { return check_and_cast<simu5g::FlowControlInfo*>(ptr.get<cObject>()); }
template<> inline simu5g::UserControlInfo_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<simu5g::UserControlInfo_Base*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __SIMU5G_LTECONTROLINFO_M_H

