<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <meta name="copyright" content="OpenSim Ltd.">
  <meta NAME="Author" CONTENT="Andras Varga">
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="STYLESHEET" href="../book.css"  type="text/css">
  <title>OMNeT++ - Simulation Manual</title>
</head>
<style type="text/css">
  hr.pgbr { color: #f5f5f5; margin-top: 40px; margin-bottom: 10px; }
  ul.dl { padding-left: 30px; text-indent: -30px; list-style: none; }
  pre { margin: 4px 8px 4px 2px; padding: 8px 10px; background:#fffff4; border: 1px solid #dddddd; }
  pre.ned { background:#f5fff5; border-left: 4px solid #ccffcc; }
  pre.msg { background:#f5fff5; border-left: 4px solid #ccffcc; }
  pre.cpp { background:#f5f5f5; border-left: 4px solid #ccccff; }
  pre.inifile { background:#fffff0; border-left: 4px solid #e5e533; }
  pre.filelisting { background:#f0f0f0; border-left: 4px solid #d9d9d9; }
  pre.xml { background:#fff0f0; border-left: 4px solid #ffa0a0; }
  pre.commandline { background:#fffff0; border-left: 4px solid #606060; }
  td,th { text-align:left; vertical-align:top; border:1px solid; padding:3pt; border-color:#000000; }
  div.caption { margin-top: 10px; }
  a[href] { color: #202080; text-decoration: none; }
  a:visited { text-decoration: none; }
  # a:hover { text-decoration: underline; }

  table.matrix { display:inline-block; vertical-align: middle; position: relative; border: 0px; background:#ffffff; margin-left:8pt; margin-right:8pt; }
  table.matrix:before, table.matrix:after { content: ""; position: absolute; top: 0; border: 1px solid #000; width: 6px; height: 100%; }
  table.matrix:before { left: -6px; border-right: 0px; }
  table.matrix:after { right: -6px; border-left: 0px; }
  table.matrix td { padding: 5px; text-align: center; border: 0px; }

  a.headerlink { visibility: hidden; }
</style>
<body>

<p><hr><b><a href="chap3.html">[Prev]</A>&nbsp;<a href="chap5.html">[Next]</A>&nbsp;<a href="toc.html#toc_4.">[TOC]</a>&nbsp;<a href="usman.html">[Chapters]</a></b><hr></p><h1><a name="cha:simple-modules"/>4 Simple Modules<a class="headerlink" href="#cha:simple-modules" title="Permalink to this headline">¶</a></h1>
<!--module!simple-->

<p>
<i>Simple modules</i> are the active components in the model.
Simple modules are programmed in C++, using the OMNeT++ class
library. The following sections contain a brief introduction
to discrete event simulation in general, explain how its concepts are
implemented in OMNeT++, and give an overview and practical advice
on how to design and code simple modules.

<p>
<h2><a name="sec:simple-modules:simulation-concepts"/>4.1 Simulation Concepts<a class="headerlink" href="#sec:simple-modules:simulation-concepts" title="Permalink to this headline">¶</a></h2>

<p>This section contains a very brief introduction to how discrete
event simulation (DES) works, in order to introduce terms we'll use
when explaining OMNeT++ concepts<!--simulation!concepts--> and
implementation.

<p>
<h3><a name="sec:simple-modules:discrete-event-simulation"/>4.1.1 Discrete Event Simulation<a class="headerlink" href="#sec:simple-modules:discrete-event-simulation" title="Permalink to this headline">¶</a></h3>

<p>A <i>discrete event system</i> is a system where state changes
(events<!--events-->) happen at discrete instances in time, and events take zero time
to happen. It is assumed that nothing (i.e. nothing interesting)
happens between two consecutive events, that is, no state change takes
place in the system between the events. This is in contrast to
<i>continuous</i> systems where state changes are continuous.
Systems that can be viewed as discrete event systems can be modeled
using discrete event simulation<!--discrete event simulation-->, DES.

<p>For example, computer networks are usually viewed as discrete
event systems. Some of the events are:

<p><ul>
  <li> start of a packet transmission
  <li> end of a packet transmission
  <li> expiry of a retransmission timeout
</ul>

<p>This implies that between two events such as <i>start of a packet
transmission</i> and <i>end of a packet transmission</i>, nothing
interesting happens. That is, the packet's state remains <i>being
transmitted</i>. Note that the definition of &#8220;interesting&#8221; events and states always
depends on the intent and purposes of the modeler.
If we were interested in the transmission of individual bits, we would
have included something like <i>start of bit transmission</i> and
<i>end of bit transmission</i> among our events.

<p>
The time when events occur is often called <i>event timestamp</i>;
<!--event timestamp--> with OMNeT++ we use the term
<i>arrival time</i><!--arrival time--> (because in the class
library, the word &#8220;timestamp&#8221; is reserved for a user-settable
attribute in the event class). Time within the model is often called
<i>simulation time</i><!--simulation time-->, <i>model time</i>
<!--model!time-->, or <i>virtual time</i><!--virtual time-->,
as opposed to real time<!--real time--> or CPU time<!--CPU time-->,
which refer to how long the simulation program has been running and
how much CPU time it has consumed.

<p>

<p><h3><a name="sec:simple-modules:event-loop"/>4.1.2 The Event Loop<a class="headerlink" href="#sec:simple-modules:event-loop" title="Permalink to this headline">¶</a></h3>

<p>Discrete event simulation maintains the set of future
events<!--future events--> in a data structure often called
FES<!--FES--> (Future Event Set) or FEL<!--FEL--> (Future Event List).
Such simulators usually work according to the following pseudocode:

<p><pre class="verbatim">
<i>initialize -- this includes building the model and</i>
              <i>inserting initial events to FES</i>

<i>while (FES not empty and simulation not yet complete)</i>
<i>{</i>
    <i>retrieve first event from FES</i>
    <i>t:= timestamp of this event</i>
    <b><i>process event</i></b>
    <i>(processing may insert new events in FES or delete existing ones)</i>
<i>}</i>
<i>finish simulation (write statistical results, etc.)</i>
</pre>

<p>
The initialization step usually builds the data structures
representing the simulation model, calls any user-defined
initialization code, and inserts initial events<!--initial events-->
into the FES<!--FES--> to ensure that the simulation can start. Initialization
strategies can differ considerably from one simulator to another.

<p>
The subsequent loop consumes events from the FES<!--FES--> and processes
them. Events are processed in strict timestamp order
to maintain causality, that is, to ensure that no current event may have
an effect on earlier events.

<p>Processing an event involves calls to user-supplied code. For example,
using the computer network simulation example, processing a &#8220;timeout
expired&#8221; event may consist of re-sending a copy of the network
packet, updating the retry count, scheduling another &#8220;timeout&#8221;
event, and so on. The user code may also remove events from the FES<!--FES-->,
for example, when canceling timeouts.

<p>The simulation stops when there are no events left (this rarely happens
in practice) or when it isn't necessary for the simulation
to run further because the model time or the CPU time has reached
a given limit, or because the statistics have reached the desired
accuracy. At this time, before the program exits, the user
will typically want to record statistics into output files.

<p>
<h3><a name="sec:simple-modules:events-in-opp"/>4.1.3 Events and Event Execution Order in OMNeT++<a class="headerlink" href="#sec:simple-modules:events-in-opp" title="Permalink to this headline">¶</a></h3>

<p>OMNeT++ uses messages<!--message--> to represent
events<!--events-->.<br><ul><font size=-1>[For all practical purposes. Note that there
is a class called <tt>cEvent</tt> that <tt>cMessage</tt> subclasses from,
but it is only used internally to the simulation kernel.]</font></ul>
Messages are represented by instances of the <tt>cMessage</tt> class
and its subclasses. Messages are sent from one module to another -- this
means that the place where the &#8220;event will occur&#8221; is the
<i>message's destination module</i>, and the model time when the
event occurs is the <i>arrival time</i><!--arrival time--> of the
message. Events like &#8220;timeout expired&#8221; are implemented by the
module sending a message to itself.

<p>Events are consumed from the FES<!--FES--> in arrival time order, to
maintain causality. More precisely, given two messages, the following
rules apply:

<p><ol>
<li> The message with the <b>earlier arrival time</b> is executed
    first. If arrival times are equal,
<li> the one with the <b>higher scheduling priority</b> (smaller
    numeric value) is executed first. If priorities are the same,
<li> the one <b>scheduled/sent earlier</b> is executed first.
</ol>

<p><i>Scheduling priority</i><!--message!priority--> is a user-assigned integer
attribute of messages.

<p>

<p><h3><a name="sec:simple-modules:simulation-time"/>4.1.4 Simulation Time<a class="headerlink" href="#sec:simple-modules:simulation-time" title="Permalink to this headline">¶</a></h3>

<p>The current simulation time can be obtained with the <tt>simTime()</tt> function.

<p>Simulation time in OMNeT++ is represented by the C++ type <tt>simtime_t</tt>,
which is by default a typedef to the <tt>SimTime</tt> class.
<tt>SimTime</tt> class stores simulation time in a 64-bit integer,
using decimal fixed-point representation. The resolution is controlled
by the <i>scale exponent</i> global configuration variable; that is,
<tt>SimTime</tt> instances have the same resolution. The exponent can be
chosen between -18 (attosecond resolution) and 0 (seconds).
Some exponents with the ranges they provide are shown in the following table.

<p><center>
  <table border>
<TR> <TD align=right>
    Exponent </TD> <TD align=right> Resolution </TD> <TD align=center> Approx. Range </TD></TR>
<TR> <TD align=right>      -18 </TD> <TD align=right> <i>10<sup>-18</sup></i>s (1 as) </TD> <TD align=center> <i>+/- 9.22</i>s </TD></TR>
<TR> <TD align=right>      -15 </TD> <TD align=right> <i>10<sup>-15</sup></i>s (1 fs) </TD> <TD align=center> <i>+/- 153.72</i> minutes </TD></TR>
<TR> <TD align=right>      -12 </TD> <TD align=right> <i>10<sup>-12</sup></i>s (1 ps) </TD> <TD align=center> <i>+/- 106.75</i> days </TD></TR>
<TR> <TD align=right>      -9  </TD> <TD align=right> <i>10<sup>-9</sup></i>s (1 ns)  </TD> <TD align=center> <i>+/- 292.27</i> years </TD></TR>
<TR> <TD align=right>      -6  </TD> <TD align=right> <i>10<sup>-6</sup></i>s (1 us)  </TD> <TD align=center> <i>+/- 292271</i> years </TD></TR>
<TR> <TD align=right>      -3  </TD> <TD align=right> <i>10<sup>-3</sup></i>s (1 ms)  </TD> <TD align=center> <i>+/- 2.9227e8</i> years </TD></TR>
<TR> <TD align=right>      0   </TD> <TD align=right> 1s                </TD> <TD align=center> <i>+/- 2.9227e11</i> years </TD></TR>
  </table>
</center>

<p>Note that although simulation time cannot be negative, it is still useful to
be able to represent negative numbers because they often arise
during the evaluation of arithmetic expressions.

<p>There is no implicit conversion from <tt>SimTime</tt> to <tt>double</tt>, mostly
because it would conflict with overloaded arithmetic operations of <tt>SimTime</tt>;
use the <tt>dbl()</tt> method of <tt>SimTime</tt> or the <tt>SIMTIME_DBL()</tt> macro
to convert. To reduce the need for <tt>dbl()</tt>, several functions and methods
have overloaded variants that directly accept <tt>SimTime</tt>, for example,
<tt>fabs()</tt>, <tt>fmod()</tt>, <tt>div()</tt>, <tt>ceil()</tt>, <tt>floor()</tt>,
<tt>uniform()</tt>, <tt>exponential()</tt>, and <tt>normal()</tt>.

<p>Other useful methods of <tt>SimTime</tt> include <tt>str()</tt>,
which returns the value as a string; <tt>parse()</tt>, which converts a
string to <tt>SimTime</tt>; <tt>raw()</tt>, which returns the
underlying 64-bit integer; <tt>getScaleExp()</tt>, which returns the
global scale exponent; <tt>isZero()</tt>, which tests whether the
simulation time is 0; and <tt>getMaxTime()</tt>, which returns the maximum
simulation time that can be represented at the current scale exponent.
Zero and the maximum simulation time are also accessible
via the <tt>SIMTIME_ZERO</tt> and <tt>SIMTIME_MAX</tt> macros.

<pre class="cpp">
// 340 microseconds in the future, truncated to the millisecond boundary
simtime_t timeout = (simTime() + SimTime(340, SIMTIME_US)).trunc(SIMTIME_MS);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
   Converting a <tt>SimTime</tt> to <tt>double</tt> may lose precision because
   <tt>double</tt> only has a 52-bit mantissa.
   Earlier versions of OMNeT++ used <tt>double</tt> for the simulation
   time, but that caused problems in long simulations that relied on fine-grained timing,
   for example, MAC protocols. Other problems were the accumulation of
   rounding errors, and non-associativity (often <i>(x+y)+z != x+(y+z)</i>, see
   ~[<a href="#bib-Goldberg91what">Goldberg91what</a>]) which meant that two <tt>double</tt> simulation
   times could not be reliably compared for equality.
</ul>

<p>
<h3><a name="sec:simple-modules:fes-implementation"/>4.1.5 FES Implementation<a class="headerlink" href="#sec:simple-modules:fes-implementation" title="Permalink to this headline">¶</a></h3>

<p>The implementation of the FES<!--FES--> is a crucial factor in the
performance of a discrete event simulator. In OMNeT++, the FES is
replaceable, and the default FES implementation uses <i>binary
heap</i><!--binary heap--> as the data structure. Binary heap is generally
considered to be the best FES algorithm for discrete event simulation as
it provides a good, balanced performance for most workloads. (Exotic data
structures like <i>skiplist</i><!--skiplist--> may perform better than
heap in some cases.)

<p>
<h2><a name="sec:simple-modules:simple-modules-in-opp"/>4.2 Components, Simple Modules, Channels<a class="headerlink" href="#sec:simple-modules:simple-modules-in-opp" title="Permalink to this headline">¶</a></h2>

<p>OMNeT++ simulation models are composed of modules and connections. Modules
may be simple (atomic) modules or compound modules; simple modules are the
active components in a model, and their behavior is defined by the user as
C++ code. Connections may have associated channel objects. Channel objects
encapsulate channel behavior: propagation and transmission time modeling,
error modeling, and possibly others. Channels are also programmable in C++
by the user.

<p>Modules and channels are represented with the <tt>cModule</tt> and <tt>cChannel</tt>
classes, respectively. <tt>cModule</tt> and <tt>cChannel</tt> are both
derived from the <tt>cComponent</tt> class.

<p>The user defines simple module types by subclassing <tt>cSimpleModule</tt>.
Compound modules are instantiated with <tt>cModule</tt>, although
the user can override it with <b><tt>@class</tt></b> in the NED file, and can even
use a simple module C++ class (i.e. one derived from <tt>cSimpleModule</tt>)
for a compound module.

<p>The <tt>cChannel</tt>'s subclasses include the three built-in channel
types: <tt>cIdealChannel</tt>, <tt>cDelayChannel</tt>, and
<tt>cDatarateChannel</tt>. The user can create new channel types
by subclassing <tt>cChannel</tt> or any other channel class.

<p>The following inheritance diagram illustrates the relationship
of the classes mentioned above.

<p>
  <center>
    <img src="component-inheritance.svg">
    <center><div class="caption"><i>Figure: Inheritance of component, module, and channel classes</i></div></center>
  </center>

<p>
Simple modules and channels can be programmed by redefining certain
member functions and providing your own code in them. Some of those
member functions are declared on <tt>cComponent</tt>, the common base
class of channels and modules.

<p><tt>cComponent</tt> has the following member functions meant for
redefining in subclasses:

<p><ul>
  <li> <tt>initialize()</tt>. This method is invoked after OMNeT++ has
    set up the network (i.e., created modules and connected them according
    to the definitions) and provides a place for initialization code.
  <li> <tt>finish()</tt> is called when the simulation has terminated
    successfully, and it is recommended to use it for recording summary
    statistics.
</ul>

<p><tt>initialize()</tt> and <tt>finish()</tt>, together with <tt>initialize()</tt>'s
variants for multi-stage initialization, will be covered in detail in
section <a href="chap4.html#sec:simple-modules:initialize-and-finish">[4.3.3]</a>.

<p>In OMNeT++, events occur inside simple modules<!--module!simple-->.
Simple modules encapsulate C++ code that generates events and reacts to events,
implementing the behavior of the module.

<p>To define the dynamic behavior of a simple module, one of the following
member functions needs to be overridden:

<p><ul>
  <li> <tt>handleMessage(cMessage *msg)</tt>. It
     is invoked with the message as a parameter whenever the
     module receives a message. <tt>handleMessage()</tt> is
     expected to <i>process</i> the message and then return.
     Simulation time never elapses inside <tt>handleMessage()</tt> calls, only between them.
  <li> <tt>activity()</tt> is started as a coroutine<br><ul><font size=-1>[Cooperatively
     scheduled thread, explained later.]</font></ul> at the beginning of the simulation, and
     it runs until the end of the simulation (or until the function
     returns or otherwise terminates). Messages are obtained with
     <tt>receive()</tt> calls. Simulation time elapses inside
     <tt>receive()</tt> calls.
</ul>

<p>Modules written with <tt>activity()</tt> and <tt>handleMessage()</tt> can be
freely mixed within a simulation model. Generally, <tt>handleMessage()</tt>
should be preferred to <tt>activity()</tt>, due to scalability and other
practical reasons. The two functions will be described in detail in sections
<a href="chap4.html#sec:simple-modules:handlemessage">[4.4.1]</a> and <a href="chap4.html#sec:simple-modules:activity">[4.4.2]</a>,
including their advantages and disadvantages.

<p>The behavior of channels can also be modified by redefining member functions.
However, the channel API is slightly more complicated than that of simple
modules, so we'll describe it in a later section (<a href="chap4.html#sec:simple-modules:channels">[4.8]</a>).

<p>Last, let us mention <tt>refreshDisplay()</tt>, which is related to updating
the visual appearance of the simulation when run under a graphical user
interface. <tt>refreshDisplay()</tt> is covered in the chapter that deals
with simulation visualization (<a href="chap8.html#sec:graphics:refreshdisplay">[8.2]</a>).

<p><ul class="note"><b>NOTE</b><br>
    <tt>refreshDisplay()</tt> has been added in OMNeT++ 5.0. Until then,
    visualization-related tasks were usually implemented as part of
    <tt>handleMessage()</tt>. <tt>refreshDisplay()</tt> provides
    a far superior and more efficient solution.
</ul>

<p>
<h2><a name="sec:simple-modules:defining-simple-modules"/>4.3 Defining Simple Module Types<a class="headerlink" href="#sec:simple-modules:defining-simple-modules" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:defining:overview"/>4.3.1 Overview<a class="headerlink" href="#sec:simple-modules:defining:overview" title="Permalink to this headline">¶</a></h3>

<p>As mentioned before, a simple module<!--module!simple--> is nothing more
than a C++ class which needs to be subclassed from <tt>cSimpleModule</tt>,
with one or more virtual member functions redefined to define its behavior.

<p>The class needs to be registered with OMNeT++ via the <tt>Define_Module()</tt> macro.
The <tt>Define_Module()</tt> line should always be placed in <tt>.cc</tt> or <tt>.cpp</tt>
files and not in the header file (<tt>.h</tt>), because the compiler generates code from it.

<p>The following <tt>HelloModule</tt> is one of the simplest simple modules that can be written.
(We could have omitted the <tt>initialize()</tt> method as well to make it even smaller,
but then how would it say Hello?) Note the use of <tt>cSimpleModule</tt> as the base class,
and the <tt>Define_Module()</tt> line.

<pre class="cpp">
// file: HelloModule.cc
#include &lt;omnetpp.h&gt;
using namespace omnetpp;

class HelloModule : public cSimpleModule
{
  protected:
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

// register module class with OMNeT++
Define_Module(HelloModule);

void HelloModule::initialize()
{
    EV &lt;&lt; "Hello World!\n";
}

void HelloModule::handleMessage(cMessage *msg)
{
    delete msg; // just discard everything we receive
}
</pre>
<p>
In order to refer to this simple<!--module!simple--> module type in NED files,
an associated NED declaration is also needed, which might look like this:

<pre class="ned">
// file: HelloModule.ned
simple HelloModule
{
    gates:
        input in;
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:module-ctor"/>4.3.2 Constructor<a class="headerlink" href="#sec:simple-modules:module-ctor" title="Permalink to this headline">¶</a></h3>

<p>Simple modules are never directly instantiated by the user, but rather by
the simulation kernel. This means that arbitrary constructors cannot be used:
the signature must be what is expected by the simulation kernel.
Luckily, this contract is very simple: the constructor must be public and must take
no arguments:

<pre class="cpp">
  public:
    HelloModule();  // constructor takes no arguments
</pre>
<p>
<tt>cSimpleModule</tt> itself has two constructors:
<ol>
  <li> <tt>cSimpleModule()</tt> -- constructor without arguments
  <li> <tt>cSimpleModule(size_t stacksize)</tt> -- constructor that accepts the coroutine
        stack size<!--module!stack size--><!--stack!size-->
</ol>

<p>The first version should be used with <tt>handleMessage()</tt> simple modules,
and the second one with <tt>activity()</tt> modules.
(With the latter, the <tt>activity()</tt> method of the module class
runs as a coroutine<!--coroutine--> that needs a separate CPU stack,
usually of 16..32K. This will be discussed in detail later.)
Passing zero stack size to the latter constructor also selects <tt>handleMessage()</tt>.

<p>Therefore, the following constructor definitions are all correct and select
<tt>handleMessage()</tt> to be used with the module:

<pre class="cpp">
HelloModule::HelloModule() {...}
HelloModule::HelloModule() : cSimpleModule() {...}
</pre>
<p>
It is also correct to omit the constructor altogether, because the
compiler-generated one is suitable too.

<p>The following constructor definition selects <tt>activity()</tt> to be used
with the module, with 16K of coroutine stack:

<pre class="cpp">
HelloModule::HelloModule() : cSimpleModule(16384) {...}
</pre>
<p>


<p><h3><a name="sec:simple-modules:initialize-and-finish"/>4.3.3 Initialization and Finalization<a class="headerlink" href="#sec:simple-modules:initialize-and-finish" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:init-finish:basic-usage"/>4.3.3.1 Basic Usage<a class="headerlink" href="#sec:simple-modules:init-finish:basic-usage" title="Permalink to this headline">¶</a></h4>

<p>The <tt>initialize()</tt> and <tt>finish()</tt> methods are declared
as part of <tt>cComponent</tt> and provide the user with the opportunity
to run code at the beginning and successful termination of the simulation.

<p>The reason <tt>initialize()</tt> exists is that simulation-related code
cannot usually be placed in the simple module's
constructor<!--module!constructor-->, because the simulation model is still
being set up when the constructor runs, and many required objects are not yet
available. In contrast, <tt>initialize()</tt> is called just before the
simulation starts executing, when everything else has already been set up.

<p><tt>finish()</tt> is used for recording statistics and is only called
when the simulation has terminated normally. It does not get called when
the simulation stops with an error message. The destructor always
gets called at the end, regardless of how the simulation stopped, but
at that time it is reasonable to assume that the simulation model has already been
partly destroyed.

<p>Based on the above considerations, the following conventions exist
for these four methods:

<p><ul class="dl">

<p><li> Constructor:

<p>Set pointer members of the module class to <tt>nullptr</tt>; postpone all other
initialization tasks to <tt>initialize()</tt>.

<p><li> <tt>initialize()</tt>:

<p>Perform all initialization tasks: read module parameters, initialize
class variables, allocate dynamic data structures with <tt>new</tt>,
and allocate and initialize self-messages (timers) if needed.

<p><li> <tt>finish()</tt>:

<p>Record statistics. Do <b>not</b> <tt>delete</tt> anything or cancel timers --
all cleanup must be done in the destructor.

<p><li> Destructor:

<p>Delete everything that was allocated by <tt>new</tt> and is still held
by the module class. When deleting self-messages (timers), use the
<tt>cancelAndDelete(msg)</tt> function! It is usually incorrect
to simply delete a self-message from the destructor, because it might be
in the scheduled events list. The <tt>cancelAndDelete(msg)</tt> function
first checks for that and cancels the message before deletion if necessary.

<p></ul>

<p>OMNeT++ prints the list of unreleased objects at the end of the simulation.
When a simulation model displays <i>"undisposed object ..."</i> messages, it indicates
that the corresponding module destructors need to be fixed. As a temporary measure, these
messages can be hidden by setting <tt>print-undisposed=false</tt> in the
configuration.

<p><ul class="note"><b>NOTE</b><br>
    The <tt>perform-gc</tt> configuration option has been removed in OMNeT++ 4.0.
    Automatic garbage collection cannot be reliably implemented due to the
    limitations of the C++ language.
</ul>

<p>
<h4><a name="sec:simple-modules:init-finish:invocation-order"/>4.3.3.2 Invocation Order<a class="headerlink" href="#sec:simple-modules:init-finish:invocation-order" title="Permalink to this headline">¶</a></h4>

<p>The <tt>initialize()</tt> functions of the modules are invoked <i>before</i>
the first event is processed, but <i>after</i> the initial events (starter
messages<!--starter messages-->) have been placed into the FES<!--FES--> by
the simulation kernel.

<p>Both simple and compound modules have <tt>initialize()</tt> functions. The
<tt>initialize()</tt> function of a compound module runs <i>before</i> that of
its submodules.

<p>The <tt>finish()</tt> functions are called when the event loop<!--event loop-->
has terminated, but only if it terminated normally.

<p><ul class="note"><b>NOTE</b><br>
<tt>finish()</tt> is not called if the simulation has terminated
with a runtime error.
</ul>

<p>The calling order for <tt>finish()</tt> is the reverse of the order of
<tt>initialize()</tt>: first the submodules, then the encompassing compound module.
  <br><ul><font size=-1>[To provide an <tt>initialize()</tt> function for a compound module,
  <tt>cModule</tt> needs to be subclassed, and the new class needs to be used
  for the compound module by adding the <tt>@class(&lt;classname&gt;)</tt> property to the NED declaration.]</font></ul>

<p>The following pseudocode summarizes this:

<p><pre class="verbatim">
<i>perform simulation run:</i>
    build network
      (i.e., create the system module and its submodules recursively)
    insert starter messages for all submodules using activity()
    do callInitialize() on the system module
        <i>enter event loop // (described earlier)</i>
    if (event loop terminated normally) // i.e., no errors
        do callFinish() on the system module
    clean up

callInitialize()
{
    call to user-defined initialize() function
    if (module is compound)
        for (each submodule)
            do callInitialize() on the submodule
}

callFinish()
{
    if (module is compound)
        for (each submodule)
            do callFinish() on the submodule
    call to user-defined finish() function
}
</pre>

<p>Keep in mind that <tt>finish()</tt> is not always called, so it is not
a suitable place for cleanup code that should run every time the module is
deleted. <tt>finish()</tt> is only appropriate for writing statistics,
result post-processing, and other operations that are intended to run only on
successful completion. Cleanup code should be placed in the
destructor<!--module!destructor-->.

<p>
<h4><a name="sec:simple-modules:multi-stage-init"/>4.3.3.3 Multi-Stage Initialization<a class="headerlink" href="#sec:simple-modules:multi-stage-init" title="Permalink to this headline">¶</a></h4>

<p>In simulation models where one-stage initialization<!--initialization-->
provided by <tt>initialize()</tt> is insufficient, multi-stage
initialization<!--initialization!multi-stage--> can be used. Modules have two
functions that can be redefined by the user:

<pre class="cpp">
virtual void initialize(int stage);
virtual int numInitStages() const;
</pre>
<p>
The initialization of modules is orchestrated in stages. It starts with the call
to <tt>initialize(0)</tt> for every module, initiating the first setup stage. Once
this is completed across all modules, the system proceeds to the next steps,
<tt>initialize(1)</tt>, <tt>initialize(2)</tt>, and so on, effectively allowing
modules to undergo additional configuration in a controlled, sequential order.

<p>To effectively manage this sequential setup, each module must declare how many
initial stages it requires by overriding the <tt>numInitStages()</tt> function.
For instance, if a module needs two phases of setup, this function should return
2. Subsequently, the module must also tailor the C++ <tt>$2</tt>initialize(int
stage) function to specify the operations that occur at each stage, such as
handling specific setups at <i>stage=0</i> and <i>stage=1</i>. This
organized approach to initialization ensures that each module is systematically
readied according to its operational needs within the broader simulation
context.<br><ul><font size=-1>[Note the <tt>const</tt> in the <tt>numInitStages()</tt> declaration.
  If you forget it, a <i>different</i> function is created instead of
  redefining the existing one in the base class, so the existing function
  remains in effect and returns 1.]</font></ul>

<p>The <tt>callInitialize()</tt> function performs the full multi-stage initialization
for the module and all its submodules.

<p>If the multi-stage initialization functions are not redefined, the
default behavior is single-stage initialization: the default
<tt>numInitStages()</tt> returns 1, and the default <tt>initialize(int stage)</tt>
simply calls <tt>initialize()</tt>.

<p>


<p><h2><a name="sec:simple-modules:handlemessage-and-activity"/>4.4 Adding Functionality to cSimpleModule<a class="headerlink" href="#sec:simple-modules:handlemessage-and-activity" title="Permalink to this headline">¶</a></h2>

<p>This section discusses <tt>cSimpleModule</tt>'s previously mentioned
<tt>handleMessage()</tt> and <tt>activity()</tt> member functions, which are
intended to be redefined by the user.

<p>
<h3><a name="sec:simple-modules:handlemessage"/>4.4.1 handleMessage()<a class="headerlink" href="#sec:simple-modules:handlemessage" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:handlemessage:overview"/>4.4.1.1 Function Called for Each Event<a class="headerlink" href="#sec:simple-modules:handlemessage:overview" title="Permalink to this headline">¶</a></h4>

<p>The idea is that at each event<!--event--> (message arrival), we
simply call a user-defined function. This function,
<tt>handleMessage(cMessage *msg)</tt>, is a
virtual member function of <tt>cSimpleModule</tt> which does
nothing by default -- the user has to redefine it in subclasses
and add the message processing code.

<p>The <tt>handleMessage()</tt> function will be called for every message
that arrives at the module. The function should process the message
and return immediately after that. The simulation time is potentially
different in each call. No simulation time elapses within a call
to <tt>handleMessage()</tt>.

<p>The event loop inside the simulator handles both <tt>activity()</tt>
and <tt>handleMessage()</tt> simple modules, and it corresponds
to the following pseudocode:

<p><pre class="verbatim">
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    m:= module containing this event
    if (m works with handleMessage())
        <b>m-&gt;handleMessage( event )</b>
    else // m works with activity()
        transferTo( m )
}
</pre>

<p>Modules with <tt>handleMessage()</tt> are NOT started automatically:
the simulation kernel creates starter messages<!--starter messages-->
only for modules with <tt>activity()</tt>. This means that you have to
schedule self-messages<!--self-message--> from the
<tt>initialize()</tt> function if you want a <tt>handleMessage()</tt>
simple module to start working &#8220;by itself&#8221;, without first receiving
a message from other modules.

<p>
<h4><a name="sec:simple-modules:handlemessage:programming"/>4.4.1.2 Programming with handleMessage()<a class="headerlink" href="#sec:simple-modules:handlemessage:programming" title="Permalink to this headline">¶</a></h4>

<p>To use the <tt>handleMessage()</tt> mechanism in a simple module, you must
specify <i>zero stack size</i><!--zero stack size--> for the module.
This is important because this tells OMNeT++ that you want to use
<tt>handleMessage()</tt>, not <tt>activity()</tt>.

<p>Message/event related functions you can use in <tt>handleMessage()</tt>:

<p><ul>
  <li> <tt>send()</tt> family of functions -- to send messages to other modules
  <li> <tt>scheduleAt()</tt> -- to schedule an event (the module &#8220;sends a message to itself&#8221;)
  <li> <tt>cancelEvent()</tt> -- to delete an event scheduled with <tt>scheduleAt()</tt>
</ul>

<p>The <tt>receive()</tt> and <tt>wait()</tt> functions cannot be used in
<tt>handleMessage()</tt> because they are coroutine-based by nature, as
explained in the section about <tt>activity()</tt>.

<p>You have to add data members to the module class for every piece
of information you want to preserve. This information cannot
be stored in local variables of <tt>handleMessage()</tt> because they
are destroyed when the function returns. Also, they cannot be
stored in static variables in the function (or the class) because
they would be shared between all instances of the class.

<p>Data members to be added to the module class will typically include
things like:

<p><ul>
  <li> state (e.g. IDLE/BUSY, CONN_DOWN/CONN_ALIVE/...)
  <li> other variables which belong to the state of the module: retry
    counts, packet queues, etc.
  <li> values retrieved/computed once and then stored: values of module
    parameters, gate indices, routing information, etc.
  <li> pointers of message objects created once and then reused for
    timers, timeouts, etc.
  <li> variables/objects for statistics collection
</ul>

<p>These variables are often initialized from the <tt>initialize()</tt>
method because the information needed to obtain the initial value
(e.g. module parameters) may not yet be available at the time the
module constructor runs.

<p>Another task to be done in <tt>initialize()</tt> is to schedule
initial event(s)<!--events!initial--> which trigger the first call(s)
to <tt>handleMessage()</tt>.  After the first call,
<tt>handleMessage()</tt> must take care to schedule further events for
itself so that the &#8220;chain&#8221; is not broken. Scheduling events is not
necessary if your module only has to react to messages coming from
other modules.

<p><tt>finish()</tt> is normally used to record statistics information
accumulated in data members of the class at the end of the simulation.

<p>
<h4><a name="sec:simple-modules:handlemessage:application-area"/>4.4.1.3 Application Area<a class="headerlink" href="#sec:simple-modules:handlemessage:application-area" title="Permalink to this headline">¶</a></h4>

<p><tt>handleMessage()</tt> is in most cases a better choice than <tt>activity()</tt>:

<p><ol>
  <li> When you expect the module to be used in large simulations
      involving several thousand modules. In such cases, the module stacks
      required by <tt>activity()</tt> would simply consume too much memory.
  <li> For modules that maintain little or no state information,
      such as packet sinks, <tt>handleMessage()</tt> is more convenient to program.
  <li> Other good candidates are modules with a large state space and
      many arbitrary state transition possibilities (i.e. where there
      are many possible subsequent states for any state). Such algorithms
      are difficult to program with <tt>activity()</tt> and
      better suited for <tt>handleMessage()</tt> (see rule of thumb
      below). This is the case for most communication protocols.
</ol>

<p>
<h4><a name="sec:simple-modules:handlemessage:protocol-model-example"/>4.4.1.4 Example 1: Protocol Models<a class="headerlink" href="#sec:simple-modules:handlemessage:protocol-model-example" title="Permalink to this headline">¶</a></h4>

<p>Models of protocol layers in a communication network tend to have
a common structure on a high level because fundamentally they all have to react
to three types of events: messages arriving from higher layer protocols
(or apps), messages arriving from lower layer protocols (from the network),
and various timers and timeouts (self-messages).

<p>This usually results in the following source code pattern:

<pre class="cpp">
class FooProtocol : public cSimpleModule
{
  protected:
    // state variables
    // ...

    virtual void processMsgFromHigherLayer(cMessage *packet);
    virtual void processMsgFromLowerLayer(FooPacket *packet);
    virtual void processTimer(cMessage *timer);

    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

// ...

void FooProtocol::handleMessage(cMessage *msg)
{
    if (msg-&gt;isSelfMessage())
        processTimer(msg);
    else if (msg-&gt;arrivedOn("fromNetw"))
        processMsgFromLowerLayer(check_and_cast&lt;FooPacket *&gt;(msg));
    else
        processMsgFromHigherLayer(msg);
}
</pre>
<p>
The functions <tt>processMsgFromHigherLayer()</tt>, <tt>processMsgFromLowerLayer()</tt>,
and <tt>processTimer()</tt> are then usually split further: there are separate
methods to process separate packet types and separate timers.

<p>
<h4><a name="sec:simple-modules:handlemessage:traffic-generator-example"/>4.4.1.5 Example 2: Simple Traffic Generators and Sinks<a class="headerlink" href="#sec:simple-modules:handlemessage:traffic-generator-example" title="Permalink to this headline">¶</a></h4>

<p>
The code for simple packet generators and sinks programmed with
<tt>handleMessage()</tt> might be as simple as the following pseudocode:

<pre class="cpp">
PacketGenerator::handleMessage(msg)
{
    create and send out a new packet;
    schedule msg again to trigger next call to handleMessage;
}

PacketSink::handleMessage(msg)
{
    delete msg;
}
</pre>
<p>
Note that <i>PacketGenerator</i> will need to redefine <tt>initialize()</tt>
to create <i>m</i> and schedule the first event.

<p>The following simple module generates packets with exponential
inter-arrival time. (Some details in the source haven't been
discussed yet, but the code is probably understandable nevertheless.)

<p>
<pre class="cpp">
class Generator : public cSimpleModule
{
  public:
    Generator() : cSimpleModule() {}
  protected:
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

Define_Module(Generator);

void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new cMessage);
}

void Generator::handleMessage(cMessage *msg)
{
    // generate & send packet
    cMessage *pkt = new cMessage;
    send(pkt, "out");
    // schedule next call
    scheduleAt(simTime()+exponential(1.0), msg);
}
</pre>

<p>

<p><h4><a name="sec:simple-modules:handlemessage:bursty-trafgen-example"/>4.4.1.6 Example 3: Bursty Traffic Generator<a class="headerlink" href="#sec:simple-modules:handlemessage:bursty-trafgen-example" title="Permalink to this headline">¶</a></h4>

<p>A bit more realistic example is to rewrite our Generator to create
packet bursts, each consisting of <tt>burstLength</tt> packets.

<p>We add some data members to the class:
<ul>
<li> <tt>burstLength</tt> will store the parameter that specifies how many
    packets a burst must contain,
<li> <tt>burstCounter</tt> will count how many packets are left to be sent
    in the current burst.
</ul>

<p>The code:

<pre class="cpp">
class BurstyGenerator : public cSimpleModule
{
  protected:
    int burstLength;
    int burstCounter;

    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burstLength = par("burstLength");
    burstCounter = burstLength;
    // schedule first packet of first burst
    scheduleAt(simTime(), new cMessage);
}

void BurstyGenerator::handleMessage(cMessage *msg)
{
    // generate & send packet
    cMessage *pkt = new cMessage;
    send(pkt, "out");
    // if this was the last packet of the burst
    if (--burstCounter == 0) {
        // schedule next burst
        burstCounter = burstLength;
        scheduleAt(simTime()+exponential(5.0), msg);
    }
    else {
        // schedule next sending within burst
        scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</pre>
<p>

<p>
<h4><a name="sec:simple-modules:handlemessage:pros-and-cons"/>4.4.1.7 Pros and Cons of Using <tt>handleMessage()</tt><a class="headerlink" href="#sec:simple-modules:handlemessage:pros-and-cons" title="Permalink to this headline">¶</a></h4>

<p>Pros:
<ul>
  <li> consumes less memory: no separate stack needed for simple modules
  <li> fast: function call is faster than switching between coroutines<!--coroutine-->
</ul>

<p>Cons:
<ul>
  <li> local variables cannot be used to store state information
  <li> need to redefine <tt>initialize()</tt>
</ul>

<p>Usually, <tt>handleMessage()</tt> should be preferred over <tt>activity()</tt>.

<p>


<p>
<h3><a name="sec:simple-modules:activity"/>4.4.2 activity()<a class="headerlink" href="#sec:simple-modules:activity" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:activity:overview"/>4.4.2.1 Process-Style Description<a class="headerlink" href="#sec:simple-modules:activity:overview" title="Permalink to this headline">¶</a></h4>

<p>With <tt>activity()</tt>, a simple module can be coded much like an
operating system process or thread. One can wait for an incoming message
(event) at any point in the code, suspend the execution for some time
(model time!), etc. When the <tt>activity()</tt> function exits, the module
is terminated (the simulation can continue if there are other modules
that can run).

<p>The most important functions that can be used in <tt>activity()</tt> are
(they will be discussed in detail later):
<ul>
<li> <tt>receive()</tt> -- to receive messages (events)
<li> <tt>wait()</tt> -- to suspend execution<!--suspend execution-->
    for some time (model time)
<li> <tt>send()</tt> family of functions -- to send messages to other
    modules
<li> <tt>scheduleAt()</tt> -- to schedule an event (the module "sends
    a message to itself")
<li> <tt>cancelEvent()</tt> -- to delete an event scheduled with
    <tt>scheduleAt()</tt>
<li> <tt>end()</tt> -- to finish execution of this module (same as
    exiting the <tt>activity()</tt> function)
</ul>

<p>The <tt>activity()</tt> function normally contains an infinite loop,
with at least a <tt>wait()</tt> or <tt>receive()</tt> call in its body.

<p>

<p><h4><a name="sec:simple-modules:activity:application-area"/>4.4.2.2 Application Area<a class="headerlink" href="#sec:simple-modules:activity:application-area" title="Permalink to this headline">¶</a></h4>

<p>In general, you should prefer <tt>handleMessage()</tt> to <tt>activity()</tt>.
The main problem with <tt>activity()</tt> is that it does not scale because
every module needs a separate coroutine stack. It has also been observed
that <tt>activity()</tt> does not encourage good programming style, and
stack switching can confuse many debuggers.

<p>There is one scenario where <tt>activity()</tt>'s process-style
description is convenient: when the process has many
states, but transitions are very limited, i.e., from any state the
process can only go to one or two other states.  For example, this is
the case when programming a network application that uses a single
network connection.  The pseudocode of the application, which talks to
a transport layer protocol, might look like this:

<p><pre class="verbatim">
<i>activity()</i>
{
    while(true)
    {
        open the connection by sending OPEN command to the transport layer
        receive the reply from the transport layer
        if (the open is not successful)
        {
            wait(some time)
            continue // loop back to while()
        }

        while (there is more to do)
        {
            send data on the network connection
            if (the connection is broken)
            {
                continue outer loop // loop back to the outer while()
            }
            wait(some time)
            receive data on the network connection
            if (the connection is broken)
            {
                continue outer loop // loop back to the outer while()
            }
            wait(some time)
        }
        close the connection by sending CLOSE command to the transport layer
        if (the close is not successful)
        {
            // handle error
        }
        wait(some time)
    }
}
</pre>

<p>If there is a need to handle several connections concurrently, dynamically creating
simple modules to handle each is an option. Dynamic module creation will be discussed
later.

<p>There are situations when you certainly do not want to use <tt>activity()</tt>.
If the <tt>activity()</tt> function contains no <tt>wait()</tt> and has only one
<tt>receive()</tt> at the top of a message handling loop, there is no point in
using <tt>activity()</tt>, and the code should be written with <tt>handleMessage()</tt>.
The body of the loop would then become the body of <tt>handleMessage()</tt>,
state variables inside <tt>activity()</tt> would become data members in
the module class, and they would be initialized in <tt>initialize()</tt>.

<p>For example, a <tt>Sink</tt> implementation:

<pre class="cpp">
void Sink::activity()
{
    while(true) {
        msg = receive();
        delete msg;
    }
}
</pre>
<p>
should rather be programmed as:

<pre class="cpp">
void Sink::handleMessage(cMessage *msg)
{
    delete msg;
}
</pre>
<p>

<p>
<h4><a name="sec:simple-modules:activity:coroutine"/>4.4.2.3 activity() Is Run as a Coroutine<a class="headerlink" href="#sec:simple-modules:activity:coroutine" title="Permalink to this headline">¶</a></h4>

<p><tt>activity()</tt> runs as a coroutine<!--coroutine-->.
Coroutines are similar to threads, but are scheduled
non-preemptively (this is also called cooperative
multitasking<!--multitasking!cooperative-->).
One can switch from one coroutine to another by a
<tt>transferTo(otherCoroutine)</tt> call, causing the first coroutine
to be suspended and the second one to run. Later, when the
second coroutine performs a <tt>transferTo(firstCoroutine)</tt> call
to the first one, the execution of the first coroutine resumes
from the point of the <tt>transferTo(otherCoroutine)</tt> call.
The full state of the coroutine, including local variables, is preserved
while the thread of execution is in other coroutines.  This implies that each
coroutine has its own CPU stack<!--stack-->, and
<tt>transferTo()</tt> involves switching from one CPU stack to
another.

<p>Coroutines<!--coroutine--> are at the heart of OMNeT++, and the
simulation programmer doesn't ever need to call <tt>transferTo()</tt>
or other functions in the coroutine library, nor does the programmer need to care
about the coroutine library implementation. It is important to
understand, however, how the event loop works with coroutines.

<p>When using coroutines, the event loop<!--event loop--> looks like
this (simplified):

<p>
<pre class="verbatim">
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve the first event from FES
    t:= the timestamp of this event
    m:= the module containing this event
    if (m works with <tt>handleMessage()</tt>)
        m-&gt;handleMessage(event)
    else // m works with <tt>activity()</tt>
        <b>transferTo(m)</b>
}
</pre>

<p>

<p>That is, when a module has an event<!--event-->, the simulation
kernel transfers control to the module's coroutine. It is expected
that when the module &#8220;decides it has finished processing the
event&#8221;, it will transfer control back to the simulation kernel by
a <tt>transferTo(main)</tt> call. Initially,
simple<!--module!simple--> modules using <tt>activity()</tt> are
booted by events (starter messages<!--starter messages-->)
inserted into the FES<!--FES--> by the simulation kernel before the
start of the simulation.

<p>
How does the coroutine know it has &#8220;finished processing the event&#8221;?
The answer: <i>when it requests another event</i>.  The functions
that request events from the simulation kernel are <tt>receive()</tt> and
<tt>wait()</tt>, so their
implementations contain a <tt>transferTo(main)</tt> call
somewhere.

<p>
Their pseudocode, as implemented in OMNeT++, is:

<p>
<pre class="verbatim">
receive()
{
    transferTo(main)
    retrieve the current event
    return the event // remember: events = messages
}

wait()
{
    create the event e
    schedule it at (current simulation time + wait interval)
    transferTo(main)
    retrieve the current event
    if (the current event is not e) {
        error
    }
    delete e  // note: actual implementation reuses events
    return
}
</pre>

<p>

<p>Thus, the <tt>receive()</tt> and <tt>wait()</tt> calls are
special points in the <tt>activity()</tt> function because
they are where

<p><ul>
  <li> simulation time elapses in the module, and
  <li> other modules get a chance to execute.
</ul>

<p>
<h4><a name="simple-modules:activity:starter-messages"/>4.4.2.4 Starter Messages<a class="headerlink" href="#simple-modules:activity:starter-messages" title="Permalink to this headline">¶</a></h4>

<p>Modules written with <tt>activity()</tt> need starter
messages<!--starter messages--> to &#8220;boot&#8221;.  These starter messages
are inserted into the FES<!--FES--> automatically by OMNeT++ at the
beginning of the simulation, even before the <tt>initialize()</tt>
functions are called.

<p>
<h4><a name="sec:simple-modules:activity:stack-size"/>4.4.2.5 Coroutine Stack Size<a class="headerlink" href="#sec:simple-modules:activity:stack-size" title="Permalink to this headline">¶</a></h4>

<p>The simulation programmer needs to define the CPU stack size<!--coroutine!stack size-->
for coroutines. This cannot be automated.

<p>16 or 32 kbytes is usually a good choice, but more space may be needed
if the module uses recursive functions or has many/large local variables.
OMNeT++ has a built-in mechanism that usually detects if the module stack
is too small and overflows<!--stack!overflow-->. OMNeT++ can also report how
much stack space a module actually uses<!--stack!usage--> at runtime.

<p>
<h4><a name="sec:simple-modules:activity:initialize-and-finish"/>4.4.2.6 initialize() and finish() with activity()<a class="headerlink" href="#sec:simple-modules:activity:initialize-and-finish" title="Permalink to this headline">¶</a></h4>

<p>Because local variables of <tt>activity()</tt> are preserved across
events, you can store everything (state information, packet buffers,
etc.) in them. Local variables can be initialized at the top of the
<tt>activity()</tt> function, so there isn't much need to use
<tt>initialize()</tt>.

<p>You do need <tt>finish()</tt> if you want to write statistics at
the end of the simulation. Because <tt>finish()</tt> cannot access
the local variables of <tt>activity()</tt>, you have to put the variables
and objects containing the statistics into the module class.
You still don't need <tt>initialize()</tt> because class members can also
be initialized at the top of <tt>activity()</tt>.

<p>A typical setup looks like this in pseudocode:

<p><pre class="verbatim">
<i>class MySimpleModule...</i>
{
    ...
    variables for statistics collection
    activity();
    finish();
};

MySimpleModule::activity()
{
    declare local variables and initialize them
    initialize statistics collection variables

    while(true)
    {
        ...
    }
}

MySimpleModule::finish()
{
    record statistics into file
}
</pre>

<p>
<h4><a name="sec:simple-modules:activity:pros-and-cons"/>4.4.2.7 Pros and Cons of Using <tt>activity()</tt><a class="headerlink" href="#sec:simple-modules:activity:pros-and-cons" title="Permalink to this headline">¶</a></h4>

<p>Pros:
<ul>
   <li> <tt>initialize()</tt> not needed; state can be stored in local
       variables of <tt>activity()</tt>
   <li> process-style description is a natural programming model in some cases
</ul>

<p>Cons:
<ul>
   <li> limited scalability: coroutine stacks can unacceptably increase the
       memory requirements of the simulation program if there are many
       <tt>activity()</tt>-based simple modules;
   <li> run-time overhead: switching between coroutines is slower than
       a simple function call
   <li> does not encourage good programming style: as module complexity
       grows, <tt>activity()</tt> tends to become a large, monolithic function.
</ul>

<p>In most cases, cons outweigh pros, and it is a better idea to use
<tt>handleMessage()</tt> instead.

<p>

<h3><a name="sec:simple-modules:global-vars"/>4.4.3 Use Modules Instead of Global Variables<a class="headerlink" href="#sec:simple-modules:global-vars" title="Permalink to this headline">¶</a></h3>
<!--global variables-->

<p>If possible, avoid using global variables, including
static class members. They are prone to causing several problems.
First, they are not reset to their initial values (to zero)
when you rebuild the simulation in Qtenv or start another run
in Cmdenv. This may produce surprising results.
Second, they prevent you from parallelizing the simulation.
When using parallel simulation, each partition of the model
runs in a separate process, having its own copies of
global variables. This is usually not what you want.

<p>The solution is to encapsulate the variables into simple modules
as private or protected data members and expose them via public methods.
Other modules can then call these public methods to get or set the values.
Calling methods of other modules will be discussed in section
<a href="chap4.html#sec:simple-modules:direct-method-calls">[4.12]</a>.
Examples of such modules are <tt>InterfaceTable</tt> and <tt>RoutingTable</tt>
in the <i>INET Framework</i>.

<p>
<h3><a name="sec:simple-modules:module-subclassing"/>4.4.4 Reusing Module Code via Subclassing<a class="headerlink" href="#sec:simple-modules:module-subclassing" title="Permalink to this headline">¶</a></h3>

<p>The code of simple modules can be reused via subclassing and redefining
virtual member functions. For example:

<pre class="cpp">
class TransportProtocolExt : public TransportProtocol
{
  protected:
    virtual void recalculateTimeout();
};

Define_Module(TransportProtocolExt);

void TransportProtocolExt::recalculateTimeout()
{
    //...
}
</pre>
<p>
The corresponding NED declaration:

<pre class="ned">
simple TransportProtocolExt extends TransportProtocol
{
    @class(TransportProtocolExt);  // Important!
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Note the <tt>@class()</tt> property, which tells OMNeT++ to use the
  <tt>TransportProtocolExt</tt> C++ class for the module type! It is needed
  because NED inheritance is NED inheritance <i>only</i>, so without <tt>@class()</tt>
  the <tt>TransportProtocolExt</tt> NED type would inherit the C++ class from
  its base NED type.
</ul>

<p>

<p><h2><a name="sec:simple-modules:parameters"/>4.5 Accessing Module Parameters<a class="headerlink" href="#sec:simple-modules:parameters" title="Permalink to this headline">¶</a></h2>

<p>Module parameters declared in NED files are represented with the <tt>cPar</tt>
class at runtime and can be accessed<!--module!accessing parameters--> by
calling the <tt>par()</tt> member function of <tt>cComponent</tt>:

<pre class="cpp">
cPar& delayPar = par("delay");
</pre>
<p>

<p><h3><a name="sec:simple-modules:parameters-reading"/>4.5.1 Reading the Value<a class="headerlink" href="#sec:simple-modules:parameters-reading" title="Permalink to this headline">¶</a></h3>

<p>The value in a <tt>cPar</tt> object can be read with methods that correspond to
the parameter's NED type: <tt>boolValue()</tt>, <tt>intValue()</tt>,
<tt>doubleValue()</tt>, <tt>stringValue()</tt>/<tt>stdstringValue()</tt>,
<tt>objectValue()</tt>, <tt>xmlValue()</tt>. There are also overloaded typecast
operators for the corresponding types (<tt>bool</tt>, integer types including
<tt>int</tt> and <tt>long</tt>, <tt>double</tt>, <tt>const char *</tt>, <tt>cObject*</tt>, and
<tt>cXMLElement*</tt>).

<pre class="cpp">
long numJobs = par("numJobs").intValue();
double processingDelay = par("processingDelay"); // using operator double()
</pre>
<p>
Note that <tt>cPar</tt> has two methods for returning a string value:
<tt>stringValue()</tt>, which returns <tt>const char *</tt>, and
<tt>stdstringValue()</tt>, which returns <tt>std::string</tt>. For volatile
parameters, only <tt>stdstringValue()</tt> may be used, but otherwise the two are
interchangeable.

<p>If you use the <tt>par("foo")</tt> parameter in expressions (such as
<tt>4*par("foo")+2</tt>), the C++ compiler may be unable to decide between
overloaded operators and report ambiguity. This issue can be resolved by adding
an explicit cast such as <tt>(double)par("foo")</tt>, or using the
<tt>doubleValue()</tt> or <tt>intValue()</tt> methods.

<p>
<h3><a name="sec:simple-modules:volatile-parameters"/>4.5.2 Volatile versus Non-Volatile Parameters<a class="headerlink" href="#sec:simple-modules:volatile-parameters" title="Permalink to this headline">¶</a></h3>

<p>Volatile parameters in OMNeT++ are designed to provide dynamic values that
are recalculated every time they are accessed. This feature is particularly
useful for simulations requiring variability and unpredictability in parameter
values.

<p>Parameters can be declared volatile by marking them with the <b><tt>volatile</tt></b>
keyword in the NED file. When a parameter is marked as volatile, that indicates
that reading the parameter's value will cause a re-evaluation of the NED
expression, which, due to possible calls to the random number generator, may
yield a different value each time. Consequently, within the model code, it is
essential to re-fetch the parameter's value each time it is required during
simulation. In other words, simply reading the parameter once in the
<tt>initialize()</tt> function and storing that value for subsequent use is
incorrect.

<p>Volatile parameters are often used to allow stochastic input, such as random
packet generation intervals specified e.g. as <tt>exponential(1.0)</tt> (numbers
drawn from the exponential distribution with mean 1.0).

<p>Note that non-volatile NED parameters behave differently: reading their values
multiple times is guaranteed to yield the same value every time. For
non-volatile parameters, the NED expression is evaluated only once and the
result is stored, so all reads will yield the same value. When a non-volatile
parameter is assigned an expression like <tt>exponential(1.0)</tt>, multiple reads
will yield the same randomly chosen value.

<p>The typical usage for non-volatile parameters is to read them in the
<tt>initialize()</tt> method of the module class and store the values in class
variables for easy access later:

<pre class="cpp">
class Source : public cSimpleModule
{
  protected:
    long numJobs;
    virtual void initialize();
    ...
};

void Source::initialize()
{
    numJobs = par("numJobs");
    ...
}
</pre>
<p>
<tt>volatile</tt> parameters need to be re-read every time the value is needed. For
example, a parameter that represents a random packet generation interval may be
used like this:

<pre class="cpp">
void Source::handleMessage(cMessage *msg)
{
    ...
    scheduleAt(simTime() + par("interval").doubleValue(), timerMsg);
    ...
}
</pre>
<p>
This code looks up the parameter by name every time. This lookup can be avoided
by storing the parameter object's pointer in a class variable, resulting in the
following code:

<pre class="cpp">
class Source : public cSimpleModule
{
  protected:
    cPar *intervalp;
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
    ...
};

void Source::initialize()
{
    intervalp = &par("interval");
    ...
}

void Source::handleMessage(cMessage *msg)
{
    ...
    scheduleAt(simTime() + intervalp-&gt;doubleValue(), timerMsg);
    ...
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:object-parameters"/>4.5.3 Object Parameters<a class="headerlink" href="#sec:simple-modules:object-parameters" title="Permalink to this headline">¶</a></h3>

<p>Parameters declared with the type <b><tt>object</tt></b> in NED can be accessed with
the <tt>objectValue()</tt> method of <tt>cPar</tt>. It returns a pointer of the
type <tt>cObject*</tt>, which then must be cast to the appropriate type using
<tt>check_and_cast()</tt> or <tt>dynamic_cast()</tt>.

<p>For example, if a module has a parameter declared as follows:
<pre class="ned">
  object packetToSend;
</pre>

<p>Then one can access this object parameter in C++ with the following line:

<pre class="cpp">
cPacket *packet = check_and_cast&lt;cPacket*&gt;(par("packetToSend").objectValue());
</pre>
<p>
Object parameters allow for JSON-style parameters and many interesting use
cases. These use cases, along with real-life examples, were presented in the NED
chapter, section <a href="chap3.html#sec:ned-lang:object-parameters">[3.6.8]</a>.

<p>
<h3><a name="sec:simple-modules:json-style-parameters"/>4.5.4 JSON-Style Parameters<a class="headerlink" href="#sec:simple-modules:json-style-parameters" title="Permalink to this headline">¶</a></h3>

<p>In OMNeT++, JSON-style parameters introduced in version 6.0 offer a flexible
way to pass structured data to simulation modules. The NED expression syntax was
extended with JSON-like list and map (dictionary) syntaxes, which allows the
user to express data structures as JSON.

<p>These data structures appear in C++ as object trees, with lists represented by
the <tt>cValueArray</tt> class, and dictionaries represented by the
<tt>cValueMap</tt> class. Values inside <tt>cValueArray</tt> and
<tt>cValueMap</tt> are stored in <tt>cValue</tt> instances. When a single value
is assigned to an object parameter, it is represented as a <tt>cValue</tt>
wrapped in a <tt>cValueHolder</tt>. <br><ul><font size=-1>[Object parameters were introduced
in version 6.0 of OMNeT++. In earlier versions, string parameters were often used
to emulate arrays and were parsed with the help of the <tt>cStringTokenizer</tt>
class and its convenience methods, such as <tt>asIntVector()</tt> and
<tt>asDoubleVector()</tt>.]</font></ul>

<p>To query and process JSON-style parameters in your module's C++ code,
particularly within the <tt>initialize()</tt> method, you would retrieve the object
using the <tt>par()</tt> and <tt>objectValue()</tt> methods, cast them to the
appropriate type, then use the methods provided by the above classes to access
the structured data.

<p>Let us see an example. Consider a module that needs to process a routing table
defined as a JSON-style parameter. The routing table is an array of route
objects, each specifying <tt>dest</tt>, <tt>netmask</tt>, <tt>interf</tt>, and
<tt>metric</tt>.

<p>In the module's NED file, we define the parameter as follows:

<pre class="ned">
  object routes;
</pre>
<p>
We assign the routes in the ini file:

<pre class="inifile">
**.routes = [
        {dest: "10.0.0.0", netmask: "255.255.0.0", interf: "eth0", metric: 10},
        {dest: "10.1.0.0", netmask: "255.255.0.0", interf: "eth1", metric: 20},
        // Additional routes...
    ]
</pre>
<p>
In the module's <tt>initialize()</tt> method, you can process this parameter as follows:

<pre class="cpp">
#include &lt;omnetpp.h&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace omnetpp;

class RoutingModule : public cSimpleModule {
protected:
    virtual void initialize() override {
        // Access the parameter
        cValueArray *routesArray = check_and_cast&lt;cValueArray*&gt;(par("routes").objectValue());

        // Iterate over the array
        for (int i = 0; i &lt; routesArray-&gt;size(); ++i) {
            cValueMap *route = check_and_cast&lt;cValueMap*&gt;(&(routesArray-&gt;get(i)));

            // Extract route information
            std::string dest = (*route)["dest"].stringValue();
            std::string netmask = (*route)["netmask"].stringValue();
            std::string interf = (*route)["interf"].stringValue();
            int metric = (*route)["metric"].intValue();

            // Process the route (example: add to internal routing table)
            addRoute(dest, netmask, interf, metric);
        }
    }

    void addRoute(const std::string& dest, const std::string& netmask,
                  const std::string& interf, int metric) {
        // Implementation of route addition to the internal routing table
    }
};
</pre>
<p>
This example demonstrates how to access a JSON-style parameter (<tt>routes</tt>),
iterate over its elements (routes), and extract and use the data in the
simulation module's logic. The use of <tt>cValueMap</tt> and
<tt>cValueArray</tt> classes makes handling structured data straightforward,
resembling the process of working with JSON in high-level programming languages.

<p>Note that volatile object parameters yield a new object instance every time
the parameter is accessed.

<p>
<h3><a name="sec:simple-modules:setting-parameters"/>4.5.5 Changing a Parameter's Value<a class="headerlink" href="#sec:simple-modules:setting-parameters" title="Permalink to this headline">¶</a></h3>

<p>Parameter values can be changed from the program during execution. This is
rarely needed but may be useful for some scenarios.

<p><ul class="note"><b>NOTE</b><br>
    The parameter's type cannot be changed at runtime -- it must
    remain the type declared in the NED file. It is also not possible
    to add or remove module parameters at runtime.
</ul>

<p>The methods to set the parameter value are <tt>setBoolValue()</tt>,
<tt>setLongValue()</tt>, <tt>setStringValue()</tt>,
<tt>setDoubleValue()</tt>, <tt>setObjectValue()</tt>, <tt>setXMLValue()</tt>.
There are also overloaded assignment operators for various types including
<tt>bool</tt>, <tt>int</tt>, <tt>long</tt>, <tt>double</tt>, <tt>const char *</tt>,
<tt>cObject*</tt>, and <tt>cXMLElement*</tt>.

<p>To allow a module to be notified about parameter changes, override
its <tt>handleParameterChange()</tt> method, see
<a href="chap4.html#sec:simple-modules:handleparameterchange">[4.5.7]</a>.

<p>
<h3><a name="sec:simple-modules:further-cpar-methods"/>4.5.6 Further cPar Methods<a class="headerlink" href="#sec:simple-modules:further-cpar-methods" title="Permalink to this headline">¶</a></h3>

<p>The parameter's name and type are returned by the <tt>getName()</tt> and
<tt>getType()</tt> methods. The latter returns a value from an enum that can be
converted to a readable string with the <tt>getTypeName()</tt> static method. The
enum values are <tt>BOOL</tt>, <tt>DOUBLE</tt>, <tt>INT</tt>, <tt>STRING</tt>, <tt>OBJECT</tt>,
and <tt>XML</tt>, and since the enum is an inner type, they usually have to be
qualified with <tt>cPar::</tt>.

<p><tt>isVolatile()</tt> returns whether the parameter was declared volatile
in the NED file. <tt>isNumeric()</tt> returns true if the parameter
type is double or long.

<p>The <tt>str()</tt> method returns the parameter's value in a string form.
If the parameter contains an expression, then the string representation
of the expression is returned.

<p>An example usage of the above methods:

<pre class="cpp">
int n = getNumParams();
for (int i = 0; i &lt; n; i++)
{
    cPar& p = par(i);
    EV &lt;&lt; "parameter: " &lt;&lt; p.getName() &lt;&lt; "\n";
    EV &lt;&lt; "  type:" &lt;&lt; cPar::getTypeName(p.getType()) &lt;&lt; "\n";
    EV &lt;&lt; "  contains:" &lt;&lt; p.str() &lt;&lt; "\n";
}
</pre>
<p>
The NED properties of a parameter can be accessed with the <tt>getProperties()</tt>
method that returns a pointer to the <tt>cProperties</tt> object that stores
the properties of this parameter. Specifically, <tt>getUnit()</tt> returns
the unit of measurement associated with the parameter (<b><tt>@unit</tt></b> property in NED).

<p>Further <tt>cPar</tt> methods and related classes like <tt>cExpression</tt> and
<tt>cDynamicExpression</tt> are used by the NED infrastructure to set up and
assign parameters. They are documented in the <b>API Reference</b> but
they are normally of little interest to users.

<p>
<h3><a name="sec:simple-modules:handleparameterchange"/>4.5.7 Reacting to Parameter Changes<a class="headerlink" href="#sec:simple-modules:handleparameterchange" title="Permalink to this headline">¶</a></h3>

<p>It is possible for modules to be notified when the value of a parameter changes
at runtime, possibly due to another module dynamically changing it. The typical
action is to re-read the parameter and update the module's state if needed.

<p>To enable notification, redefine the <tt>handleParameterChange()</tt> method of
the module class. This method will be called back by the simulation kernel with
the parameter name as an argument every time a new value is assigned to a
parameter. The method signature is as follows:

<pre class="cpp">
void handleParameterChange(const char *parameterName);
</pre>
<p>
The following example shows a module that re-reads
its <tt>serviceTime</tt> parameter when its value changes:

<pre class="cpp">
void Queue::handleParameterChange(const char *parameterName)
{
    if (strcmp(parameterName, "serviceTime") == 0)
        serviceTime = par("serviceTime"); // refresh data member
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  When implementing a <tt>handleParameterChange()</tt> method, care must be taken
  to handle the changes of all parameters marked as <b><tt>@mutable</tt></b> in the NED
  file.
</ul>

<p>Notifications are suppressed while the network (or module) is being set
up.<br><ul><font size=-1>[Prior to OMNeT++ 6.0, notifications were also disabled during the
initialization phase (see <a href="chap4.html#sec:simple-modules:initialize-and-finish">[4.3.3]</a>), and
additionally, a <tt>handleParameterChange(nullptr)</tt> call was made by the
simulation kernel after the last stage of initialization. They are no longer
done, and simulation models exploiting the previous behavior needs to be
updated.]</font></ul>

<p><tt>handleParameterChange()</tt> methods need to be implemented carefully because
they may be called at a time when the module has not yet completed all
initialization stages.

<p>Also, be extremely careful when changing parameters from inside
<tt>handleParameterChange()</tt>, as it is easy to accidentally create an
infinite notification loop.

<p>
<h2><a name="sec:simple-modules:gates"/>4.6 Accessing Gates and Connections<a class="headerlink" href="#sec:simple-modules:gates" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:gate-objects"/>4.6.1 Gate Objects<a class="headerlink" href="#sec:simple-modules:gate-objects" title="Permalink to this headline">¶</a></h3>

<p>Module gates<!--gate--> are represented by <tt>cGate</tt> objects.
Gate objects know which other gates they are connected to and
what channel objects are associated with the links.

<p><h4><a name="sec:simple-modules:accessing-gates-by-name"/>4.6.1.1 Accessing Gates by Name<a class="headerlink" href="#sec:simple-modules:accessing-gates-by-name" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cModule</tt> class has several member functions that
deal with gates. You can look up a gate by name using the <tt>gate()</tt>
method:

<pre class="cpp">
cGate *outGate = gate("out");
</pre>
<p>
This works for input and output gates. However, when a gate was declared
<tt>inout</tt> in NED, it is actually represented by the simulation kernel
with two gates. Therefore, the above call would result in a <i>gate not found</i>
error. The <tt>gate()</tt> method needs to be told whether you need the input or
output half of the gate. This can be done by appending
<tt>"$i"</tt> or <tt>"$o"</tt> to the gate name. The following example
retrieves the two gates for the inout gate <tt>"g"</tt>:

<pre class="cpp">
cGate *gIn = gate("g$i");
cGate *gOut = gate("g$o");
</pre>
<p>
Another way is to use the <tt>gateHalf()</tt> function, which takes
the name of the inout gate and either <tt>cGate::INPUT</tt> or <tt>cGate::OUTPUT</tt>:

<pre class="cpp">
cGate *gIn = gateHalf("g", cGate::INPUT);
cGate *gOut = gateHalf("g", cGate::OUTPUT);
</pre>
<p>
These methods throw an error if the gate does not exist, so they cannot
be used to determine whether the module has a particular gate.
For that purpose, there is a <tt>hasGate()</tt> method. For example:

<pre class="cpp">
if (hasGate("optOut"))
   send(new cMessage(), "optOut");
</pre>
<p>
A gate can also be identified and looked up by a numeric gate ID.
You can get the ID from the gate itself (<tt>getId()</tt> method)
or from the module by gate name (<tt>findGate()</tt> method).
The <tt>gate()</tt> method also has an overloaded variant that
returns the gate from the gate ID.

<pre class="cpp">
int gateId = gate("in")-&gt;getId();  // or:
int gateId = findGate("in");
</pre>
<p>
Gate IDs are more useful with gate vectors, which will be covered
in detail in a later section.

<p>
<h4><a name="sec:simple-modules:gate-vectors"/>4.6.1.2 Gate Vectors<a class="headerlink" href="#sec:simple-modules:gate-vectors" title="Permalink to this headline">¶</a></h4>

<p>Gate vectors have one <tt>cGate</tt> object per element.
To access individual gates in the vector, you need to call
the <tt>gate()</tt> function with an additional <i>index</i>
parameter. The index should be between zero and <i>size</i>-1.
The size of the gate vector can be obtained using the <tt>gateSize()</tt>
method. The following example iterates through all elements in the
gate vector:

<pre class="cpp">
for (int i = 0; i &lt; gateSize("out"); i++) {
    cGate *gate = gate("out", i);
    //...
}
</pre>
<p>
A gate vector cannot have &#8220;holes&#8221; in it, which means that <tt>gate()</tt>
never returns <tt>nullptr</tt> or throws an error if the gate vector exists
and the index is within bounds.

<p>For inout gates, <tt>gateSize()</tt> may be called with or without
the <tt>"$i"</tt>/<tt>"$o"</tt> suffix and returns the same number.

<p>The <tt>hasGate()</tt> method can be used both with and without an
index, and they mean two different things: without an index, it tells
whether a gate vector with the given name exists, regardless of its
size (it returns <tt>true</tt> for an existing vector even if its size
is currently zero!); with an index, it also checks whether the index
is within bounds.

<p>
<h4><a name="sec:simple-modules:gate-ids"/>4.6.1.3 Gate IDs<a class="headerlink" href="#sec:simple-modules:gate-ids" title="Permalink to this headline">¶</a></h4>

<p>A gate can also be accessed by its ID. A very important property of gate IDs
is that they are <i>contiguous</i> within a gate vector, meaning
the ID of a gate <tt>g[k]</tt> can be calculated as the ID of <tt>g[0]</tt> plus <i>k</i>.
This allows you to efficiently access any gate in a gate vector because
retrieving a gate by ID is more efficient than by name and index.
The index of the first gate can be obtained with <tt>gate("out",0)-&gt;getId()</tt>,
but it is better to use a dedicated method, <tt>gateBaseId()</tt>,
because it also works when the gate vector size is zero.

<p>Two other important properties of gate IDs are that they are <i>stable</i>
and <i>unique</i> (within the module). By stable we mean that the ID
of a gate never changes, and by unique we mean that at any
given time, no two gates have the same IDs, and that IDs of deleted
gates are not reused later. Therefore, gate IDs are unique during the lifetime
of a simulation run.

<p><ul class="note"><b>NOTE</b><br>
    Versions of OMNeT++ prior to 4.0 did not guarantee these properties. Resizing
    a gate vector could cause its ID range to be relocated if it
    would have overlapped with the ID range of other gate vectors.
    OMNeT++ 4.x solves the same problem by interpreting the gate ID
    as a bitfield, basically containing bits that identify the gate name,
    and other bits that hold the index. This also means that the theoretical
    upper limit for a gate size is now smaller, although it is still
    large enough to be safely ignored for practical purposes.
</ul>

<p>The following example iterates through a gate vector using IDs:

<pre class="cpp">
int baseId = gateBaseId("out");
int size = gateSize("out");
for (int i = 0; i &lt; size; i++) {
    cGate *gate = gate(baseId + i);
    //...
}
</pre>
<p>

<p><h4><a name="sec:simple-modules:enumerating-gates"/>4.6.1.4 Enumerating All Gates<a class="headerlink" href="#sec:simple-modules:enumerating-gates" title="Permalink to this headline">¶</a></h4>

<p>If you need to go through all gates of a module, there are
two possibilities. One is to use the <tt>getGateNames()</tt> method,
which returns the names of all gates and gate vectors the module
has. Then you can call <tt>isGateVector(name)</tt> to determine
whether individual names identify a scalar gate or a gate vector.
Gate vectors can be enumerated by index. Also, for inout
gates, <tt>getGateNames()</tt> returns the base name without the
<tt>"$i"</tt>/<tt>"$o"</tt> suffix, so the two directions
need to be handled separately. The <tt>gateType(name)</tt> method
can be used to test whether a gate is inout, input, or output
(it returns <tt>cGate::INOUT</tt>, <tt>cGate::INPUT</tt>, or
<tt>cGate::OUTPUT</tt>).

<p>Clearly, the above solution can be quite challenging. An alternative is to use
the <tt>GateIterator</tt> class provided by <tt>cModule</tt>.
Here is an example:

<pre class="cpp">
for (cModule::GateIterator i(this); !i.end(); i++) {
    cGate *gate = *i;
    ...
}
</pre>
<p>
Here, <tt>this</tt> denotes the module whose gates are being enumerated
(it can be replaced by any <tt>cModule *</tt> variable).

<p><ul class="note"><b>NOTE</b><br>
    In earlier versions of OMNeT++, gate IDs used to be small integers, so
    it made sense to iterate over all gates of a module by enumerating
    all IDs from zero to a maximum, skipping the holes (<tt>nullptr</tt>s).
    However, this is no longer the case with OMNeT++ 4.0 and later versions.
    Additionally, the <tt>gate()</tt> method now throws an error when called
    with an invalid ID, rather than returning <tt>nullptr</tt>.
</ul>

<p>
<h4><a name="sec:simple-modules:adding-and-deleting-gates"/>4.6.1.5 Adding and Deleting Gates<a class="headerlink" href="#sec:simple-modules:adding-and-deleting-gates" title="Permalink to this headline">¶</a></h4>

<p>Although rarely needed, it is possible to add and remove gates during
simulation. You can add scalar gates and gate vectors, change the size of
gate vectors, and remove scalar gates and whole gate vectors.
However, it is not possible to remove individual random gates from a gate vector,
remove one half of an inout gate (e.g. <tt>"gate$o"</tt>), or set
different gate vector sizes on the two halves of an inout gate vector.

<p>The <tt>cModule</tt> methods for adding and removing gates are
<tt>addGate(name,type,isvector=false)</tt> and <tt>deleteGate(name)</tt>.
Gate vector size can be changed using <tt>setGateSize(name,size)</tt>.
None of these methods accept a <tt>"$i"</tt> or <tt>"$o"</tt> suffix in gate names.

<p><ul class="note"><b>NOTE</b><br>
    When memory efficiency is a concern, it is useful to know that
    in OMNeT++ 4.0 and later, a gate vector will consume significantly less
    memory than the same number of individual scalar gates.
</ul>

<p>
<h4><a name="sec:simple-modules:cgate-methods"/>4.6.1.6 cGate Methods<a class="headerlink" href="#sec:simple-modules:cgate-methods" title="Permalink to this headline">¶</a></h4>

<p>The <tt>getName()</tt> method of <tt>cGate</tt> returns the name of the
gate or gate vector without the index. If you need a string that contains the gate index
as well, use <tt>getFullName()</tt>. If you also want to
include the hierarchical name of the owner module, call <tt>getFullPath()</tt>.

<p>The <tt>getType()</tt> method of <tt>cGate</tt> returns the gate type,
either <tt>cGate::INPUT</tt> or <tt>cGate::OUTPUT</tt>. (It cannot return
<tt>cGate::INOUT</tt> because an inout gate is represented by a pair
of <tt>cGate</tt>s.)

<p>If you have a gate that represents half of an inout gate (that is,
<tt>getName()</tt> returns something like <tt>"g$i"</tt> or <tt>"g$o"</tt>), you
can split the name with the <tt>getBaseName()</tt> and
<tt>getNameSuffix()</tt> methods. The <tt>getBaseName()</tt> method returns the
name without the <tt>$i</tt>/<tt>$o</tt> suffix, and <tt>getNameSuffix()</tt>
returns just the suffix (including the dollar sign). For normal gates,
<tt>getBaseName()</tt> is the same as <tt>getName()</tt>, and
<tt>getNameSuffix()</tt> returns the empty string.

<p>The methods <tt>isVector()</tt>, <tt>getIndex()</tt>, <tt>getVectorSize()</tt> speak
for themselves; <tt>size()</tt> is an alias for <tt>getVectorSize()</tt>. For
non-vector gates, <tt>getIndex()</tt> returns 0 and <tt>getVectorSize()</tt>
returns 1.

<p>The <tt>getId()</tt> method returns the gate ID (not to be confused
with the gate index).

<p>The <tt>getOwnerModule()</tt> method returns the module to which the gate object
belongs.

<p>To illustrate these methods, we can modify the gate iterator example
to print some information about each gate:

<pre class="cpp">
for (cModule::GateIterator i(this); !i.end(); i++) {
    cGate *gate = *i;
    EV &lt;&lt; gate-&gt;getFullName() &lt;&lt; ": ";
    EV &lt;&lt; "id=" &lt;&lt; gate-&gt;getId() &lt;&lt; ", ";
    if (!gate-&gt;isVector())
        EV &lt;&lt; "scalar gate, ";
    else
        EV &lt;&lt; "gate " &lt;&lt; gate-&gt;getIndex()
           &lt;&lt; " in vector " &lt;&lt; gate-&gt;getName()
           &lt;&lt; " of size " &lt;&lt; gate-&gt;getVectorSize() &lt;&lt; ", ";
    EV &lt;&lt; "type:" &lt;&lt; cGate::getTypeName(gate-&gt;getType());
    EV &lt;&lt; "\n";
}
</pre>
<p>
There are further <tt>cGate</tt> methods to access and manipulate
the connection(s) attached to the gate, which will be covered in the
following sections.

<p>
<h3><a name="sec:simple-modules:connections"/>4.6.2 Connections<a class="headerlink" href="#sec:simple-modules:connections" title="Permalink to this headline">¶</a></h3>

<p>Simple module gates normally have one connection attached. However, compound module
gates need to be connected both inside and outside of the
module to be useful. A series of connections (joined with compound
module gates) is called a <i>connection path</i> or just a path.
A path is directed, and it normally starts at an output gate of
a simple module, ends at an input gate of a simple module,
and passes through several compound module gates.

<p>Every <tt>cGate</tt> object contains pointers to the previous gate
and the next gate in the path (returned by the <tt>getPreviousGate()</tt>
and <tt>getNextGate()</tt> methods). Therefore, a path can be thought of as
a double-linked list.

<p>The use of the <i>previous gate</i> and <i>next gate</i> pointers
with various gate types is illustrated in Figure
<a href="chap4.html#fig:ch-simple-modules:gates">below</a>.

<p>
  <center>
    <img src="simple-gates.svg">
    <center><div class="caption"><i>Figure: (a) Simple module output gate, (b) Compound module output gate,
             (c) Simple module input gate, (d) Compound module input gate</i></div></center>
    <a name="fig:ch-simple-modules:gates"></a>
  </center>

<p>
The start and end gates of the path can be found using the <tt>getPathStartGate()</tt>
and <tt>getPathEndGate()</tt> methods, which simply follow the <i>previous gate</i> and
<i>next gate</i> pointers, respectively, until they are <tt>nullptr</tt>.

<p>The <tt>isConnectedOutside()</tt> and <tt>isConnectedInside()</tt> methods
return whether a gate is connected to the outside or to the inside. They
examine either the <i>previous</i> or the <i>next</i> pointer, depending on the
gate type (input or output). For example, an output gate is <i>connected outside</i>
if the <i>next</i> pointer is non-<tt>nullptr</tt>; the same function for an input gate
checks the <i>previous</i> pointer. Again, refer to Figure <a href="chap4.html#fig:ch-simple-modules:gates">below</a>
for an illustration.

<p>The <tt>isConnected()</tt> method is a bit different: it returns <tt>true</tt> if the gate
is <i>fully</i> connected, meaning that for a compound module gate,
it is connected both inside and outside, and for a simple module gate, outside.

<p>The following code prints the name of the gate to which a simple module gate is
connected:

<pre class="cpp">
cGate *gate = gate("somegate");
cGate *otherGate = gate-&gt;getType()==cGate::OUTPUT ? gate-&gt;getNextGate() :
                                                    gate-&gt;getPreviousGate();
if (otherGate)
  EV &lt;&lt; "Gate is connected to: " &lt;&lt; otherGate-&gt;getFullPath() &lt;&lt; endl;
else
  EV &lt;&lt; "Gate is not connected" &lt;&lt; endl;
</pre>
<p>

<p><h3><a name="sec:simple-modules:connections-channel"/>4.6.3 The Connection's Channel<a class="headerlink" href="#sec:simple-modules:connections-channel" title="Permalink to this headline">¶</a></h3>

<p>The channel object associated with a connection is accessible via
a pointer stored at the source gate of the connection. The pointer
is returned by the <tt>getChannel()</tt> method of the gate:

<pre class="cpp">
cChannel *channel = gate-&gt;getChannel();
</pre>
<p>
The result may be <tt>nullptr</tt>, meaning that a connection may not have
an associated channel object.

<p>If you have a channel pointer, you can get the source gate of the channel
using the <tt>getSourceGate()</tt> method:

<pre class="cpp">
cGate *gate = channel-&gt;getSourceGate();
</pre>
<p>
<tt>cChannel</tt> is just an abstract base class for channels, so
to access details of the channel, you might need to cast the resulting
pointer into a specific channel class, for example <tt>cDelayChannel</tt>
or <tt>cDatarateChannel</tt>.

<p>Another specific channel type is <tt>cIdealChannel</tt>, which basically
does nothing: it acts as if there was no channel object assigned to the
connection. OMNeT++ sometimes transparently inserts a <tt>cIdealChannel</tt>
into a channel-less connection, for example to hold the display string
associated with the connection.

<p>Often, you are not really interested in a specific connection's channel, but
rather in the <i>transmission channel</i> (see
<a href="chap4.html#sec:simple-modules:packet-transmission">[4.7.6]</a>) of the connection path that
starts at a specific output gate. The transmission channel can be found by
following the connection path until you find a channel whose
<tt>isTransmissionChannel()</tt> method returns <tt>true</tt>. However,
<tt>cGate</tt> has a convenience method for this called
<tt>getTransmissionChannel()</tt>. Here is an example usage:

<pre class="cpp">
cChannel *txChan = gate("ppp$o")-&gt;getTransmissionChannel();
</pre>
<p>
A complementary method to <tt>getTransmissionChannel()</tt> is
<tt>getIncomingTransmissionChannel()</tt>. It is usually invoked
on input gates and searches the connection path in reverse direction.

<pre class="cpp">
cChannel *incomingTxChan = gate("ppp$i")-&gt;getIncomingTransmissionChannel();
</pre>
<p>
Both methods throw an error if no transmission channel is found. If this
is not desirable, you can use the similar <tt>findTransmissionChannel()</tt> and
<tt>findIncomingTransmissionChannel()</tt> methods, which simply return
<tt>nullptr</tt> in that case.

<p>Channels are covered in more detail in section <a href="chap4.html#sec:simple-modules:channels">[4.8]</a>.

<p>
<h2><a name="sec:simple-modules:sending-and-receiving"/>4.7 Sending and Receiving Messages<a class="headerlink" href="#sec:simple-modules:sending-and-receiving" title="Permalink to this headline">¶</a></h2>

<p>At an abstract level, an OMNeT++ simulation model consists of a set of
simple modules that communicate with each other through message passing.
Simple modules create, send, receive, store, modify, schedule, and destroy
messages, while the rest of OMNeT++ exists to facilitate these tasks and collect
statistics on what is happening.

<p>Messages in OMNeT++ are instances of the <tt>cMessage</tt> class or one of
its subclasses. Network packets are represented by <tt>cPacket</tt>,
which is also a subclass of <tt>cMessage</tt>. Message objects are
created using the C++ <tt>new</tt> operator and destroyed using the
<tt>delete</tt> operator when they are no longer needed.

<p>Messages are described in detail in Chapter <a href="chap5.html#cha:messages">[5]</a>.
At this point, all we need to know is that they are referred to as
<tt>cMessage *</tt> pointers. In the examples below, messages will be
created with <tt>new cMessage("foo")</tt>, where
<tt>"foo"</tt> is a descriptive message name used for visualization
and debugging purposes.

<p>
<h3><a name="sec:simple-modules:self-messages"/>4.7.1 Self-Messages<a class="headerlink" href="#sec:simple-modules:self-messages" title="Permalink to this headline">¶</a></h3>

<p>Nearly all simulation models need to schedule future events in order
to implement timers, timeouts, delays, etc. Some typical examples include:

<p><ul>
  <li> A source module that periodically creates and sends messages
    needs to schedule the next send after every send operation.
  <li> A server that processes jobs from a queue needs to start
    a timer every time it begins processing a job. When the timer
    expires, the finished job can be sent out, and a new job may
    start processing.
  <li> When a packet is sent by a communications protocol that uses
    retransmission, it needs to schedule a timeout so that the packet
    can be retransmitted if no acknowledgment arrives within a certain
    amount of time.
</ul>

<p>In OMNeT++, you can solve such tasks by having the simple module send a message
to itself; the message will be delivered to the simple module at a later
point in time. Messages used this way are called
<i>self-messages</i>, and the module class has special methods for them
that allow for implementing self-messages without gates and connections.

<p><h4><a name="sec:simple-modules:scheduling"/>4.7.1.1 Scheduling an Event<a class="headerlink" href="#sec:simple-modules:scheduling" title="Permalink to this headline">¶</a></h4>

<p>The module can send a message to itself using the <tt>scheduleAt()</tt> function.
<tt>scheduleAt()</tt> accepts an <i>absolute</i> simulation time:

<pre class="cpp">
scheduleAt(t, msg);
</pre>
<p>
Since the target time is often relative to the current simulation time,
the function has another variant, <tt>scheduleAfter()</tt>, which takes
a <i>delta</i> instead of an absolute simulation time. The following
calls are equivalent:

<pre class="cpp">
scheduleAt(simTime()+delta, msg);
scheduleAfter(delta, msg);
</pre>
<p>
Self-messages are delivered to the module in the same way as other
messages (via the usual receive calls or <tt>handleMessage()</tt>);
the module can call the <tt>isSelfMessage()</tt> member of any received
message to determine if it is a self-message.

<p>You can determine whether a message is currently in the FES by calling
its <tt>isScheduled()</tt> member function.

<p><h4><a name="sec:simple-modules:canceling"/>4.7.1.2 Canceling an Event<a class="headerlink" href="#sec:simple-modules:canceling" title="Permalink to this headline">¶</a></h4>

<p>Scheduled self-messages can be canceled<!--self-message!canceling-->
(i.e. removed from the FES).
This feature facilitates implementing timeouts.

<pre class="cpp">
cancelEvent(msg);
</pre>
<p>
The <tt>cancelEvent()</tt> function takes a pointer to the message to
be canceled, and also returns the same pointer. After canceling it,
you may delete the message or reuse it in subsequent <tt>scheduleAt()</tt>
calls. <tt>cancelEvent()</tt> has no effect if the message is not
scheduled at that time.

<p>There is also a convenience method called <tt>cancelAndDelete()</tt>,
implemented as <tt>if (msg!=nullptr) delete cancelEvent(msg)</tt>.
This method is primarily useful for writing destructors.

<p>The following example shows how to implement a timeout in a simple
imaginary stop-and-wait protocol. The code uses a <tt>timeoutEvent</tt>
module class data member that stores the pointer of the <tt>cMessage</tt> used
as a self-message, and compares it to the pointer of the received message
to identify whether a timeout has occurred.

<pre class="cpp">
void Protocol::handleMessage(cMessage *msg)
{
    if (msg == timeoutEvent) {
        // timeout expired, re-send packet and restart timer
        send(currentPacket-&gt;dup(), "out");
        scheduleAt(simTime() + timeout, timeoutEvent);
    }
    else if (...) {  // if acknowledgment received
        // cancel timeout, prepare to send next packet, etc.
        cancelEvent(timeoutEvent);
        ...
    }
    else {
       ...
    }
}
</pre>
<p>

<p><h4><a name="sec:simple-modules:rescheduling"/>4.7.1.3 Re-scheduling an Event<a class="headerlink" href="#sec:simple-modules:rescheduling" title="Permalink to this headline">¶</a></h4>

<p>To reschedule an event that is currently scheduled to a different
simulation time, it must first be canceled using <tt>cancelEvent()</tt>.
This is shown in the following example code:

<pre class="cpp">
if (msg-&gt;isScheduled())
    cancelEvent(msg);
scheduleAt(simTime() + delay, msg);
</pre>
<p>
For convenience, the above functionality is available as a single
call, using the functions <tt>rescheduleAt()</tt> and <tt>rescheduleAfter()</tt>.
The first one takes an absolute simulation time, and the second one
takes a <i>delta</i> relative to the current simulation time.

<pre class="cpp">
rescheduleAt(t, msg);
rescheduleAfter(delta, msg);
</pre>
<p>
Using these dedicated functions is potentially more efficient than the
<tt>cancelEvent()</tt> + <tt>scheduleAt()</tt> combination.

<p><h3><a name="sec:simple-modules:sending-messages"/>4.7.2 Sending Messages<a class="headerlink" href="#sec:simple-modules:sending-messages" title="Permalink to this headline">¶</a></h3>

<p>Once created, a message object can be sent through an output
gate using one of the overloaded <tt>send()</tt> methods of <tt>cSimpleModule</tt>.
There are six variations available, as the gate can be specified in
multiple ways and the methods also accept an optional <tt>SendOptions</tt> structure:

<pre class="cpp">
send(cMessage *msg, const char *gateName, int gateIndex=-1);
send(cMessage *msg, cGate *gate);
send(cMessage *msg, int gateId);
send(cMessage *msg, const SendOptions& options, const char *gateName, int gateIndex=-1);
send(cMessage *msg, const SendOptions& options, cGate *gate);
send(cMessage *msg, const SendOptions& options, int gateId);
</pre>
<p>
The most common way of specifying the gate is with its name (<tt>gateName</tt>
parameter). If the name identifies a gate vector, an additional <tt>gateIndex</tt>
parameter is required to select the desired element of the vector.

<pre class="cpp">
send(msg, "out");
send(msg, "outv", 10); // send via outv[10]
</pre>
<p>
To send a message on an <i>inout</i> gate, remember that an inout gate
consists of an input and an output gate combined. The input and output
components of an inout gate are distinguished by appending the <tt>$i</tt> and
<tt>$o</tt> suffixes to their names, respectively. Thus, the gate name needs to be
specified in the <tt>send()</tt> call with the <tt>$o</tt> suffix:

<pre class="cpp">
send(msg, "g$o");
send(msg, "g$o", 10); // assuming g[] is an inout gate vector
</pre>
<p>
Using a gate pointer (<tt>cGate*</tt>) will result in more efficient code, as it
spares the lookup inside the <tt>send()</tt> call. Typically, the module code
obtains the gate pointer once (e.g., as part of the initialization) and then
reuses it throughout the simulation.

<pre class="cpp">
cGate *outGate = gate("out");
...
send(msg, outGate);
</pre>
<p>
Using a gate ID (<tt>gateId</tt> parameter) is slightly less efficient than using
the gate pointer, but it has the advantage that gate vectors can be indexed with
it efficiently, taking advantage of the fact that elements of a gate vector occupy
a contiguous ID range.

<pre class="cpp">
int outGateBaseId = gateBaseId("outv"); // or: gate("outv", 0)-&gt;getId()
...
int index = 10;
send(msg, outGateBaseId + index); // sends on outv[10]
</pre>
<p>
The optional <tt>SendOptions</tt>, as well as other <i>send</i> variants like
<tt>sendDelayed()</tt> and <tt>sendDirect()</tt>, will be covered in later sections.

<p><h4><a name="sec:simple-modules:what-send-does"/>4.7.2.1 What send() Does<a class="headerlink" href="#sec:simple-modules:what-send-does" title="Permalink to this headline">¶</a></h4>

<p>The <tt>send()</tt> call causes the message to travel along the full length of
the <i>connection path</i> that starts at the module and will be
"delivered" to the module at the last gate in the path. The connection path is
the series of connections defined by the <tt>getNextGate()</tt> method of
<tt>cGate</tt>; the path ends when <tt>getNextGate()</tt> returns <tt>nullptr</tt>.

<p>At each hop of the path, the associated channel object, if there is one, has
authority over what should happen to the message. More precisely, the
<tt>processMessage()</tt> method of <tt>cChannel</tt> is invoked with the message
as an argument (and with some extra arguments such as <tt>SendOptions</tt>).
Individual channel types override the <tt>processMessage()</tt> method to apply
various types of processing. For example, they may modify the packet, add
(propagation) delay, or signal that the packet be discarded.

<p>After the message has reached the last gate in the connection path (the gate
where <tt>getNextGate()</tt> returns <tt>nullptr</tt>), the message will be passed
to the <tt>arrived()</tt> method of the module to which the last gate belongs.
By default, the <tt>arrived()</tt> method inserts the message into the FES,
scheduled for the message's arrival time, before returning. The message will
only be actually passed to the module's <tt>handleMessage()</tt> (or <tt>activity()</tt>)
method when the simulation has advanced to the point where the message becomes
the first event in the FES.

<p>The <tt>arrived()</tt> method is not normally overridden in simulation models.
However, it is noteworthy that the implementation of <tt>arrived()</tt> in
<tt>cModule</tt> (which commonly represents compound modules) stops the
simulation, and displays an error message along the lines of <i>&#8220;Message
arrived at a compound module&#8221;</i>.

<p><h3><a name="sec:simple-modules:broadcasts-and-retransmissions"/>4.7.3 Broadcasts and Retransmissions<a class="headerlink" href="#sec:simple-modules:broadcasts-and-retransmissions" title="Permalink to this headline">¶</a></h3>

<p>When implementing broadcasts or retransmissions, two frequently
occurring tasks in protocol simulation, you might be tempted
to use the same message in multiple <tt>send()</tt> operations.
However, this is not allowed because a message cannot be in two places
at the same time. Once sent out, the message no longer belongs
to the module; it is taken over by the simulation kernel and will
eventually be delivered to the destination module. The sender module should
not refer to the message's pointer any further. Once the message arrives in the
destination module, that module will have full control over it; it can
send it on, destroy it immediately, or store it for later handling. The
same applies to messages that have been scheduled; they belong to the
simulation kernel until they are delivered back to the module.

<p>To enforce these rules, all message sending functions check whether
the module owns the message it is about to send. If the message is owned by
another module, in a queue, currently scheduled, etc., a runtime error
will be generated: <i>not owner of message</i>.
  <br><ul><font size=-1>[This feature does not significantly increase runtime overhead because
  it uses object ownership<!--ownership--> management (described in
  Section <a href="chap7.html#sec:sim-lib:ownership-management">[7.14]</a>);
  it merely checks that the owner of the message is the module
  that wants to send it.]</font></ul>

<p><h4><a name="sec:simple-modules:broadcasting-messages"/>4.7.3.1 Broadcasting Messages<a class="headerlink" href="#sec:simple-modules:broadcasting-messages" title="Permalink to this headline">¶</a></h4>

<p>In your model, you may need to broadcast a message to several destinations.
Broadcasts can be implemented in a simple module by sending out copies
of the same message, for example on every gate of a gate vector.
As previously mentioned, you cannot send the same message object multiple times;
instead, you need to create copies (duplicates) of the message object and send them.

<p>Here is an example:

<pre class="cpp">
for (int i = 0; i &lt; n; i++) {
    cMessage *copy = msg-&gt;dup();
    send(copy, "out", i);
}
delete msg;
</pre>
<p>
It is important to note that copying the message for the last gate is
redundant; you can just send the original message there.
Also, you can use gate IDs to avoid looking up the gate by name
for each send operation. You can exploit the fact that the ID of gate
<i>k</i> in a gate vector can be produced as <i>baseID + k</i>.
An improved version of the code looks like this:

<pre class="cpp">
int outGateBaseId = gateBaseId("out");
for (int i = 0; i &lt; n; i++)
    send(i==n-1 ? msg : msg-&gt;dup(), outGateBaseId+i);
</pre>
<p>

<p><h4><a name="sec:simple-modules:retransmissions"/>4.7.3.2 Retransmissions<a class="headerlink" href="#sec:simple-modules:retransmissions" title="Permalink to this headline">¶</a></h4>

<p>Many communication protocols involve retransmitting packets (frames).
When implementing retransmissions, you cannot simply hold a pointer
to the same message object and send it again and again; you will get
a runtime error of <i>not owner of message</i> on the first resend.

<p>Instead, for retransmission, you should create and
send copies of the message, and retain the original.
When you are sure there will not be any more retransmissions,
you can delete the original message.

<p>Creating and sending a copy:

<pre class="cpp">
// (re)transmit packet:
cMessage *copy = packet-&gt;dup();
send(copy, "out");
</pre>
<p>
And finally, when no more retransmissions will occur:

<pre class="cpp">
delete packet;
</pre>
<p>

<p><h3><a name="sec:simple-modules:delayed-sending"/>4.7.4 Delayed Sending<a class="headerlink" href="#sec:simple-modules:delayed-sending" title="Permalink to this headline">¶</a></h3>

<p>Sometimes it is necessary for a module to hold a message for some time interval
and then send it. In such cases, you can use the <tt>scheduleAt()</tt> function,
but there is a more straightforward method: delayed sending.
There are several methods provided for delayed sending:

<pre class="cpp">
sendDelayed(cMessage *msg, double delay, const char *gateName, int gateIndex=-1);
sendDelayed(cMessage *msg, double delay, int gateId);
sendDelayed(cMessage *msg, double delay, cGate *gate);
</pre>
<p>
These methods are similar to the regular <tt>send()</tt> methods, but with an
additional <i>delay</i> parameter, which must be non-negative. The effect of
the function is similar to if the module had kept the message for the delay
interval and then sent it afterward; even the <i>sending time</i> timestamp
of the message will be set to the current simulation time plus the <i>delay</i>.

<p>An example call:

<pre class="cpp">
sendDelayed(msg, 0.005, "out");
</pre>
<p>
The <tt>sendDelayed()</tt> function does not perform a <tt>scheduleAt()</tt>
followed by a <tt>send()</tt>, but rather it computes everything about the
message sending up front, including the arrival time and the target module.
This has two consequences. First, <tt>sendDelayed()</tt> is more efficient than
a <tt>scheduleAt()</tt> followed by a <tt>send()</tt> because it eliminates one
event. Second, changes in the connection path during the delay will <i>not</i>
be taken into account (because everything is calculated in advance, before the
changes take place).

<p><ul class="note"><b>NOTE</b><br>
  Although <tt>sendDelayed()</tt> is more efficient, you should think twice
  before using it in a simulation model. It may be suitable for one-shot simulation
  models known to be static, but it is generally not recommended for reusable
  modules that need to work correctly in a wide variety of simulation models,
where a connection in the path may get deleted, disabled, or reconnected to
another module during the delay period.
</ul>

<p>
<h3><a name="sec:simple-modules:direct-sending"/>4.7.5 Direct Message Sending<a class="headerlink" href="#sec:simple-modules:direct-sending" title="Permalink to this headline">¶</a></h3>

<p>The <tt>sendDirect()</tt> function allows for sending a message directly to an
input gate of another module. This is useful for simulating wireless
transmissions. <tt>sendDirect()</tt> has several variants because the target gate
can be specified in various ways, a propagation delay and duration can be
optionally given, and these two can also be specified using a
<tt>SendOptions</tt> structure.

<p>Here are the variants of <tt>sendDirect()</tt>:

<pre class="cpp">
sendDirect(cMessage *msg, cModule *targetModule, int gateId);
sendDirect(cMessage *msg, cModule *targetModule, const char *gateName,
               int gateIndex=-1);
sendDirect(cMessage *msg, cGate *gate);

sendDirect(cMessage *msg, simtime_t propagationDelay, simtime_t duration,
               cModule *targetModule, int gateId);
sendDirect(cMessage *msg, simtime_t propagationDelay, simtime_t duration,
               cModule *targetModule, const char *gateName, int gateIndex=-1);
sendDirect(cMessage *msg, simtime_t propagationDelay, simtime_t duration,
               cGate *gate);
sendDirect(cMessage *msg, const SendOptions& options, cModule *targetModule,
               int gateId);
sendDirect(cMessage *msg, const SendOptions& options, cModule *targetModule,
               const char *gateName, int gateIndex=-1);
sendDirect(cMessage *msg, const SendOptions& options, cGate *gate);
</pre>
<p>
Here is an example of sending a message directly to a module's input gate:

<pre class="cpp">
cModule *targetModule = getParentModule()-&gt;getSubmodule("node2");
sendDirect(new cMessage("msg"), targetModule, "in");
</pre>
<p>
At the target module, there is no difference between messages received
directly and those received over connections.

<p>The target gate must be an unconnected gate; in other words, modules must
have dedicated gates to be able to receive messages sent via <tt>sendDirect()</tt>.
It is not possible to have a gate that receives messages via both connections
and <tt>sendDirect()</tt>.

<p>It is recommended to tag gates dedicated for receiving messages via
<tt>sendDirect()</tt> with the <tt>@directIn</tt> property in the module's NED
declaration. This will cause OMNeT++ not to complain that the gate is not
connected in the network or compound module where the module is used.

<p>Here is an example:

<pre class="ned">
simple Radio {
    gates:
        input radioIn @directIn;  // for receiving air frames
}
</pre>
<p>
The target module can be a simple module or a compound module. The message will
follow the connections that start at the target gate and will be delivered to
the end module in the path, just like with normal connections. The path must
end with a simple module.

<p>It is even permitted to send to an output gate, which will also cause the
message to follow the connections starting at that gate. This can be useful, for
example, when several submodules are sending to a single output gate of their
parent module.

<p>The transmission duration parameter is important when the message is also a
packet, i.e. subclassed from <tt>cPacket</tt>. In that case, the duration
will be written into the packet, and can be read by the receiver with the
<tt>getDuration()</tt> method of the packet. For non-packet messages, the
duration parameter is ignored.

<p>The receiver module can choose whether it wants the simulation kernel
to deliver the packet object to it at the start or at the end of the
reception period. The default is the latter; the module can change it by calling
<tt>setDeliverImmediately()</tt> on the final input gate, that is, on
<tt>targetGate-&gt;getPathEndGate()</tt>.

<p>
<h3><a name="sec:simple-modules:packet-transmission"/>4.7.6 Packet Transmissions<a class="headerlink" href="#sec:simple-modules:packet-transmission" title="Permalink to this headline">¶</a></h3>

<p>When a message is sent out on a gate, it usually travels through
a series of connections until it arrives at the destination module.
We call this series of connections a <i>connection path</i>.

<p>Several connections in the path may have an associated channel,
but there can be only one channel per path that models nonzero
transmission duration. This restriction is enforced by the simulation
kernel. This channel is called the <i>transmission channel</i>.
  <br><ul><font size=-1>[Moreover, if <tt>sendDirect()</tt> with a nonzero duration
  was used to send the packet to the start gate of the path,
  then the path cannot have a transmission channel at all.
  The point is that the a transmission duration must be unambiguous.]</font></ul>

<p><ul class="note"><b>NOTE</b><br>
  In practice, this means that there can be only one <tt>ned.DatarateChannel</tt>
  in the path. Note that unnamed channels with a <tt>datarate</tt> parameter
  also map to <tt>ned.DatarateChannel</tt>.
</ul>

<p>
<h4><a name="sec:simple-modules:transmitting-a-packet"/>4.7.6.1 Transmitting a Packet<a class="headerlink" href="#sec:simple-modules:transmitting-a-packet" title="Permalink to this headline">¶</a></h4>

<p>Packets may only be sent when the transmission channel is idle.
This means that after each transmission, the sender module needs
to wait until the channel has finished transmitting before it can
send another packet.

<p>You can get a pointer to the transmission channel by calling the
<tt>getTransmissionChannel()</tt> method on the output gate.
The channel's <tt>isBusy()</tt> and <tt>getTransmissionFinishTime()</tt>
methods can tell you whether a channel is currently transmitting,
and when the transmission is going to finish. (When the latter is
less or equal the current simulation time, the channel is free.)
If the channel is currently busy, sending needs to be postponed:
the packet can be stored in a queue, and a timer (self-message) can be
scheduled for the time when the channel becomes empty.

<p>A code example to illustrate the above process:

<pre class="cpp">
cPacket *pkt = ...; // packet to be transmitted
cChannel *txChannel = gate("out")-&gt;getTransmissionChannel();
simtime_t txFinishTime = txChannel-&gt;getTransmissionFinishTime();
if (txFinishTime &lt;= simTime()) {
    // channel free; send out packet immediately
    send(pkt, "out");
}
else {
    // store packet and schedule timer; when the timer expires,
    // the packet should be removed from the queue and sent out
    txQueue.insert(pkt);
    scheduleAt(txFinishTime, endTxMsg);
}
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  If there is a channel with a propagation delay in
  the path before the transmission channel, the delay should be manually
  subtracted from the value returned by <tt>getTransmissionFinishTime()</tt>!
  The same applies to <tt>isBusy()</tt>: it tells whether the channel is
  currently busy, and not whether it will be busy when a packet that you send
  gets there. It is therefore advisable that you never use propagation delays
  in front of a transmission channel in a path.
</ul>

<p>The <tt>getTransmissionChannel()</tt> method searches the connection path each
time it is called. If performance is important, it is a good idea to obtain
the transmission channel pointer once, and then cache it. When the network topology
changes, the cached channel pointer needs to be updated; section
<a href="chap4.html#sec:simple-modules:model-change">[4.14.3]</a> describes the mechanism that can
be used to get notifications about topology changes.

<p>
<h4><a name="sec:simple-modules:implementation-of-message-sending"/>4.7.6.2 Implementation of Message Sending<a class="headerlink" href="#sec:simple-modules:implementation-of-message-sending" title="Permalink to this headline">¶</a></h4>

<p>Message sending is implemented like this: the arrival time<!--arrival time-->
and the bit error<!--bit error--> flag of a message are calculated right inside
the <tt>send()</tt> call, then the message is inserted into the FES<!--FES-->
with the calculated arrival time. The message does <i>not</i> get scheduled
individually for each link. This implementation was chosen because of its
run-time efficiency.

<p><ul class="note"><b>NOTE</b><br>
   The consequence of this implementation is that any change in the
   channel's parameters (delay, data rate, bit error rate, etc.) will only affect
   messages <i>sent</i> after the change. Messages already underway will not
   be influenced by the change.

<p>   This is not a huge problem in practice, but if it is important to model
   channels with changing parameters, the solution is to insert simple modules
   into the path to ensure strict scheduling.
</ul>

<p>The code which inserts the message into the FES is the <tt>arrived()</tt>
method of the recipient module. By overriding this method it is possible
to perform custom processing at the recipient module immediately, still
from within the <tt>send()</tt> call. Use only if you know what you are doing!

<p>
<h3><a name="sec:simple-modules:transmission-updates"/>4.7.7 Transmission Updates<a class="headerlink" href="#sec:simple-modules:transmission-updates" title="Permalink to this headline">¶</a></h3>
<a name="sec:simple-modules:aborting-transmissions"></a>

<p>In the modeling of communication networks, it is sometimes necessary to model
that the transmission of a packet does not go through as planned, but is aborted
or finished prematurely. For example, when a colliding transmission is detected
on an Ethernet link that uses CSMA/CD, the transmission of the packet is
aborted. Even on a duplex Ethernet link, the transmission of an Ethernet frame
may be suspended (and later resumed) so that a higher-priority frame can be
transmitted immediately, a feature called frame preemption. It is also possible
that a transmission is extended to a longer duration, for example when the
frame's payload is appended on the fly, due to the use of frame aggregation.

<p>OMNeT++ allows for modeling such scenarios using a special mechanism called
<i>transmission updates</i>. The basic idea is that while a transmission is
underway, the sender can change its mind on when the transmission will actually
finish, and what the final packet content will be. It announces the change by
sending a special packet, called a <i>transmission update</i>. The
transmission update packet contains the remaining transmission duration, and the
updated packet content.

<p>This mechanism allows for both shortening and extending the transmission
duration (but not retroactively, i.e. the remaining duration cannot be
negative). Any number of updates may be sent for a transmission, and the
original transmission does not need to be marked specially to allow the use of
updates. Aborting a transmission is modeled by simply sending an update with
zero remaining duration and the truncated packet.<br><ul><font size=-1>[Before OMNeT++
version 6.0, using the <tt>forceTransmissionFinishTime()</tt> channel method was
recommended as a way to implement aborting a transmission. It is now considered
obsolete, and should not be used.]</font></ul> An interesting additional use of transmission
updates could be making the transmission end explicit (which is normally
implicit in OMNeT++), by sending a zero-remaining-time transmission update
exactly at the time the transmission would otherwise end.

<p><ul class="note"><b>NOTE</b><br>
  The receiver has to be prepared to receive transmission updates, and to react
  to them appropriately. The details are explained in section
  <a href="chap4.html#sec:simple-modules:reception-of-transmission-updates">[4.7.8.3]</a>.
</ul>

<p>
<h4><a name="sec:simple-modules:sending-transmission-updates"/>4.7.7.1 Sending Transmission Updates<a class="headerlink" href="#sec:simple-modules:sending-transmission-updates" title="Permalink to this headline">¶</a></h4>

<p>To allow a packet transmission to be updated later, a transmission ID needs to
be chosen, specified in the send call, and remembered for later. The
transmission ID is needed for the simulation kernel to match later updates with
the original packet. It is convenient to choose the ID of the packet as
transmission ID.

<p>Transmission updates are sent using the normal message sending functions
(<tt>send()</tt>, <tt>sendDirect()</tt>, etc.), specifying a <tt>SendOptions</tt>
that has the <tt>updateTx</tt> field set and contains the transmission ID.
It is recommended to use utility functions of <tt>SendOptions</tt>, such as
<tt>finishTx()</tt> and <tt>updateTx()</tt>, to set up the <tt>SendOptions</tt>.

<p>An example for sending a packet, allowing it to be updated later:

<pre class="cpp">
cPacket *pk = new cPacket("pk", 0, length*8);
transmissionId = pk-&gt;getId();
send(pk, SendOptions().transmissionId(transmissionId), "out");
</pre>
<p>
At a later time, the transmission update can be sent with the following code:

<pre class="cpp">
cPacket *pk = new cPacket("update", 0, updatedLength*8);
send(pk, SendOptions().updateTx(transmissionId), "out");
</pre>
<p>
For the transmission to be modeled, the simulation kernel needs to obtain
values for the packet duration and the remaining duration. Input for these values
may come from multiple alternative sources:

<p><ul>
  <li> If the channel defines a data rate, the duration can be
    computed from that and the packet length.
  <li> If the channel does not contain the data rate, the sender must specify
    it explicitly in <tt>SendOptions</tt>.
  <li> Once the duration is known, the remaining duration can be computed by
    the channel as <i>start time</i> + <i>duration</i> - <i>current simulation time</i>.
  <li> Or if the channel does not keep track of the transmission start times,
    the remaining duration must be specified by the model in <tt>SendOptions</tt>.
  <li> Etc.
</ul>

<p>The <tt>cDatarateChannel</tt> class, the default transmission channel type in OMNeT++,
supports many variations of the above.

<p>For wireless transmissions modeled with <tt>sendDirect</tt>, there is no channel,
so the duration, the remaining duration, and also the propagation delay must be
specified explicitly. Here is an example of sending the original packet:

<pre class="cpp">
cGate *targetGate = peerNode-&gt;gate("directIn");
cPacket *pk = new cPacket("directPk", 0, length*8);
transmissionId = pk-&gt;getId();
txStartTime = simTime();
propagationDelay = ...;
simtime_t duration = pk-&gt;getBitLength()/BITRATE;
sendDirect(pk,
    SendOptions().transmissionId(transmissionId).
                  propagationDelay(propagationDelay).duration(duration),
    targetGate);
</pre>
<p>
And the corresponding update:

<pre class="cpp">
cPacket *pk = new cPacket("directPkUpdate", 0, updatedLength*8);
simtime_t newDuration = pk-&gt;getBitLength()/BITRATE;
simtime_t remainingDuration = txStartTime + newDuration - simTime();
sendDirect(pk,
    SendOptions().updateTx(transmissionId, remainingDuration).
                  propagationDelay(propagationDelay).duration(newDuration),
    targetGate);
</pre>
<p>

<p><h3><a name="sec:simple-modules:receiving-a-packet"/>4.7.8 Receiving Packets<a class="headerlink" href="#sec:simple-modules:receiving-a-packet" title="Permalink to this headline">¶</a></h3>

<p>Packets in OMNeT++ are delivered to modules in the same way as normal messages,
through the <tt>handleMessage()</tt> method. To access packet-specific methods
and fields, it is necessary to cast the incoming message to <tt>cPacket</tt>.

<p><tt>cPacket</tt> has several fields that provide information about the packet's
last transmission over the transmission channel. These fields are:

<p><ul>
  <li> <tt>hasBitError()</tt>: Returns <tt>true</tt> if the packet has any bit errors.
  <li> <tt>isUpdate()</tt>: Returns <tt>true</tt> if the packet is a transmission update.
  <li> <tt>getTransmissionId()</tt>: For transmission updates, returns the ID that identifies the transmission.
  <li> <tt>isReceptionStart()</tt>: Returns <tt>true</tt> if the packet represents the start of the reception process.
  <li> <tt>isReceptionEnd()</tt>: Returns <tt>true</tt> if the packet represents the end of the reception process.
  <li> <tt>getDuration()</tt>: Retrieves the total transmission duration of the packet.
  <li> <tt>getRemainingDuration()</tt>: Obtains the remaining transmission time of the packet.
</ul>

<p>Based on the information carried by these fields, processing of the received
packet typically involves performing the steps described in the following sections.

<p>
<h4><a name="sec:simple-modules:checking-bit-errors"/>4.7.8.1 Checking for Bit Errors<a class="headerlink" href="#sec:simple-modules:checking-bit-errors" title="Permalink to this headline">¶</a></h4>

<p>Packets may have a bit error flag set due to channel error modeling. It is the
receiver's responsibility to check this flag using <tt>hasBitError()</tt> and
act accordingly, typically by discarding the packet.

<p><h4><a name="sec:simple-modules:reception-start-vs-end"/>4.7.8.2 Reception Start vs. Reception End<a class="headerlink" href="#sec:simple-modules:reception-start-vs-end" title="Permalink to this headline">¶</a></h4>

<p>By default, packets are delivered at the end of their reception. To change this
behavior, call <tt>gate("in")-&gt;setDeliverImmediately(true);</tt> in the module's
<tt>initialize()</tt> method. This setting causes packets to be delivered at the
start of reception.

<pre class="cpp">
gate("in")-&gt;setDeliverImmediately(true);
</pre>
<p>
This method may only be called on simple module input gates, and it
instructs the simulation kernel to deliver packets arriving through
that gate at the simulation time that corresponds to the
beginning of the reception process.
The <tt>setDeliverImmediately()</tt> method only needs to be called once,
so it is typically done in the <tt>initialize()</tt> method of the module.

<p>
  <center>
    <img src="transmission.svg">
    <center><div class="caption"><i>Figure: Packet transmission</i></div></center>
    <a name="fig:ch-simple-modules:transmission"></a>
  </center>

<p>
When a packet is delivered to the module, you can call the packet's
<tt>isReceptionStart()</tt> and <tt>isReceptionEnd()</tt> methods to
determine whether it represents the start or end of the reception process.
(Note that for a transmission update, both methods may return <tt>false</tt>.)

<p>
<h4><a name="sec:simple-modules:reception-of-transmission-updates"/>4.7.8.3 Handling Transmission Updates<a class="headerlink" href="#sec:simple-modules:reception-of-transmission-updates" title="Permalink to this headline">¶</a></h4>

<p>The receiver should recognize transmission updates using <tt>isUpdate()</tt> and
react accordingly.

<p>Receivers that receive the packet at the end of the reception, which is the
default behavior, will only receive the final update. The original packet and
intermediate updates are managed by the simulation kernel.

<p>Receivers that receive the packet at the start of the reception (as selected by
<tt>setDeliverImmediately(true)</tt> in the previous section) should be prepared
to receive the original packet and updates, and handle them appropriately. If an
update arrives, the receiver should replace the original packet with the update
and reschedule any potential end-reception event to <tt>simTime() + pk-&gt;getRemainingDuration()</tt>.

<p>As a safeguard against unprepared modules accidentally processing transmission
updates as independent packets, the receiver is only given transmission updates
if it has explicitly declared support for them. The module declares support
by calling <tt>setTxUpdateSupport(true)</tt>, usually in the <tt>initialize()</tt> method.

<p>Non-transmission channels handle updates in the same way as they handle any other
messages and packets.

<p><h3><a name="sec:simple-modules:receiving-with-activity"/>4.7.9 Receiving Messages with activity()<a class="headerlink" href="#sec:simple-modules:receiving-with-activity" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:receive"/>4.7.9.1 Receiving Messages<a class="headerlink" href="#sec:simple-modules:receive" title="Permalink to this headline">¶</a></h4>

<p>Modules based on <tt>activity()</tt> receive messages using the <tt>receive()</tt>
method of <tt>cSimpleModule</tt>. The <tt>receive()</tt> method cannot be used with
modules based on <tt>handleMessage()</tt>.

<pre class="cpp">
cMessage *msg = receive();
</pre>
<p>
The <tt>receive()</tt> function accepts an optional <i>timeout</i>
parameter<!--receive!timeout--> (in the form of a <i>delta</i>, not an
absolute simulation time). If no message arrives within the timeout period,
the function returns <tt>nullptr</tt>.
    <br><ul><font size=-1>[Putaside queue and the functions <tt>receiveOn()</tt>,
    <tt>receiveNew()</tt>, and <tt>receiveNewOn()</tt> were deprecated
    in OMNeT++ 2.3 and removed in OMNeT++ 3.0.]</font></ul>

<pre class="cpp">
simtime_t timeout = 3.0;
cMessage *msg = receive(timeout);

if (msg == nullptr) {
    ...   // handle timeout
}
else {
    ...  // process message
}
</pre>
<p>
<h4><a name="sec:simple-modules:wait"/>4.7.9.2 The wait() Function<a class="headerlink" href="#sec:simple-modules:wait" title="Permalink to this headline">¶</a></h4>

<p>The <tt>wait()</tt> function suspends the execution of the module for a given
amount of simulation time (a <i>delta</i>). <tt>wait()</tt> cannot be used with
modules based on <tt>handleMessage()</tt>.

<pre class="cpp">
wait(delay);
</pre>
<p>
Internally, the <tt>wait()</tt> function is implemented by a combination of
<tt>scheduleAt()</tt> and <tt>receive()</tt>. The <tt>wait()</tt> function is very
convenient in modules that do not need to be prepared for incoming messages,
such as message generators.
Here is an example usage:

<pre class="cpp">
for (;;) {
    // Wait for some, potentially random, amount of time specified
    // in the interarrivalTime volatile module parameter
    wait(par("interarrivalTime").doubleValue());

    // Generate and send message
    ...
}
</pre>
<p>
It is a runtime error if a message arrives during the wait interval.
If you expect messages to arrive during the wait period, you can
use the <tt>waitAndEnqueue()</tt> function. It takes a pointer to a queue object
of class <tt>cQueue</tt>, described in Chapter <a href="chap7.html#cha:sim-lib">[7]</a>, in addition
to the wait interval. Messages that arrive during the wait interval are
accumulated in the queue and can be processed after the <tt>waitAndEnqueue()</tt>
call returns.

<p>Here is an example:

<pre class="cpp">
cQueue queue("queue");
...
waitAndEnqueue(waitTime, &queue);
if (!queue.empty())
{
    // Process messages that arrived during the wait interval
    ...
}
</pre>
<p>

<p><h2><a name="sec:simple-modules:channels"/>4.8 Channels<a class="headerlink" href="#sec:simple-modules:channels" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:channels-overview"/>4.8.1 Overview<a class="headerlink" href="#sec:simple-modules:channels-overview" title="Permalink to this headline">¶</a></h3>

<p>Channels encapsulate parameters and behavior associated with connections.
Channel types are similar to simple modules in that they are declared
in NED, and there are C++ implementation classes underlying them. Section
<a href="chap3.html#sec:ned-lang:channels">[3.5]</a> describes NED language support for channels
and explains how to associate C++ classes with declared channel types in
NED.

<p>C++ channel classes must subclass the abstract base class
<tt>cChannel</tt>. However, when creating a new channel class, it may be
more practical to extend one of the existing C++ channel classes behind the
three predefined NED channel types:

<p><ul>
  <li> <tt>cIdealChannel</tt> implements the functionality of <tt>ned.IdealChannel</tt>.
  <li> <tt>cDelayChannel</tt> implements the functionality of <tt>ned.DelayChannel</tt>.
  <li> <tt>cDatarateChannel</tt> implements the functionality of <tt>ned.DatarateChannel</tt>.
</ul>

<p>Channel classes need to be registered with the <tt>Define_Channel()</tt> macro,
just like simple module classes need <tt>Define_Module()</tt>.

<p>The channel base class <tt>cChannel</tt> inherits from <tt>cComponent</tt>,
so channels participate in the initialization and finalization protocol
(<tt>initialize()</tt> and <tt>finish()</tt>) described in
<a href="chap4.html#sec:simple-modules:initialize-and-finish">[4.3.3]</a>.

<p>The parent module of a channel (as returned by
<tt>getParentModule()</tt>) is the module that contains
the connection. If a connection connects two modules that are children of
the same compound module, the channel's parent is the compound module. If
the connection connects a compound module to one of its submodules, the
channel's parent is also the compound module.

<p>
<h3><a name="sec:simple-modules:channel-api"/>4.8.2 The Channel API<a class="headerlink" href="#sec:simple-modules:channel-api" title="Permalink to this headline">¶</a></h3>

<p>When subclassing <tt>Channel</tt>, the following pure virtual member functions
need to be overridden:

<p><ul>
  <li> <tt>bool isTransmissionChannel() const</tt>
  <li> <tt>simtime_t getTransmissionFinishTime() const</tt>
  <li> <tt>Result processMessage(cMessage *msg, const SendOptions&amp; options, simtime_t t)</tt>
</ul>

<p>The first two functions are usually one-liners; the channel behavior is
encapsulated in the third function, <tt>processMessage()</tt>.

<p><h4><a name="sec:simple-modules:transmission-channels"/>4.8.2.1 Transmission Channels<a class="headerlink" href="#sec:simple-modules:transmission-channels" title="Permalink to this headline">¶</a></h4>

<p>The first function, <tt>isTransmissionChannel()</tt>, determines whether
the channel is a <i>transmission channel</i>, i.e. one that models
transmission duration. A transmission channel sets the duration field of
packets sent through it (see the <tt>setDuration()</tt> field of
<tt>cPacket</tt>).

<p>The <tt>getTransmissionFinishTime()</tt> function is only used with
transmission channels, and it should return the simulation time the sender
will finish (or has finished) transmitting. This method is called by
modules that send on a transmission channel to find out when the channel
becomes available. The channel's <tt>isBusy()</tt> method is implemented
simply as <tt>return getTransmissionFinishTime() &lt; simTime()</tt>. For
non-transmission channels, the <tt>getTransmissionFinishTime()</tt> return
value may be any simulation time which is less than or equal to the current
simulation time.

<p><h4><a name="sec:simple-modules:channel-processmessage"/>4.8.2.2 The processMessage() Function<a class="headerlink" href="#sec:simple-modules:channel-processmessage" title="Permalink to this headline">¶</a></h4>

<p>The third function, <tt>processMessage()</tt>, encapsulates the channel's
functionality. However, before going into the details of this function,
we need to understand how OMNeT++ handles message sending on connections.

<p>Inside the <tt>send()</tt> call, OMNeT++ follows the
connection path denoted by the <tt>getNextGate()</tt> functions of gates
until it reaches the target module. At each &#8220;hop&#8221;, the corresponding
connection's channel (if the connection has one) gets a chance to add to
the message's arrival time (<i>propagation time modeling</i>), calculate a
<i>transmission duration</i>, and modify the message object in various
ways, such as setting the bit error flag in it (<i>bit error modeling</i>).
After processing all hops that way, OMNeT++ inserts the message object
into the Future Events Set (FES<!--FES-->, see section
<a href="chap4.html#sec:simple-modules:event-loop">[4.1.2]</a>), and the <tt>send()</tt> call returns.
Then OMNeT++ continues to process events in increasing timestamp order.
The message will be delivered to the target module's <tt>handleMessage()</tt>
(or <tt>receive()</tt>) function when it gets to the front of the FES.

<p>A few more details: a channel may instruct OMNeT++ to delete the message
instead of inserting it into the FES; this can be useful to model
disabled channels or to model that the message has been lost altogether.
The <tt>getDeliverOnReceptionStart()</tt> flag of the final gate in the path
will determine whether the transmission duration will be added to the
arrival time or not. Packet transmissions have been described in section
<a href="chap4.html#sec:simple-modules:packet-transmission">[4.7.6]</a>.

<p>Now, back to the <tt>processMessage()</tt> method.

<p>The method gets called as part of the above process when the message
is processed at the given hop. The method's arguments are the message
object, the simulation time the beginning of the message will reach
the channel (i.e., the sum of all previous propagation delays),
and a struct in which the method can return the results:

<pre class="cpp">
Result processMessage(cMessage *msg, const SendOptions& options, simtime_t t);
</pre>
<p>
The <tt>Result</tt> struct is an inner type of <tt>cChannel</tt>
and looks like this:

<pre class="cpp">
struct Result
{
    bool discard = false;        // whether the channel has lost the msg
    simtime_t delay;             // propagation delay
    simtime_t duration;          // transmission duration
    simtime_t remainingDuration; // remaining tx duration (for tx update)
};
</pre>
<p>
It also has a constructor that initializes all fields to zero; it is left
out for brevity.

<p>The method should model the transmission of the given message starting at
the given <i>t</i> time and store the results (propagation delay,
transmission duration, deletion flag) in the result object. Only the
relevant fields in the result object need to be changed; others can be left
untouched.

<p>Transmission duration and bit error modeling only apply to packets (i.e.,
to instances of <tt>cPacket</tt>, where <tt>cMessage</tt>'s
<tt>isPacket()</tt> returns true); they should be skipped for non-packet
messages. <tt>processMessage()</tt> does not need to call the <tt>setDuration()</tt>
method on the packet; this is done by the simulation kernel. However,
it should call <tt>setBitError(true)</tt> on the packet
if error modeling results in bit errors.

<p>If the method sets the <tt>discard</tt> flag in the result object, that
means that the message object will be deleted by OMNeT++; this facility
can be used to model that the message gets lost in the channel.

<p>The <tt>processMessage()</tt> method does not need to throw an error on overlapping
transmissions or if the packet's duration field is already set; these
checks are done by the simulation kernel before <tt>processMessage()</tt> is called.



<p><h3><a name="sec:simple-modules:channel-examples"/>4.8.3 Channel Examples<a class="headerlink" href="#sec:simple-modules:channel-examples" title="Permalink to this headline">¶</a></h3>

<p>To illustrate coding channel behavior, we look at how the built-in channel
types are implemented.

<p><tt>cIdealChannel</tt> lets messages and packets pass through without
any delay or change. Its <tt>isTransmissionChannel()</tt> method returns
<tt>false</tt>, <tt>getTransmissionFinishTime()</tt> returns <i>0s</i>, and the
body of its <tt>processMessage()</tt> method is empty:

<pre class="cpp">
cChannel::Result cIdealChannel::processMessage(cMessage *msg,
                    const SendOptions& options, simtime_t t)
{
    return Result();
}
</pre>
<p>
<tt>cDelayChannel</tt> implements propagation delay, and it can be
disabled; in its disabled state, messages sent through it will be discarded.
This class still models zero transmission duration, so its
<tt>isTransmissionChannel()</tt> and <tt>getTransmissionFinishTime()</tt>
methods still return <tt>false</tt> and <i>0s</i>. The <tt>processMessage()</tt> method
sets the appropriate fields in the <tt>Result</tt> struct:

<p>
<pre class="cpp">
cChannel::Result cDelayChannel::processMessage(cMessage *msg,
                    const SendOptions& options, simtime_t t)
{
    Result result;

    // if channel is disabled, signal that the message should be deleted
    if (isDisabled) {
        result.discard = true;
        return result;
    }

    // propagation delay modeling
    result.delay = delay;
    return result;
}
</pre>

<p>The <tt>handleParameterChange()</tt> method is also redefined, so that
the channel can update its internal <tt>delay</tt> and <tt>isDisabled</tt>
data members if the corresponding channel parameters change during simulation.
<br><ul><font size=-1>[This code is a little simplified; the actual code uses a bit
in a bitfield to store the value of <tt>isDisabled</tt>.]</font></ul>

<p><tt>cDatarateChannel</tt> is different. It performs packet duration modeling
(duration is calculated from the data rate and the length of the packet),
so <tt>isTransmissionChannel()</tt> returns <tt>true</tt>.
<tt>getTransmissionFinishTime()</tt> returns the value of a <tt>txfinishtime</tt>
data member, which gets updated after every packet.

<pre class="cpp">
simtime_t cDatarateChannel::getTransmissionFinishTime() const
{
    return txfinishtime;
}
</pre>
<p>
<tt>cDatarateChannel</tt>'s <tt>processMessage()</tt> method makes use of
the <tt>isDisabled</tt>, <tt>datarate</tt>, <tt>ber</tt>, and <tt>per</tt> data
members, which are also kept up to date with the help of
<tt>handleParameterChange()</tt>.

<pre class="cpp">
cChannel::Result cDatarateChannel::processMessage(cMessage *msg,
                    const SendOptions& options, simtime_t t)
{
    Result result;

    // if channel is disabled, signal that the message should be deleted
    if (isDisabled) {
        result.discard = true;
        return result;
    }

    // datarate modeling
    if (datarate != 0 && msg-&gt;isPacket()) {
        simtime_t duration = ((cPacket *)msg)-&gt;getBitLength() / datarate;
        result.duration = duration;
        txfinishtime = t + duration;
    }
    else {
        txfinishtime = t;
    }

    // propagation delay modeling
    result.delay = delay;

    // bit error modeling
    if ((ber != 0 || per != 0) && msg-&gt;isPacket()) {
        cPacket *pkt = (cPacket *)msg;
        if (ber != 0 && dblrand() &lt; 1.0 - pow(1.0-ber, (double)pkt-&gt;getBitLength()))
            pkt-&gt;setBitError(true);
        if (per != 0 && dblrand() &lt; per)
            pkt-&gt;setBitError(true);
    }

    return result;
}
</pre>
<p>

<p>
<h2><a name="sec:simple-modules:stopping"/>4.9 Stopping the Simulation<a class="headerlink" href="#sec:simple-modules:stopping" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:endsimulation"/>4.9.1 Normal Termination<a class="headerlink" href="#sec:simple-modules:endsimulation" title="Permalink to this headline">¶</a></h3>

<p>You can terminate the simulation using the <tt>endSimulation()</tt> function:

<pre class="cpp">
endSimulation();
</pre>
<p>
<tt>endSimulation()</tt> is rarely needed in practice because you
can specify simulation time and CPU time limits<!--simulation time limits-->
in the ini file (see later).

<p><h3><a name="sec:simple-modules:raising-errors"/>4.9.2 Raising Errors<a class="headerlink" href="#sec:simple-modules:raising-errors" title="Permalink to this headline">¶</a></h3>

<p>When the simulation encounters an error condition, it can throw a
<tt>cRuntimeError</tt> exception to terminate the simulation with an error
message. (Under Cmdenv, the exception also causes a nonzero program exit
code). The <tt>cRuntimeError</tt> class has a constructor with a
<tt>printf()</tt>-like argument list. An example:

<pre class="cpp">
if (windowSize &lt;= 0)
    throw cRuntimeError("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>
Do not include a newline (<tt>\n</tt>), period, or exclamation mark
in the error text; it will be added by OMNeT++.

<p>The same effect can be achieved by calling the <tt>error()</tt> method of
<tt>cModule</tt>:

<pre class="cpp">
if (windowSize &lt;= 0)
    error("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>
Of course, the <tt>error()</tt> method can only be used when a module pointer
is available.

<p>

<p><h2><a name="sec:simple-modules:fsm"/>4.10 Finite State Machines<a class="headerlink" href="#sec:simple-modules:fsm" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:fsm-overview"/>4.10.1 Overview<a class="headerlink" href="#sec:simple-modules:fsm-overview" title="Permalink to this headline">¶</a></h3>

<p>Finite State Machines<!--finite state machine--> (FSMs)
can make life easier when dealing with <tt>handleMessage()</tt>. OMNeT++ provides a
class and a set of macros to build FSMs.

<p>The key points are:

<p><ul>
  <li> There are two kinds of states: <i>transient</i> and <i>steady</i>. On
    each event (that is, at each call to <tt>handleMessage()</tt>), the FSM
    transitions out of the current (steady) state, undergoes a series of state
    changes (runs through a number of transient states), and finally arrives at
    another steady state. Thus between two events, the system is always in one of
    the steady states. Transient states are therefore not really necessary -- they
    exist only to group actions to be taken during a transition in a convenient way.
  <li> You can assign program code to handle entering and leaving a state, known
    as entry/exit code. Staying in the same state is handled as leaving and
    re-entering the state.
  <li> Entry code should not modify the state (this is verified by OMNeT++). State
    changes (transitions) must be put into the exit code.
</ul>

<p>OMNeT++'s FSMs <i>can</i> be nested. This means
that any state (or rather, its entry or exit code) may contain a
further full-fledged <tt>FSM_Switch()</tt> (see below). This allows you
to introduce sub-states and thereby bring some structure into the
state space if it becomes too large.

<p>
<h4><a name="sec:simple-modules:fsm-api"/>4.10.1.1 The FSM API<a class="headerlink" href="#sec:simple-modules:fsm-api" title="Permalink to this headline">¶</a></h4>

<p>FSM state is stored in an object of type <tt>cFSM</tt>. The possible states
are defined by an enum; the enum is also a place to define which
state is transient and which is steady. In the following example, SLEEP
and ACTIVE are steady states and SEND is transient (the numbers
in parentheses must be unique within the state type and they are used
for constructing the numeric IDs for the states):

<pre class="cpp">
enum {
  INIT = 0,
  SLEEP = FSM_Steady(1),
  ACTIVE = FSM_Steady(2),
  SEND = FSM_Transient(1),
};
</pre>
<p>
The actual FSM is embedded in a switch-like statement, <tt>FSM_Switch()</tt>,
with cases for entering and leaving each state:

<pre class="cpp">
FSM_Switch(fsm)
{
  case FSM_Exit(state1):
    //...
    break;
  case FSM_Enter(state1):
    //...
    break;
  case FSM_Exit(state2):
    //...
    break;
  case FSM_Enter(state2):
    //...
    break;
  //...
};
</pre>
<p>

<p>State transitions are done via calls to <tt>FSM_Goto()</tt>, which simply stores
the new state in the <tt>cFSM</tt> object:

<pre class="cpp">
FSM_Goto(fsm, newState);
</pre>
<p>
The FSM starts from the state with the numeric code 0; this state
is conventionally named INIT.

<p>
<h4><a name="sec:simple-modules:debugging-fsms"/>4.10.1.2 Debugging FSMs<a class="headerlink" href="#sec:simple-modules:debugging-fsms" title="Permalink to this headline">¶</a></h4>

<p>FSMs can log their state transitions, with the output looking like this:

<pre class="filelisting">
...
FSM GenState: leaving state SLEEP
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SEND
FSM GenState: leaving state SEND
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SLEEP
...
</pre>
<p>
To enable the above output, define <tt>FSM_DEBUG</tt> before including <tt>omnetpp.h</tt>.

<pre class="cpp">
#define FSM_DEBUG    // enables debug output from FSMs
#include &lt;omnetpp.h&gt;
</pre>
<p>
FSMs perform their logging via the <tt>FSM_Print()</tt> macro, defined as something like this:

<pre class="cpp">
#define FSM_Print(fsm,exiting)
  (EV &lt;&lt; "FSM " &lt;&lt; (fsm).getName()
      &lt;&lt; ((exiting) ? ": leaving state " : ": entering state ")
      &lt;&lt; (fsm).getStateName() &lt;&lt; endl)
</pre>
<p>
The log output format can be changed by undefining <tt>FSM_Print()</tt> after the
inclusion of <tt>omnetpp.h</tt>, and providing a new definition.

<p>
<h4><a name="sec:simple-modules:fsm-implementation"/>4.10.1.3 Implementation<a class="headerlink" href="#sec:simple-modules:fsm-implementation" title="Permalink to this headline">¶</a></h4>

<p><tt>FSM_Switch()</tt> is a macro. It expands to a <tt>switch</tt>
statement embedded in a <tt>for()</tt> loop which repeats until the
FSM reaches a steady state.

<p>Infinite loops are avoided by counting state transitions: if
an FSM goes through 64 transitions without reaching a steady
state, the simulation will terminate with an error message.

<p>
<h4><a name="sec:simple-modules:fsm-example"/>4.10.1.4 An Example<a class="headerlink" href="#sec:simple-modules:fsm-example" title="Permalink to this headline">¶</a></h4>

<p>Let us write another bursty packet generator. It will have two
states, SLEEP and ACTIVE. In the SLEEP state, the module does
nothing. In the ACTIVE state, it sends messages with a given
inter-arrival time. The code was taken from the Fifo2 sample
simulation.

<p>
<pre class="cpp">
#define FSM_DEBUG
#include &lt;omnetpp.h&gt;
using namespace omnetpp;

class BurstyGenerator : public cSimpleModule
{
  protected:
    // parameters
    double sleepTimeMean;
    double burstTimeMean;
    double sendIATime;
    cPar *msgLength;

    // FSM and its states
    cFSM fsm;
    enum {
      INIT = 0,
      SLEEP = FSM_Steady(1),
      ACTIVE = FSM_Steady(2),
      SEND = FSM_Transient(1),
    };

    // variables used
    int i;
    cMessage *startStopBurst;
    cMessage *sendMessage;

    // the virtual functions
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    fsm.setName("fsm");
    sleepTimeMean = par("sleepTimeMean");
    burstTimeMean = par("burstTimeMean");
    sendIATime = par("sendIATime");
    msgLength = &par("msgLength");
    i = 0;
    WATCH(i); // always put watches in initialize()
    startStopBurst = new cMessage("startStopBurst");
    sendMessage = new cMessage("sendMessage");
    scheduleAt(0.0,startStopBurst);
}

void BurstyGenerator::handleMessage(cMessage *msg)
{
   FSM_Switch(fsm) {
     case FSM_Exit(INIT):
       // transition to SLEEP state
       FSM_Goto(fsm,SLEEP);
       break;
     case FSM_Enter(SLEEP):
       // schedule end of sleep period (start of next burst)
       scheduleAt(simTime()+exponential(sleepTimeMean), startStopBurst);
     break;
     case FSM_Exit(SLEEP):
       // schedule end of this burst
       scheduleAt(simTime()+exponential(burstTimeMean), startStopBurst);
       // transition to ACTIVE state:
       if (msg!=startStopBurst) {
         error("invalid event in state ACTIVE");
       }
       FSM_Goto(fsm,ACTIVE);
       break;
     case FSM_Enter(ACTIVE):
       // schedule next sending
       scheduleAt(simTime()+exponential(sendIATime), sendMessage);
     break;
     case FSM_Exit(ACTIVE):
       // transition to either SEND or SLEEP
       if (msg==sendMessage) {
         FSM_Goto(fsm,SEND);
       } else if (msg==startStopBurst) {
         cancelEvent(sendMessage);
         FSM_Goto(fsm,SLEEP);
       } else {
         error("invalid event in state ACTIVE");
       }
       break;
     case FSM_Exit(SEND): {
       // generate and send out job
       char msgname[32];
       sprintf(msgname, "job-%d", ++i);
       EV &lt;&lt; "Generating " &lt;&lt; msgname &lt;&lt; endl;
       cMessage *job = new cMessage(msgname);
       job-&gt;setBitLength((long) *msgLength);
       job-&gt;setTimestamp();
       send(job, "out");
       // return to ACTIVE
       FSM_Goto(fsm,ACTIVE);
       break;
     }
   }
}
</pre>

<p>

<p>
<h2><a name="sec:simple-modules:walking-module-hierarchy"/>4.11 Navigating the Module Hierarchy<a class="headerlink" href="#sec:simple-modules:walking-module-hierarchy" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:module-vectors"/>4.11.1 Module Vectors<a class="headerlink" href="#sec:simple-modules:module-vectors" title="Permalink to this headline">¶</a></h3>

<p>If a module is part of a module vector<!--module!vector-->, the
<tt>getIndex()</tt> and <tt>getVectorSize()</tt> member functions can be used to
query its index and the vector size:

<pre class="cpp">
EV &lt;&lt; "This is module [" &lt;&lt; module-&gt;getIndex() &lt;&lt;
      "] in a vector of size [" &lt;&lt; module-&gt;getVectorSize() &lt;&lt; "].\n";
</pre>
<p>

<p><h3><a name="sec:simple-modules:module-ids"/>4.11.2 Component IDs<a class="headerlink" href="#sec:simple-modules:module-ids" title="Permalink to this headline">¶</a></h3>

<p>Every component (module and channel) in the network has an ID that
can be obtained from <tt>cComponent</tt>'s <tt>getId()</tt> member
function:

<pre class="cpp">
int componentId = getId();
</pre>
<p>
An ID uniquely identifies a module or channel for the whole duration of the
simulation. This holds even when modules are created and destroyed
dynamically because IDs of deleted modules or channels are never reused for
newly created ones.

<p>To look up a component by ID, one needs to use methods of the simulation
manager object, <tt>cSimulation</tt>. <tt>getComponent()</tt> expects an ID and
returns the component's pointer if the component still exists. Otherwise, it
returns <tt>nullptr</tt>. The method has two variations, <tt>getModule(id)</tt>
and <tt>getChannel(id)</tt>. They return <tt>cModule</tt> and <tt>cChannel</tt>
pointers if the identified component is, in fact, a module or channel, respectively.
Otherwise, they return <tt>nullptr</tt>.

<pre class="cpp">
int id = 100;
cModule *mod = getSimulation()-&gt;getModule(id); // exists, and is a module
</pre>
<p>

<p><h3><a name="sec:simple-modules:walking-up-and-down-module-hierarchy"/>4.11.3 Walking Up and Down the Module Hierarchy<a class="headerlink" href="#sec:simple-modules:walking-up-and-down-module-hierarchy" title="Permalink to this headline">¶</a></h3>

<p>The parent module can be accessed by the <tt>getParentModule()</tt>
member function:

<pre class="cpp">
cModule *parent = getParentModule();
</pre>
<p>
For example, the parameters of the parent module are accessed
like this:

<pre class="cpp">
double timeout = getParentModule()-&gt;par("timeout");
</pre>
<p>
<tt>cModule</tt>'s <tt>findSubmodule()</tt> and <tt>getSubmodule()</tt>
member functions make it possible to look up the module's submodules
by name<!--module!submodule!lookup--> (or name and index if the submodule
is in a module vector). The first one returns the module ID of
the submodule, and the latter returns the module pointer. If the
submodule is not found, they return -1 or <tt>nullptr</tt>, respectively.

<pre class="cpp">
int submodID = module-&gt;findSubmodule("foo", 3); // look up "foo[3]"
cModule *submod = module-&gt;getSubmodule("foo", 3);
</pre>
<p>

<p><h3><a name="sec:simple-modules:finding-modules-by-path"/>4.11.4 Finding Modules by Path<a class="headerlink" href="#sec:simple-modules:finding-modules-by-path" title="Permalink to this headline">¶</a></h3>

<p><tt>cModule</tt>'s <tt>getModuleByPath()</tt> member function can be used to
find modules by relative or absolute path. It accepts a path string and
returns the pointer of the matching module or throws an exception if it
was not found. If it is not known in advance whether the module exists,
its companion function <tt>findModuleByPath()</tt> can be used.
<tt>findModuleByPath()</tt> returns <tt>nullptr</tt> if the module
identified by the path does not exist but otherwise behaves identically
to <tt>getModuleByPath()</tt>.<br><ul><font size=-1>[<tt>findModuleByPath()</tt> was
introduced in OMNeT++ 6.0. In previous versions, <tt>getModuleByPath()</tt>
returned <tt>nullptr</tt> if there was no matching module.]</font></ul>

<p>The path is a dot-separated list of module names. The special module name,
<tt>^</tt> (caret), stands for the parent module. If the path
starts with a dot or caret, it is understood as relative to this module.
Otherwise, it is taken to mean an absolute path. For absolute paths,
inclusion of the toplevel module's name in the path is optional.
The toplevel module itself may be referred to as <tt>&lt;root&gt;</tt>.

<p>The following lines demonstrate relative paths. They find the <tt>app[3]</tt>
submodule and the <tt>gen</tt> submodule of the <tt>app[3]</tt> submodule of the
module in question:

<pre class="cpp">
cModule *app = module-&gt;getModuleByPath(".app[3]");  // note leading dot
cModule *gen = module-&gt;getModuleByPath(".app[3].gen");
</pre>
<p>
Without the leading dot, the path is interpreted as absolute. The following
lines both find the <tt>tcp</tt> submodule of <tt>host[2]</tt> in the network,
regardless of the module on which the <tt>getModuleByPath()</tt> has been
invoked.

<pre class="cpp">
cModule *tcp = module-&gt;getModuleByPath("Network.host[2].tcp");
cModule *tcp = module-&gt;getModuleByPath("host[2].tcp");
</pre>
<p>
The parent module may be expressed with a caret:

<pre class="cpp">
cModule *parent = module-&gt;getModuleByPath("^"); // parent module
cModule *tcp = module-&gt;getModuleByPath("^.tcp"); // sibling module
cModule *other = module-&gt;getModuleByPath("^.^.host[1].tcp"); // two levels up, then...
</pre>
<p>

<p><h3><a name="sec:simple-modules:iterating-over-submodules"/>4.11.5 Iterating over Submodules<a class="headerlink" href="#sec:simple-modules:iterating-over-submodules" title="Permalink to this headline">¶</a></h3>

<p>To access all modules within a compound module,
one can use <tt>cModule::SubmoduleIterator</tt>.

<pre class="cpp">
for (cModule::SubmoduleIterator it(module); !it.end(); it++) {
    cModule *submodule = *it;
    EV &lt;&lt; submodule-&gt;getFullName() &lt;&lt; endl;
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:navigating-connections"/>4.11.6 Navigating Connections<a class="headerlink" href="#sec:simple-modules:navigating-connections" title="Permalink to this headline">¶</a></h3>

<p>To determine the module at the other end of a connection, use
<tt>cGate</tt>'s <tt>getPreviousGate()</tt>, <tt>getNextGate()</tt>, and
<tt>getOwnerModule()</tt> methods. An example:

<pre class="cpp">
cModule *neighbour = gate("out")-&gt;getNextGate()-&gt;getOwnerModule();
</pre>
<p>
For input gates, use <tt>getPreviousGate()</tt> instead of <tt>getNextGate()</tt>.

<p>The endpoints of the connection path are returned by the
<tt>getPathStartGate()</tt> and <tt>getPathEndGate()</tt> <tt>cGate</tt>
methods. These methods follow the connection path by repeatedly calling
<tt>getPreviousGate()</tt> and <tt>getNextGate()</tt>, respectively,
until they arrive at a <tt>nullptr</tt>. An example:

<pre class="cpp">
cModule *peer = gate("out")-&gt;getPathEndGate()-&gt;getOwnerModule();
</pre>
<p>

<p><h2><a name="sec:simple-modules:direct-method-calls"/>4.12 Direct Method Calls Between Modules<a class="headerlink" href="#sec:simple-modules:direct-method-calls" title="Permalink to this headline">¶</a></h2>
<!--method calls!between modules-->

<p>In some simulation models, there might be modules that are too
tightly coupled for message-based communication to be efficient.
In such cases, the solution might be to call one simple module's public
C++ methods from another module.

<p>Simple modules are C++ classes, so normal C++ method calls will
work. However, two issues need to be mentioned:

<p><ul>
  <li> how to obtain a pointer to the object representing the module;
  <li> how to inform the simulation kernel that a method call across modules is taking place.
</ul>

<p>Typically, the called module is in the same compound module as the caller,
so the <tt>getParentModule()</tt> and <tt>getSubmodule()</tt> methods of
<tt>cModule</tt> can be used to obtain a <tt>cModule*</tt> pointer to the
called module. (Further ways to obtain the pointer are described
in section <a href="chap4.html#sec:simple-modules:walking-module-hierarchy">[4.11]</a>).
The <tt>cModule*</tt> pointer then has to be cast to the actual C++ class
of the module, so that its methods become visible.

<p>This can be achieved using the following code:

<pre class="cpp">
cModule *targetModule = getParentModule()-&gt;getSubmodule("foo");
Foo *target = check_and_cast&lt;Foo *&gt;(targetModule);
target-&gt;doSomething();
</pre>
<p>
The <tt>check_and_cast&lt;&gt;()</tt> template function on the second line
is part of OMNeT++. It performs a standard C++ <tt>dynamic_cast</tt> and checks
the result: if it is <tt>nullptr</tt>, <tt>check_and_cast</tt> raises an OMNeT++ error.
Using <tt>check_and_cast</tt> saves you from writing error checking code:
if <tt>targetModule</tt> from the first line is <tt>nullptr</tt> because
the submodule named <tt>"foo"</tt> was not found, or if that
module is actually not of type <tt>Foo</tt>, an exception is thrown
from <tt>check_and_cast</tt> with an appropriate error message.<br><ul><font size=-1>[A
<tt>check_and_cast_nullable&lt;&gt;()</tt> function also exists. It
accepts <tt>nullptr</tt> as input and only complains if the cast goes wrong.]</font></ul>

<p>The second issue is how to inform the simulation kernel that
a method call across modules is taking place. Why is this necessary
in the first place? First, the simulation kernel always needs to know which
module's code is currently executing in order for ownership handling
and other internal mechanisms to work correctly. Second, the Qtenv
simulation GUI can animate method calls, but to be able to do that,
it needs to know about them. Third, method calls are also recorded
in the event log.

<p>The solution is to add the <tt>Enter_Method()</tt> or <tt>Enter_Method_Silent()</tt>
macro at the beginning of the methods that may be invoked from other
modules. These calls perform context switching and, in the case of
<tt>Enter_Method()</tt>, notify the simulation GUI so that animation
of the method call can take place. <tt>Enter_Method_Silent()</tt>
does not animate the method call, but otherwise, it is equivalent
to <tt>Enter_Method()</tt>. Both macros accept a <tt>printf()</tt>-like
argument list (it is optional for <tt>Enter_Method_Silent()</tt>),
which should produce a string with the method name and the
actual arguments as much as possible. The string is displayed in
the animation (<tt>Enter_Method()</tt> only) and recorded into the event log.

<p>
<pre class="cpp">
void Foo::doSomething()
{
    Enter_Method("doSomething()");
    ...
}
</pre>

<p>

<p><h2><a name="sec:simple-modules:creating-modules"/>4.13 Dynamic Module Creation<a class="headerlink" href="#sec:simple-modules:creating-modules" title="Permalink to this headline">¶</a></h2>
<!--module!dynamic creation-->

<p><h3><a name="sec:simple-modules:dynamic-creation:when-to-use"/>4.13.1 When To Use<a class="headerlink" href="#sec:simple-modules:dynamic-creation:when-to-use" title="Permalink to this headline">¶</a></h3>

<p>Certain simulation scenarios require the ability to dynamically create
and destroy modules. For example, simulating the arrival and departure
of new users in a mobile network may be implemented in terms of adding
and removing modules during the course of the simulation. Loading and
instantiating network topology (i.e. nodes and links) from a data file
is another common technique enabled by dynamic module (and link) creation.

<p>OMNeT++ allows both simple and compound modules to be created at runtime.
When instantiating a compound module, its full internal structure
(submodules and internal connections) is reproduced.

<p>Once created and started, dynamic modules are no different from
&#8220;static&#8221; modules.

<p>
<h3><a name="sec:simple-modules:dynamic-creation:overview"/>4.13.2 Overview<a class="headerlink" href="#sec:simple-modules:dynamic-creation:overview" title="Permalink to this headline">¶</a></h3>

<p>To understand how dynamic module creation works, you have to know a
bit about how OMNeT++ normally instantiates modules. Each module type
(class) has a corresponding factory object of the class
<tt>cModuleType</tt>. This object is created under the hood by the
<tt>Define_Module()</tt> macro, and it has a factory
method which can instantiate the module class (this function basically
only consists of a <tt>return new <i>&lt;moduleclass&gt;</i>(...)</tt> statement).

<p>The <tt>cModuleType</tt> object can be looked up by its name
string (which is the same as the module class name). Once you have its
pointer, it is possible to call its factory method and create an
instance of the corresponding module class -- without having to
include the C++ header file containing the module's class declaration
into your source file.

<p>The <tt>cModuleType</tt> object also knows what gates and
parameters the given module type has to have. (This information comes from
NED files.)

<p>Simple modules can be created in one step. For a compound module, the
situation is more complicated because its internal structure
(submodules, connections) may depend on parameter values and gate
vector sizes. Thus, for compound modules, it is generally required to
first create the module itself, second, set parameter values and gate
vector sizes, and then call the method that creates its submodules and
internal connections.

<p>As you already know, simple modules with <tt>activity()</tt> need a
starter message<!--starter messages-->. For statically created
modules, this message is created automatically by OMNeT++, but for
dynamically created modules, you have to do this explicitly by calling
the appropriate functions.

<p>Calling <tt>initialize()</tt> has to take place after insertion of the
starter messages because the initializing code may insert new messages
into the FES<!--FES-->, and these messages should be processed
<i>after</i> the starter message.

<p>
<h3><a name="sec:simple-modules:dynamic-creation:api"/>4.13.3 Creating Modules<a class="headerlink" href="#sec:simple-modules:dynamic-creation:api" title="Permalink to this headline">¶</a></h3>

<p>The first step is to find the factory object. The <tt>cModuleType::get()</tt>
function expects a fully qualified NED type name and returns the factory
object:

<pre class="cpp">
cModuleType *moduleType = cModuleType::get("foo.nodes.WirelessNode");
</pre>
<p>
The return value does not need to be checked for <tt>nullptr</tt> because
the function raises an error if the requested NED type is not found.
(If this behavior is not what you need, you can use the similar
<tt>cModuleType::find()</tt> function, which returns <tt>nullptr</tt> if the type
was not found.)

<p><h4><a name="sec:simple-modules:dynamic:createscheduleinit"/>4.13.3.1 The All-in-One Method<a class="headerlink" href="#sec:simple-modules:dynamic:createscheduleinit" title="Permalink to this headline">¶</a></h4>

<p><tt>cModuleType</tt> has a
<tt>createScheduleInit(const char *name, cModule *parentmod)</tt> % don't break this line (for html)
convenience function to get a module up and running in one step.

<pre class="cpp">
cModule *mod = moduleType-&gt;createScheduleInit("node", this);
</pre>
<p>
<tt>createScheduleInit()</tt> performs the following steps: <tt>create()</tt>,
<tt>finalizeParameters()</tt>, <tt>buildInside()</tt>,
<tt>scheduleStart(now)</tt>, and <tt>callInitialize()</tt>.

<p>This method can be used for both simple and compound modules. Its
applicability is somewhat limited, however: because it does everything in
one step, you do not have the chance to set parameters or gate sizes, and
to connect gates before <tt>initialize()</tt> is called.
(<tt>initialize()</tt> expects all parameters and gates to be in place and
the network fully built when it is called.) Because of the above
limitation, this function is mainly useful for creating basic simple
modules.

<p>
<h4><a name="sec:simple-modules:dynamic-creation:details"/>4.13.3.2 The Detailed Procedure<a class="headerlink" href="#sec:simple-modules:dynamic-creation:details" title="Permalink to this headline">¶</a></h4>

<p>If the <tt>createScheduleInit()</tt> all-in-one method is not applicable,
one needs to use the full procedure. It consists of five steps:

<p><ol>
  <li> Find the factory object;
  <li> Create the module;
  <li> Set up its parameters and gate sizes as needed;
  <li> Tell the (possibly compound) module to recursively create
        its internal submodules and connections;
  <li> Schedule activation message(s) for the new simple module(s).
</ol>

<p>Each step (except for Step 3.) can be done with one line of code.

<p>See the following example, where Step 3 is omitted:

<pre class="cpp">
// find factory object
cModuleType *moduleType = cModuleType::get("foo.nodes.WirelessNode");

// create (possibly compound) module and build its submodules (if any)
cModule *module = moduleType-&gt;create("node", this);
module-&gt;finalizeParameters();
module-&gt;buildInside();

// create activation message
module-&gt;scheduleStart(simTime());
</pre>
<p>
If you want to set up parameter values or gate vector sizes (Step 3.),
the code goes between the <tt>create()</tt> and
<tt>buildInside()</tt> calls:

<pre class="cpp">
// create
cModuleType *moduleType = cModuleType::get("foo.nodes.WirelessNode");
cModule *module = moduleType-&gt;create("node", this);

// set up parameters and gate sizes before we set up its submodules
module-&gt;par("address") = ++lastAddress;
module-&gt;finalizeParameters();

module-&gt;setGateSize("in", 3);
module-&gt;setGateSize("out", 3);

// create internals, and schedule it
module-&gt;buildInside();
module-&gt;scheduleStart(simTime());
</pre>
<p>

<p><h3><a name="sec:simple-modules:deleting-modules"/>4.13.4 Deleting Modules<a class="headerlink" href="#sec:simple-modules:deleting-modules" title="Permalink to this headline">¶</a></h3>

<p>To delete a module dynamically<!--module!dynamic deletion-->, use
<tt>cModule</tt>'s <tt>deleteModule()</tt> member function:

<pre class="cpp">
module-&gt;deleteModule();
</pre>
<p>
If the module was a compound module, this involves recursively
deleting all its submodules. An <tt>activity()</tt>-based simple module
can also delete itself; in that case, the <tt>deleteModule()</tt> call
does not return to the caller.

<p>
<h3><a name="sec:simple-modules:predelete"/>4.13.5 The preDelete() method<a class="headerlink" href="#sec:simple-modules:predelete" title="Permalink to this headline">¶</a></h3>

<p>When <tt>deleteModule()</tt> is called on a compound module, individual modules
under the compound module are notified by calling their <tt>preDelete()</tt>
member functions before any change is actually made.

<p>This notification can be quite useful when the compound module contains modules
that hold pointers to each other, necessitated by their complex interactions via
C++ method calls. With such modules, destruction can be tricky: given a
sufficiently complex control flow involving cascading cross-module method calls
and signal listeners, it is actually quite easy to accidentally invoke a method
on a module that has already been deleted at that point, resulting in a crash.
(Note that destructors of collaborating modules cannot rely on being invoked in
any particular order because that order is determined factors, e.g. submodule
order in NED, which are out of the control of the C++ code.)

<p><tt>preDelete()</tt> is a <tt>cComponent</tt> virtual method that, similar to
<tt>handleMessage()</tt> and <tt>initialize()</tt>, is intended for being overridden
by the user. When a compound module is deleted, <tt>deleteModule()</tt> first
invokes <tt>preDelete()</tt> recursively on the submodule tree and only starts
deleting modules after that. This gives a chance to modules that override
<tt>preDelete()</tt> to set pointers to collaborating modules to <tt>nullptr</tt>,
or otherwise ensure that nothing bad will happen once modules start being
deleted.

<p><tt>preDelete()</tt> receives an argument: the pointer of the module on which
<tt>deleteModule()</tt> was invoked. This allows the module to tell apart cases
when, for example, it is deleted itself or as part of a larger unit.

<p>An example:

<pre class="cpp">
void Foo::preDelete(cComponent *root)
{
    barModule = nullptr;
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:weak-compontent-ptr"/>4.13.6 Component Weak Pointers<a class="headerlink" href="#sec:simple-modules:weak-compontent-ptr" title="Permalink to this headline">¶</a></h3>

<p><tt>opp_component_ptr&lt;T&gt;</tt> offers an answer to a related problem: how to detect
when a module we have a pointer to is deleted, so that we no longer try to
access it.

<p><tt>opp_component_ptr&lt;T&gt;</tt> is a smart pointer that points to a
<tt>cComponent</tt> object (i.e. a module or a channel) and automatically
becomes <tt>nullptr</tt> when the referenced object is deleted. It is a non-owning
(&#8220;weak&#8221;) pointer, i.e. the pointer going out of scope has no effect on the
referenced object.

<p>In practice, one would replace bare pointers in the code (for example,
<tt>Foo*</tt>) with <tt>opp_component_ptr&lt;Foo&gt;</tt> smart pointers and test
before accessing the other module that the pointer is still valid.

<p>An example:

<pre class="cpp">
opp_component_ptr&lt;Foo&gt; fooModule;  // as class member

if (fooModule)
    fooModule-&gt;doSomething();

// or: obtain a bare pointer for multiple use
if (Foo *fooPtr = fooModule.get()) {
    fooPtr-&gt;doSomething();
    fooPtr-&gt;doSomethingElse();
}
</pre>
<p>

<p><h3><a name="sec:simple-modules:module-deletion-and-finish"/>4.13.7 Module Deletion and finish()<a class="headerlink" href="#sec:simple-modules:module-deletion-and-finish" title="Permalink to this headline">¶</a></h3>

<p><tt>finish()</tt> is called for <i>all</i> modules at the end of the
simulation, no matter how the modules were created. If a module is
dynamically deleted before that, <tt>finish()</tt> will not be invoked
(<tt>deleteModule()</tt> does not do it). However, you can still manually
invoke it before <tt>deleteModule()</tt>.

<p>You can use the <tt>callFinish()</tt> function to invoke <tt>finish()</tt>
(It is not a good idea to invoke <tt>finish()</tt> directly). If you are
deleting a compound module, <tt>callFinish()</tt> will recursively invoke
<tt>finish()</tt> for all submodules, and if you are deleting a simple
module from another module, <tt>callFinish()</tt> will do the context switch
for the duration of the call.
  <br><ul><font size=-1>[The <tt>finish()</tt> function has even been made <tt>protected</tt>
  in <tt>cSimpleModule</tt>, in order to discourage its invocation from
  other modules.]</font></ul>

<p>Example:

<pre class="cpp">
mod-&gt;callFinish();
mod-&gt;deleteModule();
</pre>
<p>

<p><h3><a name="sec:simple-modules:creating-connections"/>4.13.8 Creating Connections<a class="headerlink" href="#sec:simple-modules:creating-connections" title="Permalink to this headline">¶</a></h3>
<!--connection!creating-->

<p>Connections can be created using <tt>cGate</tt>'s <tt>connectTo()</tt>
method. <tt>connectTo()</tt> should be invoked on the source gate
of the connection and expects the destination gate pointer as
an argument. The use of the words <i>source</i> and <i>destination</i>
correspond to the direction of the arrow in NED files.

<pre class="cpp">
srcGate-&gt;connectTo(destGate);
</pre>
<p>
<tt>connectTo()</tt> also accepts a channel object (<tt>cChannel*</tt>) as an
additional, optional argument. Similarly to modules, channels can be
created using their factory objects that have the type <tt>cChannelType</tt>:

<pre class="cpp">
cGate *outGate, *inGate;
...

// find factory object and create a channel
cChannelType *channelType = cChannelType::get("foo.util.Channel");
cChannel *channel = channelType-&gt;create("channel");

// create connecting
outGate-&gt;connectTo(inGate, channel);
</pre>
<p>
The channel object will be owned by the source gate of the connection, and
one cannot reuse the same channel object with several connections.

<p>Instantiating one of the built-in channel types (<tt>cIdealChannel</tt>,
<tt>cDelayChannel</tt>, or <tt>cDatarateChannel</tt>) is somewhat simpler
because those classes have static <tt>create()</tt> factory functions and the
step of finding the factory object can be spared. Alternatively, one can use
<tt>cChannelType</tt>'s <tt>createIdealChannel()</tt>, <tt>createDelayChannel()</tt>,
and <tt>createDatarateChannel()</tt> static methods.

<p>The channel object may need to be parameterized before using it for a
connection. For example, <tt>cDelayChannel</tt> has a <tt>setDelay()</tt>
method, and <tt>cDatarateChannel</tt> has <tt>setDelay()</tt>,
<tt>setDatarate()</tt>, <tt>setBitErrorRate()</tt>, and
<tt>setPacketErrorRate()</tt>.

<p>An example that sets up a channel with a datarate and a delay between two
modules:

<pre class="cpp">
cDatarateChannel *datarateChannel = cDatarateChannel::create("channel");
datarateChannel-&gt;setDelay(0.001);
datarateChannel-&gt;setDatarate(1e9);
outGate-&gt;connectTo(inGate, datarateChannel);
</pre>
<p>
Finally, here is a more complete example that creates two modules and
connects them in both directions:

<pre class="cpp">
cModuleType *moduleType = cModuleType::get("TicToc");
cModule *a = modtype-&gt;createScheduleInit("a", this);
cModule *b = modtype-&gt;createScheduleInit("b", this);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"));
b-&gt;gate("out")-&gt;connectTo(a-&gt;gate("in"));
</pre>
<p>

<p><h3><a name="sec:simple-modules:removing-connections"/>4.13.9 Removing Connections<a class="headerlink" href="#sec:simple-modules:removing-connections" title="Permalink to this headline">¶</a></h3>
<!--connection!removing-->

<p>The <tt>disconnect()</tt> method of <tt>cGate</tt> can be
used to remove connections. This method has to be invoked
on the <i>source</i> side of the connection. It also destroys
the channel object associated with the connection if one has been set.

<pre class="cpp">
srcGate-&gt;disconnect();
</pre>
<p>

<p>
<h2><a name="sec:simple-modules:signals"/>4.14 Signals<a class="headerlink" href="#sec:simple-modules:signals" title="Permalink to this headline">¶</a></h2>

<p>This section describes <i>simulation signals</i>, or signals for short.
Signals are a versatile concept that first appeared in OMNeT++ 4.1.

<p>Simulation signals can be used for:

<p><ul>
  <li> exposing statistical properties of the model, without specifying
        whether and how to record them
  <li> receiving notifications about simulation model changes at runtime, and
        acting upon them
  <li> implementing a publish-subscribe style communication among modules;
        this is advantageous when the producer and consumer of the information
        do not know about each other, and possibly there is a many-to-one or
        many-to-many relationship among them
  <li> emitting information for other purposes, for example as input for
        custom animation effects
</ul>

<p>Signals are emitted by components (modules and channels). Signals propagate on
the module hierarchy up to the root. At any level, one can register listeners,
that is, objects with callback methods. These listeners will be notified (their
appropriate methods called) whenever a signal value is emitted. The result of
upwards propagation is that listeners registered at a compound module can
receive signals from all components in that submodule tree. A listener
registered at the system module can receive signals from the whole simulation.

<p><ul class="note"><b>NOTE</b><br>
    A channel's parent is the (compound) module that contains the connection,
    not the owner of either gate the channel is connected to.
</ul>

<p>Signals are identified by signal <i>names</i> (i.e. strings), but for efficiency,
at runtime we use dynamically assigned numeric identifiers (<i>signal IDs</i>,
typedef'd as <tt>simsignal_t</tt>). The mapping of signal names to signal IDs is
global, so all modules and channels asking to resolve a particular signal name
will get back the same numeric signal ID.

<p>Listeners can subscribe to signal names or IDs, regardless of their
source. For example, if two different and unrelated module types, say
<tt>Queue</tt> and <tt>Buffer</tt>, both emit a signal named <tt>"length"</tt>, then
a listener that subscribes to <tt>"length"</tt> at some higher compound module
will get notifications from both <tt>Queue</tt> and <tt>Buffer</tt> module
instances. The listener can still look at the source of the signal if it
wants to distinguish the two (it is available as a parameter to the
callback function), but the signals framework itself does not have such a
feature.

<p><ul class="note"><b>NOTE</b><br>
  Because the component type that emits the signal is not part of the signal's
  identity, it is advised to choose signal names carefully. A good naming scheme
  facilitates the &#8220;merging&#8221; of signals that arrive from different sources but
  mean the same thing, and reduces the chance of collisions between signals that
  accidentally have the same name but represent different things.
</ul>

<p>When a signal is emitted, it can carry a <i>value</i> with it. There are
multiple overloaded versions of the <tt>emit()</tt> method for different
data types, and also overloaded <tt>receiveSignal()</tt> methods in
listeners. The signal value can be of selected primitive types, or an
object pointer; anything that is not feasible to emit as a primitive type
may be wrapped into an object and emitted as such.

<p>Even when the signal value is of a primitive type, it is possible to convey
extra information to listeners via an additional <i>details</i> object,
which is an optional argument of <tt>emit()</tt>.

<p><h3><a name="sec:simple-modules:signals-design"/>4.14.1 Design Considerations and Rationale<a class="headerlink" href="#sec:simple-modules:signals-design" title="Permalink to this headline">¶</a></h3>

<p>The implementation of signals is based on the following assumptions:

<p><ul>
  <li> subscribe/unsubscribe operations are rare compared to <tt>emit()</tt>
    calls, so it is <tt>emit()</tt> that needs to be efficient
  <li> the signals mechanism is present in every module, so per-module
    memory overhead must be kept as low as possible
  <li> it is expected that modules and channels will be heavily instrumented
    with signals, and only a subset of signals will actually be used
    (will have listeners) in any particular simulation; therefore,
    the CPU and memory overhead of momentarily unused signals must be
    as low as possible
</ul>

<p>These goals have been achieved in the 4.1 version with the following
implementation. First, the data structure that used to store listeners in
components is dynamically allocated, so if there are no listeners, the
per-component overhead is only the size of the pointer (which will be
<tt>nullptr</tt> then).

<p>Second, additionally there are two bitfields in every component that store
which one of the first 64 signals (IDs 0..63) have local listeners and
listeners in ancestor modules.<br><ul><font size=-1>[It is assumed that there will be
typically less than 64 frequently used signals used at a time in a
simulation.]</font></ul> Using these bitfields, it is possible to determine in constant
time for the first 64 signals whether the signal has listeners, so
<tt>emit()</tt> can return immediately if there are none. For other signals,
<tt>emit()</tt> needs to examine the listener lists up to the root every
time. Even if a simulation uses more than 64 signals, in
performance-critical situations it is possible to arrange that frequently
emitted signals (e.g. <tt>"txBegin"</tt>) get the &#8220;fast&#8221; signal IDs, while
infrequent signals (like e.g. <tt>"routerDown"</tt>) get the rest.

<p>
<h3><a name="sec:simple-modules:signals-api"/>4.14.2 The Signals Mechanism<a class="headerlink" href="#sec:simple-modules:signals-api" title="Permalink to this headline">¶</a></h3>

<p>Signal-related methods are declared on <tt>cComponent</tt>, so they are available
for both <tt>cModule</tt> and <tt>cChannel</tt>.

<p><h4><a name="sec:simple-modules:signal-ids"/>4.14.2.1 Signal IDs<a class="headerlink" href="#sec:simple-modules:signal-ids" title="Permalink to this headline">¶</a></h4>

<p>Signals are identified by names, but internally, numeric signal IDs are used
for efficiency. The <tt>registerSignal()</tt> method takes a signal name as
a parameter and returns the corresponding <tt>simsignal_t</tt> value.
The method is static, illustrating the fact that signal names are global.
An example:

<pre class="cpp">
simsignal_t lengthSignalId = registerSignal("length");
</pre>
<p>
The <tt>getSignalName()</tt> method (also static) does the reverse:
it accepts a <tt>simsignal_t</tt> and returns the name of the signal as
a <tt>const char *</tt> (or <tt>nullptr</tt> for an invalid signal handle):

<pre class="cpp">
const char *signalName = getSignalName(lengthSignalId); // --&gt; "length"
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  Since OMNeT++ 4.3, the lifetime of signal IDs is the entire program, and
  it is possible to call <tt>registerSignal()</tt> from initializers of
  global variables, e.g., static class members. In earlier versions,
  signal IDs were usually allocated in <tt>initialize()</tt> and were
  only valid for that simulation run.
</ul>

<p><h4><a name="sec:simple-modules:emitting-signals"/>4.14.2.2 Emitting Signals<a class="headerlink" href="#sec:simple-modules:emitting-signals" title="Permalink to this headline">¶</a></h4>

<p>The <tt>emit()</tt> family of functions emit a signal from the module or
channel. <tt>emit()</tt> takes a signal ID (<tt>simsignal_t</tt>) and
a value as parameters:

<pre class="cpp">
emit(lengthSignalId, queue.length());
</pre>
<p>
The value can be of type <tt>bool</tt>, <tt>long</tt>, <tt>double</tt>, <tt>simtime_t</tt>,
<tt>const char *</tt>, or <tt>(const) cObject *</tt>. Other types can be cast into
one of these types or wrapped into an object subclassed from <tt>cObject</tt>.

<p><tt>emit()</tt> also has an extra, optional object pointer argument named
<tt>details</tt>, with the type <tt>cObject*</tt>. This argument may be used
to convey extra information to listeners.<br><ul><font size=-1>[The <i>details</i>
parameter was added in OMNeT++ 5.0.]</font></ul>

<p>When there are no listeners, the runtime cost of <tt>emit()</tt> is usually minimal.
However, if producing a value has a significant runtime cost, then the
<tt>mayHaveListeners()</tt> or <tt>hasListeners()</tt> method can be used
to check beforehand whether the given signal has any listeners at all.
If not, producing the value and emitting the signal can be skipped.

<p>Example usage:

<pre class="cpp">
if (mayHaveListeners(distanceToTargetSignal)) {
    double d = sqrt((x-targetX)*(x-targetX) + (y-targetY)*(y-targetY));
    emit(distanceToTargetSignal, d);
}
</pre>
<p>
The <tt>mayHaveListeners()</tt> method is very efficient (a constant-time
operation) but may return false positive. In contrast,
<tt>hasListeners()</tt> will search up to the top of the module tree if
the answer is not cached, so it is generally slower. We recommend that
you take into account the cost of producing notification information when
deciding between <tt>mayHaveListeners()</tt> and <tt>hasListeners()</tt>.

<p>
<h4><a name="sec:simple-modules:signal-declarations"/>4.14.2.3 Signal Declarations<a class="headerlink" href="#sec:simple-modules:signal-declarations" title="Permalink to this headline">¶</a></h4>

<p>Since OMNeT++ 4.4, signals can be declared in NED files for documentation
purposes, and OMNeT++ can check that only declared signals are emitted,
and that they actually conform to the declarations (with regard to the
data type, etc.)

<p>The following example declares a queue module that emits a signal named
<tt>queueLength</tt>:

<pre class="ned">
simple Queue
{
    parameters:
        @signal[queueLength](type=long);
        ...
}
</pre>
<p>
Signals are declared with the <b><tt>@signal</tt></b> property on
the module or channel that emits it. (NED properties are described in
<a href="chap3.html#sec:ned-lang:properties">[3.12]</a>). The property index corresponds
to the signal name, and the property's body may declare various attributes
of the signal; currently only the data type is supported.

<p>The <tt>type</tt> property key is optional; when present, its value should be
<tt>bool</tt>, <tt>long</tt>, <tt>unsigned long</tt>, <tt>double</tt>, <tt>simtime_t</tt>,
<tt>string</tt>, or a registered class name optionally followed by a question
mark. Classes can be registered using the <tt>Register_Class()</tt> or
<tt>Register_Abstract_Class()</tt> macros; these macros create a
<tt>cObjectFactory</tt> instance, and the simulation kernel will call
<tt>cObjectFactory</tt>'s <tt>isInstance()</tt> method to check that the
emitted object is really a subclass of the declared class.
<tt>isInstance()</tt> just wraps a C++ <tt>dynamic_cast</tt>.)

<p>A question mark after the class name means that the signal is allowed to
emit <tt>nullptr</tt> pointers. For example, a module named <tt>PPP</tt> may emit
the frame (packet) object every time it starts transmitting and emit
<tt>nullptr</tt> when the transmission is completed:

<pre class="ned">
simple PPP
{
    parameters:
        @signal[txFrame](type=PPPFrame?);  // a PPPFrame or nullptr
        ...
}
</pre>
<p>
The property index may contain wildcards, which is important for declaring
signals whose names are only known at runtime. For example, if a module emits
signals called <tt>session-1-seqno</tt>, <tt>session-2-seqno</tt>, <tt>session-3-seqno</tt>,
etc., those signals can be declared as:

<pre class="ned">
    @signal[session-*-seqno]();
</pre>
<p>

<p><h4><a name="sec:simple-modules:enabling-signal-checking"/>4.14.2.4 Enabling/Disabling Signal Checking<a class="headerlink" href="#sec:simple-modules:enabling-signal-checking" title="Permalink to this headline">¶</a></h4>

<p>Starting with OMNeT++ 5.0, signal checking is turned on by default when
the simulation kernel is compiled in debug mode, requiring all signals to be
declared with <b><tt>@signal</tt></b>. (It is turned off in release-mode
simulation kernels due to performance reasons.)

<p>If needed, signal checking can be disabled with the <b><tt>check-signals</tt></b>
configuration option:

<pre class="inifile">
check-signals = false
</pre>
<p>

<p><h4><a name="sec:simple-modules:signal-data-objects"/>4.14.2.5 Signal Data Objects<a class="headerlink" href="#sec:simple-modules:signal-data-objects" title="Permalink to this headline">¶</a></h4>

<p>When emitting a signal with a <tt>cObject*</tt> pointer, you can pass as data
an object that you already have in the model, provided you have a suitable
object at hand. However, it is often necessary to declare a custom class
to hold all the details, and fill in an instance just for the purpose of
emitting the signal.

<p>The custom notification class must be derived from <tt>cObject</tt>.
We recommend that you also add <tt>noncopyable</tt> as a base class, because
then you don't need to write a copy constructor, assignment operator, and
<tt>dup()</tt> function, sparing some work. When emitting the signal, you
can create a temporary object and pass its pointer to the <tt>emit()</tt>
function.

<p>An example of custom notification classes are the ones associated with
model change notifications (see <a href="chap4.html#sec:simple-modules:model-change">[4.14.3]</a>).
For example, the data class that accompanies a signal that announces that a
gate or gate vector is about to be created looks like this:

<pre class="cpp">
class cPreGateAddNotification : public cObject, noncopyable
{
  public:
    cModule *module;
    const char *gateName;
    cGate::Type gateType;
    bool isVector;
};
</pre>
<p>
And the code that emits the signal:

<pre class="cpp">
if (hasListeners(PRE_MODEL_CHANGE))
{
    cPreGateAddNotification tmp;
    tmp.module = this;
    tmp.gateName = gatename;
    tmp.gateType = type;
    tmp.isVector = isVector;
    emit(PRE_MODEL_CHANGE, &tmp);
}
</pre>
<p>

<p><h4><a name="sec:simple-modules:subscribing-to-signals"/>4.14.2.6 Subscribing to Signals<a class="headerlink" href="#sec:simple-modules:subscribing-to-signals" title="Permalink to this headline">¶</a></h4>

<p>The <tt>subscribe()</tt> method registers a listener for a signal.
Listeners are objects that extend the <tt>cIListener</tt> class.
The same listener object can be subscribed to multiple signals.
<tt>subscribe()</tt> has two arguments: the signal and a pointer to
the listener object:

<pre class="cpp">
cIListener *listener = ...;
simsignal_t lengthSignalId = registerSignal("length");
subscribe(lengthSignalId, listener);
</pre>
<p>
For convenience, the <tt>subscribe()</tt> method has a variant
that takes the signal name directly, so the <tt>registerSignal()</tt>
call can be omitted:

<pre class="cpp">
cIListener *listener = ...;
subscribe("length", listener);
</pre>
<p>
One can also subscribe at other modules, not only the local one.
For example, to get signals from all parts of the model,
one can subscribe at the system module level:

<pre class="cpp">
cIListener *listener = ...;
getSimulation()-&gt;getSystemModule()-&gt;subscribe("length", listener);
</pre>
<p>
The <tt>unsubscribe()</tt> method has the same parameter list
as <tt>subscribe()</tt> and unregisters the given listener
from the signal:

<pre class="cpp">
unsubscribe(lengthSignalId, listener);
</pre>
<p>
or

<pre class="cpp">
unsubscribe("length", listener);
</pre>
<p>
It is an error to subscribe the same listener to the same
signal twice.

<p>It is possible to test whether a listener is subscribed to a signal
using the <tt>isSubscribed()</tt> method, which also takes the same
parameter list.

<pre class="cpp">
if (isSubscribed(lengthSignalId, listener)) {
    ...
}
</pre>
<p>
For completeness, there are methods for getting the list of signals
that the component has subscribed to (<tt>getLocalListenedSignals()</tt>)
and the list of listeners for a given signal (<tt>getLocalSignalListeners()</tt>).
The former returns a <tt>std::vector&lt;simsignal_t&gt;</tt>; the latter takes
a signal ID (<tt>simsignal_t</tt>) and returns a <tt>std::vector&lt;cIListener*&gt;</tt>.

<p>The following example prints the number of listeners for each signal:

<pre class="cpp">
EV &lt;&lt; "Signal listeners:\n";
std::vector&lt;simsignal_t&gt; signals = getLocalListenedSignals();
for (unsigned int i = 0; i &lt; signals.size(); i++) {
    simsignal_t signalID = signals[i];
    std::vector&lt;cIListener*&gt; listeners = getLocalSignalListeners(signalID);
    EV &lt;&lt; getSignalName(signalID) &lt;&lt; ": " &lt;&lt; listeners.size() &lt;&lt; " signals\n";
}
</pre>
<p>
<h4><a name="sec:simple-modules:signal-listeners"/>4.14.2.7 Listeners<a class="headerlink" href="#sec:simple-modules:signal-listeners" title="Permalink to this headline">¶</a></h4>

<p>Listeners are objects that subclass from the <tt>cIListener</tt> class, which
declares the following methods:

<pre class="cpp">
class cIListener
{
  public:
    virtual ~cIListener() {}
    virtual void receiveSignal(cComponent *src, simsignal_t id,
                               bool value, cObject *details) = 0;
    virtual void receiveSignal(cComponent *src, simsignal_t id,
                               intval_t value, cObject *details) = 0;
    virtual void receiveSignal(cComponent *src, simsignal_t id,
                               uintval_t value, cObject *details) = 0;
    virtual void receiveSignal(cComponent *src, simsignal_t id,
                               double value, cObject *details) = 0;
    virtual void receiveSignal(cComponent *src, simsignal_t id,
                               simtime_t value, cObject *details) = 0;
    virtual void receiveSignal(cComponent *src, simsignal_t id,
                               const char *value, cObject *details) = 0;
    virtual void receiveSignal(cComponent *src, simsignal_t id,
                               cObject *value, cObject *details) = 0;
    virtual void finish(cComponent *component, simsignal_t id) {}
    virtual void subscribedTo(cComponent *component, simsignal_t id) {}
    virtual void unsubscribedFrom(cComponent *component, simsignal_t id) {}
};
</pre>
<p>
This class has a number of virtual methods:

<p><ul>
  <li> Several overloaded <tt>receiveSignal()</tt> methods, one for each
    data type. Whenever a signal is emitted (via <tt>emit()</tt>), the matching
    <tt>receiveSignal()</tt> method is invoked on the subscribed listeners.
  <li> <tt>finish()</tt> is called by a component on its local listeners
    after the component's <tt>finish()</tt> method was called. If the listener
    is subscribed to multiple signals or at multiple components, the method
    will be called multiple times. Note that <tt>finish()</tt> methods in general
    are not invoked if the simulation terminates with an error, so that method
    is not a place for doing cleanup.
  <li> <tt>subscribedTo()</tt>, <tt>unsubscribedFrom()</tt> are called
    when this listener object is subscribed/unsubscribed to (from) a signal.
    These methods give the opportunity for listeners to track whether
    and where they are subscribed. It is also OK for a listener to delete
    itself in the last statement of the <tt>unsubscribedFrom()</tt> method,
    but you must be sure that there are no other places the same listener
    is still subscribed.
</ul>

<p>Since <tt>cIListener</tt> has a large number of pure virtual methods, it is more
convenient to subclass from <tt>cListener</tt>, a do-nothing implementation
instead. It defines <tt>finish()</tt>, <tt>subscribedTo()</tt>, and
<tt>unsubscribedFrom()</tt> with an empty body, and the <tt>receiveSignal()</tt>
methods with bodies that throw a <tt>"Data type not supported"</tt> error.
You can redefine the <tt>receiveSignal()</tt> method(s) whose data type
you want to support, and signals emitted with other (unexpected) data
types will result in an error instead of going unnoticed.

<p>The order in which listeners will be notified is undefined (it is not necessarily
the same order in which listeners were subscribed.)

<p><h4><a name="sec:simple-modules:signals:life-cycle"/>4.14.2.8 Listener Life Cycle<a class="headerlink" href="#sec:simple-modules:signals:life-cycle" title="Permalink to this headline">¶</a></h4>

<p>When a component (module or channel) is deleted, it automatically
unsubscribes (but does not delete) the listeners it has. When a
module is deleted, it first unsubscribes all listeners from all
modules and channels in its submodule tree before starting
to recursively delete the modules and channels themselves.

<p>When a listener is deleted, it automatically unsubscribes from all components
it is subscribed to.<br><ul><font size=-1>[This behavior is new in <i>OMNeT++ 6.0</i>. Prior versions
mandated that the listener be already unsubscribed from all places when its
destructor runs, but did not automatically unsubscribe.]</font></ul>

<p><ul class="note"><b>NOTE</b><br>
  If your module has added listeners to other modules (e.g., the top-level
  module), these listeners must be unsubscribed in the module
  destructor at the latest. Remember to make sure the modules still exist before you
  call <tt>unsubscribe()</tt> on them, unless they are an ancestor
  of your module in the module tree.
</ul>

<p>
<h3><a name="sec:simple-modules:model-change"/>4.14.3 Listening to Model Changes<a class="headerlink" href="#sec:simple-modules:model-change" title="Permalink to this headline">¶</a></h3>

<p>In simulation models, it is often useful to hold references to other
modules, a connecting channel, or other objects, or to cache information
derived from the model topology. However, such pointers or data may
become invalid when the model changes at runtime and need to be updated
or recalculated. The problem is how to get notification that something has
changed in the model.

<p><ul class="note"><b>NOTE</b><br>
  Whenever you see a <tt>cModule*</tt>, <tt>cChannel*</tt>, <tt>cGate*</tt>, or
  similar pointer kept as state in a simple module, you should think about
  how it will be kept up-to-date if the model changes at runtime.
</ul>

<p>The solution is, of course, signals. OMNeT++ has two built-in signals,
<tt>PRE_MODEL_CHANGE</tt> and <tt>POST_MODEL_CHANGE</tt> (these macros
are <tt>simsignal_t</tt> values, not names) that are emitted before and
after each model change.

<p>Pre/post model change notifications are emitted with data objects that
carry the details of the change. The data classes are:

<p><ul>
  <li> <tt>cPreModuleAddNotification</tt> / <tt>cPostModuleAddNotification</tt>
  <li> <tt>cPostModuleBuildNotification</tt>
  <li> <tt>cPostComponentInitializeNotification</tt>
  <li> <tt>cPreModuleDeleteNotification</tt> / <tt>cPostModuleDeleteNotification</tt>
  <li> <tt>cPreModuleReparentNotification</tt> / <tt>cPostModuleReparentNotification</tt>
  <li> <tt>cPreGateAddNotification</tt> / <tt>cPostGateAddNotification</tt>
  <li> <tt>cPreGateDeleteNotification</tt> / <tt>cPostGateDeleteNotification</tt>
  <li> <tt>cPreGateVectorResizeNotification</tt> / <tt>cPostGateVectorResizeNotification</tt>
  <li> <tt>cPreGateConnectNotification</tt> / <tt>cPostGateConnectNotification</tt>
  <li> <tt>cPreGateDisconnectNotification</tt> / <tt>cPostGateDisconnectNotification</tt>
  <li> <tt>cPrePathCreateNotification</tt> / <tt>cPostPathCreateNotification</tt>
  <li> <tt>cPrePathCutNotification</tt> / <tt>cPostPathCutNotification</tt>
  <li> <tt>cPreParameterChangeNotification</tt> / <tt>cPostParameterChangeNotification</tt>
  <li> <tt>cPreDisplayStringChangeNotification</tt> / <tt>cPostDisplayStringChangeNotification</tt>
</ul>

<p>They all subclass from <tt>cModelChangeNotification</tt>, which is, of course, a
<tt>cObject</tt>. Inside the listener, you can use <tt>dynamic_cast&lt;&gt;</tt> to figure
out what notification arrived.

<p><ul class="note"><b>NOTE</b><br>
  Please look up these classes in the API documentation to see their data fields,
  when exactly they get fired, and what one needs to be careful about when using them.
</ul>

<p>An example listener that prints a message when a module is deleted:

<pre class="cpp">
class MyListener : public cListener
{
   ...
};

void MyListener::receiveSignal(cComponent *src, simsignal_t id, cObject *value,
                               cObject *details)
{
    if (dynamic_cast&lt;cPreModuleDeleteNotification *&gt;(value)) {
        cPreModuleDeleteNotification *data = (cPreModuleDeleteNotification *)value;
        EV &lt;&lt; "Module " &lt;&lt; data-&gt;module-&gt;getFullPath() &lt;&lt; " is about to be deleted\n";
    }
}
</pre>
<p>
If you'd like to get notification about the deletion of any module, you need
to install the listener on the system module:

<pre class="cpp">
getSimulation()-&gt;getSystemModule()-&gt;subscribe(PRE_MODEL_CHANGE, listener);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
  <tt>PRE_MODEL_CHANGE</tt> and <tt>POST_MODEL_CHANGE</tt> are fired on the
  module (or channel) affected by the change, and <i>not</i> on the module
  which executes the code that causes the change. For example,
  <i>pre-module-deleted</i> is fired on the module to be removed, and
  <i>post-module-deleted</i> is fired on its parent (because the original
  module no longer exists), and not on the module that contains the
  <tt>deleteModule()</tt> call.
</ul>

<p><ul class="note"><b>NOTE</b><br>
  A listener will <i>not</i> receive <i>pre/post-module-deleted</i>
  notifications if the whole submodule tree that contains the subscription
  point is deleted. This is because compound module destructors begin
  by unsubscribing all modules/channels in the subtree before starting
  recursive deletion.
</ul>

<p>
<h2><a name="sec:simple-modules:signal-based-statistics"/>4.15 Signal-Based Statistics Recording<a class="headerlink" href="#sec:simple-modules:signal-based-statistics" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:simple-modules:signal-based-statistics-motivation"/>4.15.1 Motivation<a class="headerlink" href="#sec:simple-modules:signal-based-statistics-motivation" title="Permalink to this headline">¶</a></h3>

<p>One use of signals is to expose variables for result collection without
specifying where, how, and whether to record them. With this approach,
modules only publish the variables, and the actual result recording
takes place in listeners. Listeners may be added by the simulation
framework (based on the configuration) or by other modules (for example,
by dedicated result collection modules).

<p>The signals approach allows for several possibilities:

<p><ul>
 <li> Provides a controllable level of detail: in some simulation runs,
    you may want to record all values as a time series; in other runs,
    you may only want to record the mean, time average, minimum/maximum
    value, standard deviation, etc.; and in yet other runs,
    you may want to record the distribution as a histogram.
 <li> Depending on the purpose of the simulation experiment, you may want
    to process the results before recording them. For example,
    you may want to record a smoothed or filtered value, the percentage
    of time the value is nonzero or over a threshold, the sum of the values,
    etc.
 <li> You may want aggregate statistics, such as recording the total number
    of packet drops or the average end-to-end delay for the entire network.
 <li> You may want to record combined statistics, for example, a drop
    percentage (drop count/total number of packets).
 <li> You may want to ignore results generated during the warm-up period
    or during other transients.
</ul>

<p>The signals approach can fulfill the above goals.

<p>
<h3><a name="sec:simple-modules:declaring-statistics"/>4.15.2 Declaring Statistics<a class="headerlink" href="#sec:simple-modules:declaring-statistics" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:simple-modules:declared-statistics:introduction"/>4.15.2.1 Introduction<a class="headerlink" href="#sec:simple-modules:declared-statistics:introduction" title="Permalink to this headline">¶</a></h4>

<p>In order to record simulation results based on signals, you need to add
<b><tt>@statistic</tt></b> properties to the NED definition of the simple module
or channel. A <b><tt>@statistic</tt></b> property defines the name of the
statistic, which signal(s) are used as input, what processing steps are to
be applied to them (e.g., smoothing, filtering, summing, differential
quotient), and what properties are to be recorded (minimum, maximum,
average, etc.) and in which form (vector, scalar, histogram). Record items
can be marked optional, which allows you to denote a <i>&#8220;default&#8221;</i>
and a more comprehensive <i>&#8220;all&#8221;</i> result set to be recorded.
The list of record items can be further tweaked from the configuration.
You can also specify a descriptive name (&#8220;title&#8221;) for the statistic, as
well as a measurement unit.

<p>The following example declares a queue module with a queue length statistic:

<pre class="ned">
simple Queue
{
    parameters:
        @statistic[queueLength](record=max,timeavg,vector?);
    gates:
        input in;
        output out;
}
</pre>
<p>
As you can see, statistics are represented with indexed NED properties (see
<a href="chap3.html#sec:ned-lang:properties">[3.12]</a>). The property name is always <tt>statistic</tt>,
and the index (here, <tt>queueLength</tt>) is the name of the statistic. The
property value, that is, everything inside the parentheses, provides hints
and extra information for recording.

<p>The above <tt>@statistic</tt> declaration assumes that the module's C++ code
emits the queue's updated length as signal <tt>queueLength</tt> whenever
elements are inserted into the queue or removed from it.
By default, the maximum and the time average of the queue length will
be recorded as scalars. You can also instruct the simulation to record
&#8220;all&#8221; results, which will turn on optional record items marked
with a question mark. In this case, the queue lengths will also be
recorded into an output vector.

<p><ul class="note"><b>NOTE</b><br>
The configuration lets you fine-tune the list of result items even
beyond the <tt>default</tt> and <tt>all</tt> settings. See section
<a href="chap12.html#sec:ana-sim:configuring-recording-modes">[12.2.3]</a> for more information.
</ul>

<p>In the above example, the signal to be recorded was taken from the
statistic name. However, if this is not suitable, you can use the
<tt>source</tt> property key to specify a different signal as input for the
statistic. The following example assumes that the C++ code emits a <tt>qlen</tt>
signal and declares a <tt>queueLength</tt> statistic based on that:

<pre class="ned">
simple Queue
{
    parameters:
        @signal[qlen](type=int); // optional
        @statistic[queueLength](source=qlen; record=max,timeavg,vector?);
        ...
}
</pre>
<p>
Note that the <tt>source=qlen</tt> property key has been added to specify
the <tt>qlen</tt> signal as the input for the statistic. Additionally, a
signal declaration (<b><tt>@signal</tt></b> property) has been added for the
<i>qlen</i> signal. Although signal declarations are currently optional
and ignored by the system, it is good practice to include them.

<p>You can also apply processing to a signal before recording it. Consider
the following example:

<pre class="ned">
@statistic[dropCount](source=count(drop); record=last,vector?);
</pre>
<p>
This records the total number of packet drops as a scalar and, optionally,
the number of packets dropped over time as a vector. This assumes that the
C++ code emits a <tt>drop</tt> signal every time a packet is dropped.
Here, <tt>count()</tt> is a <i>result filter</i>.

<p><ul class="note"><b>NOTE</b><br>
Starting from OMNeT++ 4.4, items containing parentheses (e.g.,
<tt>count(drop)</tt>) no longer need to be enclosed in quotation marks.
</ul>

<p>Another example:

<pre class="ned">
@statistic[droppedBytes](source=sum(packetBytes(pkdrop)); record=last,vector?);
</pre>
<p>
This assumes that the C++ code emits a <tt>pkdrop</tt> signal with a
<tt>cPacket</tt> pointer as the value. Based on that signal, it records
the total number of bytes dropped as a scalar and optionally as a vector.
The <tt>packetBytes()</tt> filter extracts the number of bytes from each packet
using the <tt>getByteLength()</tt> method in <tt>cPacket</tt>, and the
<tt>sum()</tt> filter sums up the values.

<p>Arithmetic expressions can also be used. For example, the following line
computes the number of dropped bytes using the <tt>packetBits()</tt> filter:

<pre class="ned">
@statistic[droppedBytes](source=sum(8*packetBits(pkdrop)); record=last,
vector?);
</pre>
<p>
The source can also combine multiple signals in an arithmetic expression:

<pre class="ned">
@statistic[dropRate](source=count(drop)/count(pk); record=last,vector?);
</pre>
<p>
When using multiple signals, a value arriving on either signal will result
in one output value. The computation will use the last values of the other
signals (sample-hold interpolation). However, the same signal cannot occur
twice, as it would cause glitches in the output.

<p>Record items can also be expressions and contain filters. For example,
the following statistic is equivalent to one of the previous examples.
It computes and records the total number of bytes dropped, using a
<tt>cPacket*</tt>-valued signal as input. However, some of the computations
have been moved to the recorder part.

<pre class="ned">
@statistic[droppedBytes](source=packetBits(pkdrop); record=last(8*sum),
vector(8*sum)?);
</pre>
<p>

<p><h4><a name="sec:simple-modules:declared-statistics:property-keys"/>4.15.2.2 <a href="../api/classomnetpp_1_1nedxml_1_1MsgTypeTable_1_1Property.html">Property</a> Keys<a class="headerlink" href="#sec:simple-modules:declared-statistics:property-keys" title="Permalink to this headline">¶</a></h4>

<p>The following keys are understood in <b><tt>@statistic</tt></b> properties:

<p><ul class="dl">
  <li><b>source</b> : Defines the input for the recorders (see the <tt>record=</tt> key).
     If omitted, the statistic name is taken as the signal name.
  <li><b>record</b> : Contains a list of recording modes, separated by commas.
     Recording modes define how to record the source (see the <tt>source=</tt> key).
  <li><b>title</b> : A longer, descriptive name for the statistic signal. Result
      visualization tools may use it as the chart label (e.g., in the legend).
  <li><b>unit</b> : The unit of measurement for the values. This may also appear in charts.
  <li><b>interpolationmode</b> : Defines how to interpolate signal values where
      needed (e.g., for drawing). Possible values are <tt>none</tt>,
      <tt>sample-hold</tt>, <tt>backward-sample-hold</tt>, <tt>linear</tt>.
  <li><b>enum</b> : Defines symbolic names for various integer signal values.
      The property value must be a string containing <i>name=value</i> pairs
      separated by commas. For example: <tt>"IDLE=1,BUSY=2,DOWN=3"</tt>.
</ul>

<p>
<h4><a name="sec:simple-modules:available-result-filters-and-recorders"/>4.15.2.3 Available Filters and Recorders<a class="headerlink" href="#sec:simple-modules:available-result-filters-and-recorders" title="Permalink to this headline">¶</a></h4>

<p>The following table contains a list of predefined result filters.
All filters in the table output a value for each input value.

<p><table border>
<TR> <TD align=left>
  
<p>  <b>Filter</b> </TD> <TD align=left> <b>Description</b> </TD></TR>
<TR> <TD align=left>   <tt>count</tt> </TD> <TD align=left> Computes and outputs the count of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>sum</tt> </TD> <TD align=left> Computes and outputs the sum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>min</tt> </TD> <TD align=left> Computes and outputs the minimum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>max</tt> </TD> <TD align=left> Computes and outputs the maximum of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>mean</tt> </TD> <TD align=left> Computes and outputs the average (sum / count) of values received so far. </TD></TR>
<TR> <TD align=left>   <tt>timeavg</tt> </TD> <TD align=left> Regards the input values and their timestamps as a step function (sample-hold style), and
                  computes and outputs their time average (integral divided by duration). </TD></TR>
<TR> <TD align=left>   <tt>constant0</tt> </TD> <TD align=left> Outputs a constant 0 for each received value (independent of the value). </TD></TR>
<TR> <TD align=left>   <tt>constant1</tt> </TD> <TD align=left> Outputs a constant 1 for each received value (independent of the value). </TD></TR>
<TR> <TD align=left>   <tt>packetBits</tt> </TD> <TD align=left> Expects <tt>cPacket</tt> pointers as values and outputs the bit length
                     for each received one. Non-<tt>cPacket</tt> values are ignored. </TD></TR>
<TR> <TD align=left>   <tt>packetBytes</tt> </TD> <TD align=left> Expects <tt>cPacket</tt> pointers as values and outputs the byte length
                      for each received one. Non-<tt>cPacket</tt> values are ignored. </TD></TR>
<TR> <TD align=left>   <tt>sumPerDuration</tt> </TD> <TD align=left> For each value, computes the sum of values received so far,
                         divides it by the duration, and outputs the result. </TD></TR>
<TR> <TD align=left>   <tt>removeRepeats</tt> </TD> <TD align=left> Removes repeated values, i.e., discards values that are the same as the previous one. </TD></TR>
</table>

<p>The list of predefined result recorders:

<p><table border>
<TR> <TD align=left>
  
<p>  <b>Recorder</b> </TD> <TD align=left> <b>Description</b> </TD></TR>
<TR> <TD align=left>   <tt>last</tt> </TD> <TD align=left> Records the last value into an output scalar. </TD></TR>
<TR> <TD align=left>   <tt>count</tt> </TD> <TD align=left> Records the count of the input values into an output scalar;
                functionally equivalent to <tt>last(count)</tt>. </TD></TR>
<TR> <TD align=left>   <tt>sum</tt> </TD> <TD align=left> Records the sum of the input values into an output scalar
              (or zero if there were none);
              functionally equivalent to <tt>last(sum)</tt>. </TD></TR>
<TR> <TD align=left>   <tt>min</tt> </TD> <TD align=left> Records the minimum of the input values into an output scalar
              (or positive infinity if there were none);
              functionally equivalent to <tt>last(min)</tt>. </TD></TR>
<TR> <TD align=left>   <tt>max</tt> </TD> <TD align=left> Records the maximum of the input values into an output scalar
              (or negative infinity if there were none);
              functionally equivalent to <tt>last(max)</tt>. </TD></TR>
<TR> <TD align=left>   <tt>mean</tt> </TD> <TD align=left> Records the mean of the input values into an output scalar
               (or NaN if there were none);
               functionally equivalent to <tt>last(mean)</tt>. </TD></TR>
<TR> <TD align=left>   <tt>timeavg</tt> </TD> <TD align=left> Regards the input values with their timestamps as a step
               function (sample-hold style), and records the time average of the
               input values into an output scalar;
               functionally equivalent to <tt>last(timeavg)</tt>. </TD></TR>
<TR> <TD align=left>   <tt>stats</tt> </TD> <TD align=left> Computes basic statistics (count, mean, std.dev, min, max) from the input values,
                and records them into the output scalar file as a statistic object. </TD></TR>
<TR> <TD align=left>   <tt>histogram</tt> </TD> <TD align=left> Computes a histogram and basic statistics (count, mean, std.dev, min, max)
                from the input values, and records the result into the output scalar file
                as a histogram object. </TD></TR>
<TR> <TD align=left>   <tt>vector</tt> </TD> <TD align=left> Records the input values with their timestamps into an output vector. </TD></TR>
</table>

<p><ul class="note"><b>NOTE</b><br>
You can print the list of available result filters and result recorders
by executing the <tt>opp_run -h resultfilters</tt> and <tt>opp_run
-h resultrecorders</tt> commands.
</ul>

<p>
<h4><a name="sec:simple-modules:naming-and-attributes-of-recorded-results"/>4.15.2.4 Naming and Attributes of Recorded Results<a class="headerlink" href="#sec:simple-modules:naming-and-attributes-of-recorded-results" title="Permalink to this headline">¶</a></h4>

<p>The names of recorded result items are formed by concatenating the
statistic name and the recording mode with a colon between them:
<tt>"<i>&lt;statisticName&gt;</i>:<i>&lt;recordingMode&gt;</i>"</tt>.

<p>Thus, the following statistics

<pre class="ned">
@statistic[dropRate](source=count(drop)/count(pk); record=last,vector?);
@statistic[droppedBytes](source=packetBytes(pkdrop); record=sum,vector(sum)?);
</pre>
<p>
will produce the following scalars: <tt>dropRate:last</tt>, <tt>droppedBytes:sum</tt>,
and the following vectors: <tt>dropRate:vector</tt>, <tt>droppedBytes:vector(sum)</tt>.

<p>All property keys (except for <tt>record</tt>) are recorded as result
attributes into the vector file or scalar file. The <tt>title</tt> property
will be modified slightly before recording, by adding the recording mode
after a comma. Otherwise, all result items saved from the same statistic
would have exactly the same name. Examples: <tt>"Dropped Bytes, sum"</tt>,
<tt>"Dropped Bytes, vector(sum)"</tt>.

<p>It is allowed to use other property keys as well, but they won't be
interpreted by the OMNeT++ runtime or the result analysis tool.

<p>
<h4><a name="sec:simple-modules:statistic-source-and-record-details"/>4.15.2.5 Source and Record Expressions in Detail<a class="headerlink" href="#sec:simple-modules:statistic-source-and-record-details" title="Permalink to this headline">¶</a></h4>

<p>To fully understand <tt>source</tt> and <tt>record</tt>, it is useful
to see how result recording is set up.

<p>When a module or channel is created in the simulation, the OMNeT++ runtime
checks the <tt>@statistic</tt> properties on its NED declaration and adds
listeners to the signals mentioned as input. There are two types of
listeners associated with result recording: <i>result filters</i> and
<i>result recorders</i>. Result filters can be chained, and at the end of
the chain, there is always a recorder. So, there may be a recorder directly
subscribed to a signal, or there may be a chain of one or more filters plus
a recorder. You can think of it as a pipeline or a &#8220;pipe tree&#8221;, where the
tree roots are signals, the leaves are result recorders, and the intermediate
nodes are result filters.

<p>Result filters typically perform some processing on the values they receive
on their inputs (from the previous filter in the chain or directly from the signal)
and propagate them to their outputs (to chained filters and recorders). A
filter may also discard values (i.e., not propagate them). Recorders may write
the received values into an output vector or record output scalar(s) at the end
of the simulation.

<p>Many operations exist in both filter and recorder form. For example, the
<tt>sum</tt> filter passes on the sum of the values received on its input to
its output, while the <tt>sum</tt> recorder computes the sum of the received values
to record it as an output scalar on simulation completion.

<p>The next figure illustrates which filters and recorders are created and how
they are connected for the following statistics:

<pre class="ned">
@statistic[droppedBits](source=8*packetBytes(pkdrop); record=sum,vector(sum));
</pre>
<p>

<p>  <center>
    <img src="statisticrecording.svg">
    <center><div class="caption"><i>Figure: Result filters and recorders chained</i></div></center>
  </center>

<p>
<ul class="hint"><b>HINT</b><br>
To see how result filters and recorders are set up for a particular
simulation, run the simulation with the <b><tt>debug-statistics-recording</tt></b>
configuration option. For example, specify <tt>--debug-statistics-recording=true</tt>
on the command line.
</ul>

<p>
<h3><a name="sec:simple-modules:demux-filter"/>4.15.3 Demultiplexing Results with the Demux Filter<a class="headerlink" href="#sec:simple-modules:demux-filter" title="Permalink to this headline">¶</a></h3>

<p>The <tt>demux</tt> result filter in OMNeT++ provides a mechanism for
recording a breakdown of simulation results based on runtime attributes. It
facilitates the separation of results into multiple streams or categories,
leveraging the properties of emitted signals. This is particularly
advantageous in scenarios with multiple interacting entities or modules.

<p>The <tt>demux</tt> filter works by demultiplexing its input into several
outputs, dynamically creating new outputs as required. The filter uses the name
string of the <tt>details</tt> object associated with the emitted signal as the
selector for this demultiplexing process. This capability enables dynamic
categorization of statistics based on runtime conditions, such as signal
sources.

<p>Let's consider a practical example. Suppose we have a network simulation
where a sink module receives packets from multiple senders. We'd like to
separately record the total number of bytes received from each sender.

<p>First, we define a sink module in NED, which is equipped with a signal and
a statistic that uses the <tt>demux</tt> filter:

<pre class="ned">
simple Sink {
    @signal[packetReceived];
    @statistic[bytesReceivedPerSender](source=packetReceived;record=sum(demux));
}
</pre>
<p>
Next, we implement the sink module to emit a signal each time it receives a packet,
tagging the emission with the sender's name:

<pre class="cpp">
class Sink : public cSimpleModule {
  protected:
    virtual void handleMessage(cMessage *msg) override {
        if (msg-&gt;isPacket()) {
            cPacket *pkt = check_and_cast&lt;cPacket *&gt;(msg);
            static simsignal_t packetReceivedSignal = registerSignal("packetReceived");
            const char *senderName = pkt-&gt;getSendingModule()-&gt;getFullName();

            cNamedObject senderDetails(senderName);
            emit(packetReceivedSignal, pkt-&gt;getByteLength(), &senderDetails);

            delete msg;
        }
    }
};
</pre>
<p>
With the <tt>demux</tt> filter, the generated statistic names will include
the demux label (i.e., the sender's name), resulting in statistic names such as:

<p><ul>
    <li> <tt>bytesReceivedPerSender:Sender1:sum</tt>
    <li> <tt>bytesReceivedPerSender:Sender2:sum</tt>
    <li> ...
</ul>

<p>Each statistic records the sum of the bytes received from its corresponding sender,
providing a detailed breakdown of the data volume by source.

<p>
<h3><a name="sec:simple-modules:statistic-recording-dynamic-signals"/>4.15.4 Statistics Recording for Dynamically Registered Signals<a class="headerlink" href="#sec:simple-modules:statistic-recording-dynamic-signals" title="Permalink to this headline">¶</a></h3>

<p>It is often convenient to have a module record statistics per session, per
connection, per client, etc. One way to handle this is by registering
signals dynamically (e.g., <tt>session1-jitter</tt>, <tt>session2-jitter</tt>, ...),
and setting up <b><tt>@statistic</tt></b>-style result recording for each.

<p>The NED file would look like this:

<pre class="ned">
@signal[session*-jitter](type=simtime_t); // note the wildcard
@statisticTemplate[sessionJitter](record=mean,vector?);
</pre>
<p>
In the C++ code of the module, you need to register each new signal with
<tt>registerSignal()</tt> and, in addition, inform OMNeT++ to set up statistics
recording for it as described by the <b><tt>@statisticTemplate</tt></b> property.
This can be done by calling <tt>getEnvir()-&gt;addResultRecorders()</tt>.

<pre class="cpp">
char signalName[32];
sprintf(signalName, "session%d-jitter", sessionNum);
simsignal_t signal = registerSignal(signalName);

char statisticName[32];
sprintf(statisticName, "session%d-jitter", sessionNum);
cProperty *statisticTemplate =
    getProperties()-&gt;get("statisticTemplate", "sessionJitter");
getEnvir()-&gt;addResultRecorders(this, signal, statisticName, statisticTemplate);
</pre>
<p>
In the <b><tt>@statisticTemplate</tt></b> property, the <tt>source</tt> key will be
ignored (as the parameter signal will be used as the source). The actual
name and index of the property will also be ignored. (In the case of <b><tt>@statistic</tt></b>,
the index holds the result name, but here the name is explicitly specified
in the <tt>statisticName</tt> parameter.)

<p>When recording multiple signals using a common <b><tt>@statisticTemplate</tt></b>,
you may want the titles of the recorded statistics to differ for each signal.
This can be achieved by using dollar variables in the <tt>title</tt> key of the
<b><tt>@statisticTemplate</tt></b>. The following variables are available:

<p><ul>
  <li> <tt>$name</tt>: name of the statistic
  <li> <tt>$component</tt>: component's full path
  <li> <tt>$mode</tt>: recording mode
  <li> <tt>$namePart[0-9]+</tt>: the given part of the statistic name when split
    along colons (:); numbering starts with 1
</ul>

<p>For example, if the statistic name is <tt>"conn:host1-to-host4(3):bytesSent"</tt>,
and the title is <tt>"bytes sent in connection $namePart2"</tt>, it will become
<tt>"bytes sent in connection host1-to-host4(3)"</tt>.

<p>
<h3><a name="sec:simple-modules:statistic-recording-programmatically"/>4.15.5 Adding Result Filters and Recorders Programmatically<a class="headerlink" href="#sec:simple-modules:statistic-recording-programmatically" title="Permalink to this headline">¶</a></h3>

<p>As an alternative to using <b><tt>@statisticTemplate</tt></b> and <tt>addResultRecorders()</tt>,
it is possible to set up result recording programmatically by creating and
attaching result filters and recorders to the desired signals.

<p><ul class="note"><b>NOTE</b><br>
It is important to know that <tt>@statistic</tt> implements warm-up period
support by including a special <i>warm-up period filter</i> at the
front of the filter/recorder chain. When adding result filters and recorders
manually, you need to add this filter manually as well.
</ul>

<p>The following code example sets up recording to an output vector after
removing duplicate values. It is essentially equivalent to the following
<tt>@statistic</tt> line:

<pre class="ned">
@statistic[queueLength](source=qlen; record=vector(removeRepeats);
                        title="Queue Length"; unit=packets);
</pre>
<p>
The C++ code:

<pre class="cpp">
simsignal_t signal = registerSignal("qlen");

cResultFilter *warmupFilter =
        cResultFilterType::get("warmup")-&gt;create();
cResultFilter *removeRepeatsFilter =
        cResultFilterType::get("removeRepeats")-&gt;create();
cResultRecorder *vectorRecorder =
        cResultRecorderType::get("vector")-&gt;create();
opp_string_map *attrs = new opp_string_map;
(*attrs)["title"] = "Queue Length";
(*attrs)["unit"] = "packets";
cResultRecorder::Context ctx { this, "queueLength", "vector",
                               nullptr, attrs};
vectorRecorder-&gt;init(&ctx);

subscribe(signal, warmupFilter);
warmupFilter-&gt;addDelegate(removeRepeatsFilter);
removeRepeatsFilter-&gt;addDelegate(vectorRecorder);
</pre>
<p>

<p><h3><a name="sec:simple-modules:emitting-statistic-signals"/>4.15.6 Emitting Signals<a class="headerlink" href="#sec:simple-modules:emitting-statistic-signals" title="Permalink to this headline">¶</a></h3>

<p>Emitting signals for statistical purposes is not much different from
emitting signals for any other purpose. Statistic signals are primarily
expected to contain numeric values, so the overloaded <tt>emit()</tt> functions
that take <tt>long</tt>, <tt>double</tt>, and <tt>simtime_t</tt> are typically used.

<p><b>Emitting with a timestamp.</b> By default, the emitted values are associated with
the current simulation time. However, there might be cases where you want
to associate the values with a different timestamp. For example, you may want
to associate values with past timestamps, as is done with the <tt>recordWithTimestamp()</tt>
method of <tt>cOutVector</tt> (see <a href="chap7.html#sec:sim-lib:coutvector">[7.10.1]</a>). This situation
can arise when, for example, you want to emit a value with a timestamp that reflects the
start of an event, even though the event's outcome (the value) can only be
known after the event has completed.

<p>To emit a value with a different timestamp, you need to construct an object
that contains a <i>(timestamp, value)</i> pair, and use the <tt>emit(simsignal_t, cObject*)</tt>
method to emit it. The <tt>cTimestampedValue</tt> class provides this functionality,
with two public data members: <tt>time</tt> (of type <tt>simtime_t</tt>) and
<tt>value</tt> (of type <tt>double</tt>). It also has a convenience constructor that
takes these two values.

<p><ul class="note"><b>NOTE</b><br>
<tt>cTimestampedValue</tt> is not part of the signal mechanism per se. However,
the result recording listeners provided by OMNeT++ are designed to understand
<tt>cTimestampedValue</tt> and know how to handle it.
</ul>

<p>Here is an example usage:

<pre class="cpp">
simtime_t frameReceptionStartTime = ...;
double receivePower = ...;
cTimestampedValue tmp(frameReceptionStartTime, receivePower);
emit(recvPowerSignal, &tmp);
</pre>
<p>
If performance is critical, you can make the <tt>cTimestampedValue</tt> object a
class member or a static variable to eliminate the construction/destruction
time.<br><ul><font size=-1>[It is safe to use a static variable here because the simulation
program is single-threaded. However, ensure that there isn't a listener
somewhere that would modify the same static variable during the firing process.]</font></ul>

<p>Timestamps must be monotonically increasing.

<p><b>Emitting non-numeric values.</b> Sometimes, it is practical to have
multi-purpose signals or retrofit an existing non-statistical signal so that it
can be recorded as a result. For this reason, signals with non-numeric types
(i.e., <tt>const char *</tt> and <tt>cObject *</tt>) may also be recorded as results.
The built-in result recording listeners follow these rules when interpreting
non-numeric values:

<p><ul>
  <li> Strings are recorded as 1.0.
  <li> Objects that can be cast to <tt>cITimestampedValue</tt> are recorded
     using the <tt>getSignalTime()</tt> and <tt>getSignalValue()</tt> methods of the class.
  <li> Other objects are recorded as 1.0, except for <tt>nullptr</tt>, which is recorded as 0.0.
</ul>

<p><tt>cITimestampedValue</tt> is a C++ interface that can be used as an additional
base class for any class. It is declared as follows:

<pre class="cpp">
class cITimestampedValue {
    public:
        virtual ~cITimestampedValue() {}
        virtual double getSignalValue(simsignal_t signalID) = 0;
        virtual simtime_t getSignalTime(simsignal_t signalID);
};
</pre>
<p>
The <tt>getSignalValue()</tt> function is pure virtual (i.e., it must return some value),
but the <tt>getSignalTime()</tt> function has a default implementation that
returns the current simulation time. Note that the <tt>signalID</tt> argument
allows the same class to serve multiple signals (i.e., to return different values for each).

<p><h3><a name="sec:simple-modules:writing-result-filters"/>4.15.7 Writing Result Filters and Recorders<a class="headerlink" href="#sec:simple-modules:writing-result-filters" title="Permalink to this headline">¶</a></h3>

<p>You can define your own result filters and recorders in addition to the
built-in ones. To do this, you need to write the implementation in C++ and
register it with a macro to let OMNeT++ know about it. The new result filter
or recorder can then be used in the <tt>source=</tt> and <tt>record=</tt> attributes
of <b><tt>@statistic</tt></b> properties, just like the built-in ones.

<p>Result filters must be subclassed from <tt>cResultFilter</tt> or one
of its more specific subclasses (<tt>cNumericResultFilter</tt> and
<tt>cObjectResultFilter</tt>). The new result filter class needs to be
registered using the <tt>Register_ResultFilter(NAME, CLASSNAME)</tt> macro.

<p>Similarly, a result recorder must be subclassed from <tt>cResultRecorder</tt> or
the more specific <tt>cNumericResultRecorder</tt> class, and be registered
using the <tt>Register_ResultRecorder(NAME, CLASSNAME)</tt> macro.

<p>
  <center>
    <img src="resultlistener-inheritance.svg">
    <center><div class="caption"><i>Figure: Inheritance of result filter and recorder classes</i></div></center>
  </center>

<p>
Here is an example implementation of a result filter taken from the simulation runtime:

<p>
<pre class="cpp">
/**
 * Filter that outputs the sum of signal values divided by the measurement
 * interval (simtime minus warmup period).
 */
class SumPerDurationFilter : public cNumericResultFilter
{
    protected:
        double sum;
    protected:
        virtual bool process(simtime_t& t, double& value, cObject *details);
    public:
        SumPerDurationFilter() {sum = 0;}
};

Register_ResultFilter("sumPerDuration", SumPerDurationFilter);

bool SumPerDurationFilter::process(simtime_t& t, double& value, cObject *)
{
    sum += value;
    value = sum / (simTime() - getSimulation()-&gt;getWarmupPeriod());
    return true;
}
</pre>

<p>


<hr class='pgbr'><p><hr><b><a href="chap3.html">[Prev]</A>&nbsp;<a href="chap5.html">[Next]</A>&nbsp;<a href="toc.html#toc_4.">[TOC]</a>&nbsp;<a href="usman.html">[Chapters]</a></b><hr></p>

</body>
</html>
