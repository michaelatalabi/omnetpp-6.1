<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <meta name="copyright" content="OpenSim Ltd.">
  <meta NAME="Author" CONTENT="Andras Varga">
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="STYLESHEET" href="../book.css"  type="text/css">
  <title>OMNeT++ - Simulation Manual</title>
</head>
<style type="text/css">
  hr.pgbr { color: #f5f5f5; margin-top: 40px; margin-bottom: 10px; }
  ul.dl { padding-left: 30px; text-indent: -30px; list-style: none; }
  pre { margin: 4px 8px 4px 2px; padding: 8px 10px; background:#fffff4; border: 1px solid #dddddd; }
  pre.ned { background:#f5fff5; border-left: 4px solid #ccffcc; }
  pre.msg { background:#f5fff5; border-left: 4px solid #ccffcc; }
  pre.cpp { background:#f5f5f5; border-left: 4px solid #ccccff; }
  pre.inifile { background:#fffff0; border-left: 4px solid #e5e533; }
  pre.filelisting { background:#f0f0f0; border-left: 4px solid #d9d9d9; }
  pre.xml { background:#fff0f0; border-left: 4px solid #ffa0a0; }
  pre.commandline { background:#fffff0; border-left: 4px solid #606060; }
  td,th { text-align:left; vertical-align:top; border:1px solid; padding:3pt; border-color:#000000; }
  div.caption { margin-top: 10px; }
  a[href] { color: #202080; text-decoration: none; }
  a:visited { text-decoration: none; }
  # a:hover { text-decoration: underline; }

  table.matrix { display:inline-block; vertical-align: middle; position: relative; border: 0px; background:#ffffff; margin-left:8pt; margin-right:8pt; }
  table.matrix:before, table.matrix:after { content: ""; position: absolute; top: 0; border: 1px solid #000; width: 6px; height: 100%; }
  table.matrix:before { left: -6px; border-right: 0px; }
  table.matrix:after { right: -6px; border-left: 0px; }
  table.matrix td { padding: 5px; text-align: center; border: 0px; }

  a.headerlink { visibility: hidden; }
</style>
<body>

<p><hr><b><a href="chap7.html">[Prev]</A>&nbsp;<a href="chap9.html">[Next]</A>&nbsp;<a href="toc.html#toc_8.">[TOC]</a>&nbsp;<a href="usman.html">[Chapters]</a></b><hr></p><h1><a name="cha:graphics"/>8 Graphics and Visualization<a class="headerlink" href="#cha:graphics" title="Permalink to this headline">¶</a></h1>

<p><h2><a name="sec:graphics:overview"/>8.1 Overview<a class="headerlink" href="#sec:graphics:overview" title="Permalink to this headline">¶</a></h2>

<p>OMNeT++ simulations can be run under graphical user interfaces like Qtenv
that offer visualization and animation, along with interactive
execution and other features. This chapter deals with model visualization.

<p>OMNeT++ essentially provides four main tools for defining and enhancing
model visualization:

<p><ol>

<p>    <li> <i>Display strings</i> are the traditional way. They are
    per-component strings that encode how the component (module or channel)
    will appear in the graphical user interface. Display strings can be
    specified in NED files and can also be manipulated programmatically at
    runtime.

<p>    <li> <i>The canvas.</i> The same user interface area that contains
    submodules and connections (i.e. the <i>canvas</i>) can also display
    additional graphical elements that OMNeT++ calls <i>figures</i>. Using
    figures, one can display lines, curves, polygons, images, and text items,
    as well as anything that can be created by combining them and applying effects like
    rotation and scaling. Like display strings, figures can also be specified
    in NED files, but it is generally more useful to create and manipulate them
    programmatically. Every module has its own default canvas, and extra canvases
    can also be created at runtime.

<p>    <li> <i>3D visualization</i> of the simulation's virtual world is a
    third possibility. OMNeT++'s 3D visualization capabilities come from the
    open-source OpenSceneGraph library and its osgEarth extension. These
    libraries build on top of OpenGL, and beyond basic graphics functionality,
    they also offer high-level capabilities, such as reading 3D model files
    directly from disk or displaying maps, 3D terrain, or Earth as a planet
    using online map and satellite imagery data sources.

<p>    <li> <i>Support for smooth custom animation</i> allows models to visualize
    their operation using sophisticated animations. The key idea is that the
    simulation model is called back from the runtime GUI (Qtenv) repeatedly
    at a reasonable &#8220;frame rate,&#8221; allowing it to continually update the
    canvas (2D) and/or the 3D scene to produce fluid animations.

<p></ol>

<p>The following sections will cover the above topics in more detail. But first,
let us get acquainted with a new <tt>cModule</tt> virtual method that one
can redefine and place visualization-related code into.

<p>
<h2><a name="sec:graphics:refreshdisplay"/>8.2 Placement of Visualization Code<a class="headerlink" href="#sec:graphics:refreshdisplay" title="Permalink to this headline">¶</a></h2>

<p>Traditionally, when C++ code was needed to enhance visualization, such as
updating a displayed status label or refreshing the position of a mobile node,
it was embedded in the <tt>handleMessage()</tt> function, enclosed in <tt>if
(ev.isGUI())</tt> blocks. This approach was less than ideal because the
visualization code would run for all events in that module, not just before
display updates when it was actually needed. In <i>Express</i> mode, for
example, Qtenv would only refresh the display once every second or so, with a
large number of events processed between updates. Therefore, visualization code
placed inside <tt>handleMessage()</tt> could potentially waste a significant
amount of CPU cycles. Additionally, visualization code embedded in
<tt>handleMessage()</tt> is not suitable for creating smooth animations.

<p>
<h3><a name="sec:graphics:refreshdisplay-usage-and-semantics"/>8.2.1 The refreshDisplay() Method<a class="headerlink" href="#sec:graphics:refreshdisplay-usage-and-semantics" title="Permalink to this headline">¶</a></h3>

<p>Starting from OMNeT++ version 5.0, visualization code can be placed into a
dedicated method called <tt>refreshDisplay()</tt>. Using this method is more
efficient than embedding visualization code into <tt>handleMessage()</tt>,
because <tt>refreshTheDisplay()</tt> is called only as often as necessary
by the graphical user interface to keep the display up to date.

<p><tt>refreshDisplay()</tt> is declared on <tt>cModule</tt> as:

<pre class="cpp">
virtual void refreshDisplay() const {}
</pre>
<p>
Components that contain visualization-related code are expected to override
<tt>refreshDisplay()</tt> and move visualization code, such as display string
manipulation, canvas figure maintenance, and OSG scene graph updates, into it.

<p>When and how is <tt>refreshDisplay()</tt> invoked? Generally, it is invoked right
before the GUI performs a display update. With some additional rules, this boils
down to the following:

<p><ol>
<li> It is invoked only under graphical user interfaces, currently Qtenv.
     It is never invoked under Cmdenv.

<p><li> When invoked, it will be called on <i>all</i> components of the
      simulation. It does not matter if a module has a graphical inspector
      open or not. This design decision simplifies the handling
      of cross-module visualization dependencies. Runtime overhead is
      still not an issue, because display updates are only done at most
      a few times per second in <i>Express</i> mode. In other modes,
      raw event processing performance is of somewhat lesser importance.
      <br><ul><font size=-1>[At any rate, only a small portion of components are expected to
      have (nontrivial) <tt>refreshDisplay()</tt> overrides in complex models.
      If it still becomes too resource-consuming, local caching of related
      data and the use of a <i>displayInvalid</i> flag might help.]</font></ul>

<p><li> It is invoked right before display updates. This includes the following:
      after network setup; in <i>Step</i> and <i>Run</i> modes, before and
      after every event; in <i>Fast</i> and <i>Express</i> modes, after
      every "batch" of events; every time a new graphical inspector is opened,
      zoomed, navigated in, or closed; after model data (cPar, cDisplayString
      values, etc.) is edited, and after finalization.

<p><li> If smooth animation is used, it is invoked continuously with a reasonably
      high frequency in <i>Step</i>, <i>Run</i> and <i>Fast</i> modes.
      This can mean anything from many times between processing two consecutive
      events to not even once until after the processing of a couple of events,
      depending on the current animation speed and event density.

<p></ol>

<p>Here is an example of how one would use it:

<pre class="cpp">
void FooModule::refreshDisplay() const
{
    // refresh statistics
    char buf[80];
    sprintf(buf, "Sent:%d  Rcvd:%d", numSent, numReceived);
    getDisplayString()-&gt;setTagArg("t", 0, buf);

    // update the mobile node's position
    Point pos = ...  // e.g. invoke a computePosition() method
    getDisplayString()-&gt;setTagArg("p", 0, pos.x);
    getDisplayString()-&gt;setTagArg("p", 1, pos.y);
}
</pre>
<p>
One useful accessory to <tt>refreshDisplay()</tt> is the <tt>isExpressMode()</tt>
method of <tt>cEnvir</tt>. It returns true if the simulation is running under a
GUI in <i>Express</i> mode. Visualization code may check this flag and adapt
the visualization accordingly. For example:

<pre class="cpp">
if (getEnvir()-&gt;isExpressMode()) {
    // display throughput statistics
}
else {
    // visualize current frame transmission
}
</pre>
<p>

<p><h3><a name="sec:graphics:refreshdisplay-advantages"/>8.2.2 Advantages<a class="headerlink" href="#sec:graphics:refreshdisplay-advantages" title="Permalink to this headline">¶</a></h3>

<p>Overriding <tt>refreshDisplay()</tt> has several advantages over putting the
simulation code into <tt>handleMessage()</tt>. The first one is clearly
<i>performance</i>. When running under Cmdenv, the runtime cost of
visualization code is literally zero. When running in <i>Express</i> mode
under Qtenv, it is practically zero because the cost of one update is amortized
over several hundred thousand or million events.

<p>The second advantage is also very practical: <i>consistency</i> of the
visualization. If the simulation has cross-module dependencies such that an
event processed by one module affects the information displayed by another
module, with <tt>handleMessage()</tt>-based visualization, the model may have
inconsistent visualization until the second module also processes an event and
updates its displayed state. With <tt>refreshDisplay()</tt>, this does not happen
because all modules are refreshed together.

<p>The third advantage is <i>separation of concerns</i>. It is generally not a
good idea to intermix simulation logic with visualization code, and
<tt>refreshDisplay()</tt> allows one to completely separate the two.

<p><h3><a name="sec:graphics:refreshdisplay-constness"/>8.2.3 Why is <tt>refreshDisplay()</tt> const?<a class="headerlink" href="#sec:graphics:refreshdisplay-constness" title="Permalink to this headline">¶</a></h3>

<p>Code in <tt>refreshDisplay()</tt> should never alter the state of the simulation
because that would destroy repeatability due to the fact that the timing and
frequency of <tt>refreshDisplay()</tt> calls are completely unpredictable from
the simulation model's point of view. The fact that the method is declared
<tt>const</tt> gently encourages this behavior.

<p>If visualization code makes use of internal caches or maintains some other
mutable state, such data members can be declared <tt>mutable</tt> to allow
<tt>refreshDisplay()</tt> to change them.

<p>
<h2><a name="sec:graphics:smooth-animation"/>8.3 Smooth Animation<a class="headerlink" href="#sec:graphics:smooth-animation" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:graphics:animation-concepts"/>8.3.1 Concepts<a class="headerlink" href="#sec:graphics:animation-concepts" title="Permalink to this headline">¶</a></h3>

<p>Support for smooth custom animation enables models to visualize their operation
using sophisticated animations. The key idea is that the simulation model
is called back from the runtime GUI (Qtenv) repeatedly at a reasonable
&#8220;frame rate,&#8221; allowing it to continually update the canvas (2D) and/or the
3D scene to produce fluid animations. Callback means that the
<tt>refreshDisplay()</tt> methods of modules and figures are invoked.

<p><tt>refreshDisplay()</tt> knows the animation position from the simulation time
and the <i>animation time</i>, a variable also made accessible to the model.
If you think about the animation as a movie, animation time is simply the
position in seconds in the movie. By default, the movie is played in Qtenv at normal (1x)
speed, and then animation time is simply the number of seconds since the
start of the movie. The speed control slider in Qtenv's toolbar allows
you to play it at higher (2x, 10x, etc.) and lower (0.5x, 0.1x, etc.)
speeds; so if you play the movie at 2x speed, animation time will
pass twice as fast as real time.

<p>When smooth animation is turned on (more about that later), simulation
time progresses in the model (piecewise) linearly. The speed at which the simulation
progresses in the movie is called <i>animation speed</i>. Sticking to the
movie analogy, when the simulation progresses in the movie 100 times
faster than animation time, animation speed is 100.

<p>Certain actions take zero simulation time, but we still want to animate
them. Examples of such actions are the sending of a message over a zero-delay link,
or a visualized C++ method call between two modules. When these animations play
out, simulation is paused and simulation time stays constant
until the animation is over. Such periods are called <i>holds</i>.

<p><h3><a name="sec:graphics:animation-modes"/>8.3.2 Smooth vs. Traditional Animation<a class="headerlink" href="#sec:graphics:animation-modes" title="Permalink to this headline">¶</a></h3>

<p>Smooth animation is a relatively new feature in OMNeT++, and not all simulations
need it. Smooth and traditonal, &#8220;non-smooth&#8221; animation in Qtenv are
two distinct modes which operate very differently:

<p><ul>
  <li> In <b>Traditional animation</b>, simulation events are essentially
    processed <i>as fast as possible</i>, and meanwhile, <tt>refreshDisplay()</tt>
    is called with some policy (e.g. once before/after each event, or at
    1s intervals real-time) to keep the displayed  graphics up to date.
  <li> <b>Smooth animation</b> is essentially a <i>scaled realtime simulation</i>,
    where <tt>refreshDisplay()</tt> is continually called with a reasonably
    high frame rate.
</ul>

<p>The factor that decides which operation mode is active is the <i>presence
of an animation speed</i>. If there is no animation speed, traditional
animation is performed; if there is one, smooth animation is done.

<p>The Qtenv GUI has a dialog (<i>Animation Parameters</i>) which displays
the current animation speed, among other things. This dialog allows the
user to check at any time which operation mode is currently active.<br><ul><font size=-1>[
Note that even during traditional animation, some built-in animation effects
request animation speeds and holds, so there may be periods when smooth animation
is performed.]</font></ul>

<p><h3><a name="sec:graphics:animation-speed"/>8.3.3 The Choice of Animation Speed<a class="headerlink" href="#sec:graphics:animation-speed" title="Permalink to this headline">¶</a></h3>

<p>Different animation speeds may be appropriate for different animation effects.
For example, when animating WiFi traffic where various time slots are on the microsecond scale,
an animation speed on the order of <i>10^-5</i> might be appropriate; when animating the
movement of cars or pedestrians, an animation speed of <i>1</i> is a reasonable choice.
When several animations requiring different animation speeds occur in the same
scene, one solution is to animate the scene using the lowest animation speed
so that even the fastest actions can be visually followed by the human viewer.

<p>The solution provided by OMNeT++ for the above problem is the following.
Animation speed cannot be controlled explicitly, only requests may be submitted.
Several parts of the models may request different animation speeds.
The effective animation speed is computed as the minimum of the animation
speeds of visible canvases, unless the user interactively overrides it in the UI,
for example by imposing a lower or upper limit.

<p>An animation speed request may be submitted using the <tt>setAnimationSpeed()</tt>
method of <tt>cCanvas</tt>.<br><ul><font size=-1>[The class that represents the canvas for
2D graphics, see <a href="chap8.html#sec:graphics:creating-accessing-and-viewing-canvases">[8.6.2]</a> for more
info.]</font></ul> The <tt>setAnimationSpeed()</tt> method takes two arguments:
the animation speed value (a <tt>double</tt>) and an object pointer (<tt>cObject*</tt>)
that identifies the part of the model that requests it. The second, object parameter
is used as a key that allows the request to be updated or withdrawn later.
Typically, the pointer of the module that makes the request (i.e. <tt>this</tt>) is
used for that purpose. Calling <tt>setAnimationSpeed()</tt> with zero animation
speed cancels the request.

<p>An example:

<pre class="cpp">
cCanvas *canvas = getSystemModule()-&gt;getCanvas(); // toplevel canvas
canvas-&gt;setAnimationSpeed(2.0, this); // one request
canvas-&gt;setAnimationSpeed(1e-6, macModule); // another request
...
canvas-&gt;setAnimationSpeed(1.0, this); // overwrite first request
canvas-&gt;setAnimationSpeed(0, macModule); // cancel second request
</pre>
<p>
In practice, built-in animation effects such as message sending animation
also submit their own animation speed requests internally, so they also
affect the effective animation speed chosen by Qtenv.

<p>The current effective animation speed can be obtained from the environment of the
simulation (<tt>cEnvir</tt>, see chapter <a href="chap18.html#cha:embedding">[18]</a> for context):

<pre class="cpp">
double animSpeed = getEnvir()-&gt;getAnimationSpeed();
</pre>
<p>
Animation time can be accessed like this:

<pre class="cpp">
double animTime = getEnvir()-&gt;getAnimationTime();
</pre>
<p>
Animation time starts from zero, and monotonically increases with simulation
time and also during &#8220;holds&#8221;.

<p>
<h3><a name="sec:graphics:animation-hold"/>8.3.4 Holds<a class="headerlink" href="#sec:graphics:animation-hold" title="Permalink to this headline">¶</a></h3>

<p>As mentioned earlier, a hold interval is an interval when only animation
takes place, but simulation time does not progress and no events
are processed. Hold intervals are intended for animating actions
that take zero simulation time.

<p>A hold can be requested with the <tt>holdSimulationFor()</tt> method
of <tt>cCanvas</tt>, which accepts an animation time delta as parameter.
If a hold request is issued when there is one already in progress,
the current hold will be extended as needed to incorporate the
request. A hold request cannot be cancelled or shrunk.

<pre class="cpp">
cCanvas *canvas = getSystemModule()-&gt;getCanvas(); // toplevel canvas
canvas-&gt;holdSimulationFor(0.5); // request a 0.5s (animation time) hold
</pre>
<p>
When rendering frames in <tt>refreshDisplay()</tt> during a hold, the code
can use animation time to determine the position in the animation.
If the code needs to know the animation time elapsed since the start of
the hold, it should query and remember the animation time when issuing
the hold request.

<p>If the code needs to know the animation time remaining until the end
of the hold, it can use the <tt>getRemainingAnimationHoldTime()</tt>
method of <tt>cEnvir</tt>. Note that this is not necessarily the
time remaining from its own hold request, because other parts of the
simulation might extend the hold.

<p>
<h3><a name="sec:graphics:disabling-built-in-anims"/>8.3.5 Disabling Built-In Animations<a class="headerlink" href="#sec:graphics:disabling-built-in-anims" title="Permalink to this headline">¶</a></h3>

<p>If a model implements such full-blown animations for a compound module that
OMNeT++'s default animations (message sending/method call animations) become
a liability, they can be programmatically turned off for that module with
<tt>cModule</tt>'s <tt>setBuiltinAnimationsAllowed()</tt> method:

<pre class="cpp">
// disable animations for the toplevel module
cModule *network = getSimulation()-&gt;getSystemModule();
network-&gt;setBuiltinAnimationsAllowed(false);
</pre>
<p>

<p>
<h2><a name="sec:graphics:display-strings"/>8.4 Display Strings<a class="headerlink" href="#sec:graphics:display-strings" title="Permalink to this headline">¶</a></h2>

<p>Display strings<!--display strings--> are concise textual descriptions that
specify the arrangement and appearance of the graphical representations of
modules and connections in graphical user interfaces (currently Qtenv).

<p>Display strings are usually specified in NED's <b><tt>@display</tt></b> property, but it
is also possible to modify them programmatically at runtime.

<p>Display strings can be used in the following contexts:
<ul>
  <li> <i>submodules</i> -- display strings can contain position, arrangement
    (for module vectors), icon, icon color, auxiliary icon, status text,
    communication range (as a circle or filled circle), tooltip, etc.
  <li> <i>compound modules, networks</i> -- display strings can specify
    background color, border color, border width, background image, scaling, grid,
    and unit of measurement, etc.
  <li> <i>connections</i> -- display strings can specify positioning, color,
    line width, line style, text, and tooltip
  <li> <i>messages</i> -- display strings can specify icon, icon color, etc.
</ul>

<p>
<h3><a name="sec:graphics:displaystring-syntax-and-placement"/>8.4.1 Syntax and Placement<a class="headerlink" href="#sec:graphics:displaystring-syntax-and-placement" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:graphics:dispstr-syntax"/>8.4.1.1 Syntax<a class="headerlink" href="#sec:graphics:dispstr-syntax" title="Permalink to this headline">¶</a></h4>

<p>Display strings are specified in <b><tt>@display</tt></b> properties in NED files. The
property must contain a single string value. The string should consist of a
semicolon-separated list of tags. Each tag consists of a key, an equal sign, and
a comma-separated list of arguments:

<pre class="ned">
@display("p=100,100;b=60,10,rect,blue,black,2")
</pre>
<p>
Tag arguments may be omitted both at the end and inside the parameter list. If
an argument is omitted, a reasonable default value is used. In the following
example, the first and second arguments of the <tt>b</tt> tag are omitted.

<pre class="ned">
@display("p=100,100;b=,,rect,blue")
</pre>
<p>
<h4><a name="sec:graphics:dispstr-placement"/>8.4.1.2 Placement<a class="headerlink" href="#sec:graphics:dispstr-placement" title="Permalink to this headline">¶</a></h4>

<p>Display strings can be placed in the <b><tt>parameters</tt></b> section of module and
channel type definitions, as well as in submodules and connections. The
following NED sample illustrates the placement of display strings in the code:

<pre class="ned">
simple Server
{
    parameters:
        @display("i=device/server");
    ...
}

network Example
{
    parameters:
        @display("bgi=maps/europe");
    submodules:
        server: Server {
            @display("p=273,101");
        }
        ...
    connections:
        client1.out --&gt; { @display("ls=red,3"); } --&gt; server.in++;
}
</pre>
<p>
<h4><a name="sec:graphics:dispstr-quoting"/>8.4.1.3 Quoting<a class="headerlink" href="#sec:graphics:dispstr-quoting" title="Permalink to this headline">¶</a></h4>

<p>Since commas and semicolons are part of the display string syntax, they need to
be escaped in the NED file when they occur as part of a value (e.g., annotation
label or tooltip text). Specifically, to include a comma, semicolon, or equal
sign in a tag value, it should be prefixed with two backslashes:
<tt><br>,</tt>, <tt><br>;</tt>,
<tt><br>=</tt>. To include a literal backslash in a tag
value, it should be written as four backslashes:
<tt>\\\\</tt>. Tab or
newline characters can be included in a tag value by writing them as
<tt>\t</tt> and <tt>\n</tt>, respectively.

<p>The reason for the above rules is that display strings specified in NED files
are string literals, so backslash escape sequences are interpreted by the NED
parser first. It handles tabs, newlines, and literal backslashes and quotation
marks. Double backslashes become single backslashes after this step. Then, the
string value is parsed by the display string parser, which splits the string
into tags and values. In this step, the remaining backslashes that are in front
of commas, semicolons, or equal signs remove their special meanings, a backslash
in front of another backslash generates a single backslash, and the rest of the
backslashes are ignored.

<p>Examples:

<pre class="ned">
  @display("t=Hello\\, world!");  // -&gt; Hello, world!
  @display("t=C:\\\\Windows\\\\Temp"); // -&gt; C:\Windows\Temp
  @display("t=\"Hello\\,\" Martin said."); // -&gt; "Hello," Martin said.
</pre>
<p>
<h4><a name="sec:graphics:dispstr-paramrefs"/>8.4.1.4 Parameter References<a class="headerlink" href="#sec:graphics:dispstr-paramrefs" title="Permalink to this headline">¶</a></h4>

<p>In addition to literal values, display strings may also contain embedded
NED expressions and references to module/channel parameters, made available
with the <tt>${...}</tt> and <tt>$foo</tt> syntaxes, respectively. These features
are described in detail in <a href="chap8.html#sec:graphics:displaystring-parameter-substitution">[8.4.7]</a>
and <a href="chap8.html#sec:graphics:displaystring-embedded-expressions">[8.4.8]</a>.
To add a literal dollar sign to a display string value, double it:

<pre class="ned">
  @display("t=Price: $$50");  // -&gt; Price: $50
</pre>
<p>
Commas and semicolons inside <tt>${...}</tt> do not need to be escaped with a backslash.

<p><h3><a name="sec:graphics:displaystring-inheritance"/>8.4.2 Inheritance<a class="headerlink" href="#sec:graphics:displaystring-inheritance" title="Permalink to this headline">¶</a></h3>

<p>At runtime, every module and channel object has a single display string object
that controls its appearance in various contexts. The initial value of this
display string object comes from merging the <b><tt>@display</tt></b> properties
occurring at various places in NED files. This section describes the rules for
merging <b><tt>@display</tt></b> properties to create the module or channel's display
string.

<p><ul>
  <li> Derived NED types inherit their display string from their base NED type.
  <li> Submodules inherit their display string from their type.
  <li> Connections inherit their display string from their channel type.
</ul>

<p>The base NED type's display string is merged into the current display string
using the following rules:

<p><ol>
  <li> <b>Inheriting.</b> If a tag or tag argument is present in the base
    display string but not in the current one, it will be added to the result.
    Example: <tt>"i=block/sink"</tt> (base) + <tt>"p=20,40;i=,red"</tt> (current)
    <i>--></i> <tt>"p=20,40;i=block/sink,red"</tt>
  <li> <b>Overwriting.</b> If a tag argument is present in both the base and
    current display strings, the tag argument in the current display string will
    take priority. Example: <tt>"b=40,20,oval"</tt> + <tt>"b=,30"</tt> <i>--></i>
    <tt>"b=40,30,oval"</tt>
  <li> <b>Erasing.</b> If the current display string contains a tag argument
    with the value &#8220;-&#8221; (hyphen), that tag argument will be empty in the result.
    Example: <tt>"i=block/sink,red"</tt> + <tt>"i=,-"</tt> <i>--></i>
    <tt>"i=block/sink"</tt>
</ol>

<p>The result of merging the <b><tt>@display</tt></b> properties will be used to
initialize the display string object (<tt>cDisplayString</tt>) of the
module or channel. The display string object can then still be modified
programmatically at runtime.

<p><ul class="note"><b>NOTE</b><br>
If a tag argument is empty, the GUI may use a suitable default value. For
example, if the border color for a rectangle is not specified in the
display string, the GUI may use black. This default value cannot be
queried programmatically.
</ul>

<p>Example of display string inheritance:

<pre class="ned">
simple Base {
    @display("i=block/queue"); // use a queue icon in all instances
}

simple Derived extends Base {
    @display("i=,red,60");  // ==&gt; "i=block/queue,red,60"
}

network SimpleQueue {
    submodules:
        submod: Derived {
            @display("i=,yellow,-;p=273,101;r=70");
                     // ==&gt; "i=block/queue,yellow;p=273,101;r=70"
        }
        ...
}
</pre>
<p>

<p><h3><a name="sec:graphics:submodule-displaystring-tags"/>8.4.3 Submodule Tags<a class="headerlink" href="#sec:graphics:submodule-displaystring-tags" title="Permalink to this headline">¶</a></h3>

<p>The following tags of the module display string are in effect in submodule
context, that is, when the module is displayed as a submodule of another
module:

<p><ul>
  <li> <tt>i</tt> -- icon
  <li> <tt>is</tt> -- icon size
  <li> <tt>i2</tt> -- auxiliary or status icon
  <li> <tt>b</tt> -- shape (box, oval, etc.)
  <li> <tt>p</tt> -- positioning and layout
  <li> <tt>g</tt> -- layout group
  <li> <tt>r</tt> -- range indicator
  <li> <tt>q</tt> -- queue information text
  <li> <tt>t</tt> -- text
  <li> <tt>tt</tt> -- tooltip
</ul>

<p>The following sections provide an overview and examples for each tag. More
detailed information, such as what each tag argument means, is available in
Appendix <a href="chap25.html#cha:display-strings">[25]</a>.

<p><h4><a name="sec:graphics:submodule-icons"/>8.4.3.1 Icons<a class="headerlink" href="#sec:graphics:submodule-icons" title="Permalink to this headline">¶</a></h4>

<p>By default, modules are displayed with a simple default icon, but OMNeT++ comes
with a large set of categorized icons to choose from. To see what icons are
available, look into the <tt>images/</tt> folder in the OMNeT++ installation. The
stock icons installed with OMNeT++ have several size variants. Most of them have
very small (vs), small (s), large (l), and very large (vl) versions.

<p>One can specify the icon with the <tt>i</tt> tag. The icon name should be given
with the name of the subfolder under <tt>images/</tt>, but without the file name
extension. The size may be specified with the icon name suffix (<tt>_s</tt> for
very small, <tt>_vl</tt> for very large, etc.), or in a separate <tt>is</tt> tag.

<p>An example that displays the <i>block/source</i> icon in a large size:

<pre class="ned">
@display("i=block/source;is=l");
</pre>
<p>
Icons can also be colorized, which can often be useful. Color can indicate the
status or grouping of the module, or simply serve aesthetic purposes. The
following example makes the icon 20% red:

<pre class="ned">
@display("i=block/source,red,20");
</pre>
<p>
<center>
<img src="graphics-itag.png">
</center>

<p><h4><a name="sec:graphics:submodule-status-icon"/>8.4.3.2 Status Icon<a class="headerlink" href="#sec:graphics:submodule-status-icon" title="Permalink to this headline">¶</a></h4>

<p>Modules can also display a small auxiliary icon in the top-right corner of the
main icon. This icon can be useful for displaying the status of the module, for
example, and can be set with the <tt>i2</tt> tag. Icons suitable for use with
<tt>i2</tt> are in the <tt>status/</tt> category.

<p>An example:

<pre class="ned">
@display("i=block/queue;i2=status/busy");
</pre>
<p>
<center>
<img src="graphics-i2tag.png">
</center>

<p><h4><a name="sec:graphics:submodule-shapes"/>8.4.3.3 Shapes<a class="headerlink" href="#sec:graphics:submodule-shapes" title="Permalink to this headline">¶</a></h4>

<p>To have a simple but resizable representation for a module, one can use the
<tt>b</tt> tag to create geometric shapes. Currently, <tt>oval</tt> and
<tt>rectangle</tt> are supported.

<p>The following example displays an oval shape with a size of 70x30, a 4-pixel
black border, and red fill:

<pre class="ned">
@display("b=70,30,oval,red,black,4");
</pre>
<p>
<center>
<img src="graphics-btag.png">
</center>

<p><h4><a name="sec:graphics:submodule-positioning"/>8.4.3.4 Positioning<a class="headerlink" href="#sec:graphics:submodule-positioning" title="Permalink to this headline">¶</a></h4>

<p>The <tt>p</tt> tag allows one to define the position of a submodule or otherwise affect its placement.

<p><ul class="note"><b>NOTE</b><br>
If the <tt>p</tt> tag is missing or doesn't specify the position, OMNeT++ will use a
layouting algorithm to automatically place the module. The layouting algorithm
is covered in section <a href="chap8.html#sec:graphics:compound-module-layouting">[8.4.11]</a>.
</ul>

<p>The following example will place the module at the given position:

<pre class="ned">
@display("p=50,79");
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
Coordinates and distances in <tt>p</tt>, <tt>b</tt> or <tt>r</tt> tags need not
be integers. Fractional numbers make sense because runtime GUIs like
Qtenv support zooming.
</ul>

<p>If the submodule is a module vector, one can also specify in the <tt>p</tt>
tag how to arrange the elements of the vector. They can be arranged in a
row, a column, a matrix or a ring. The rest of the arguments in the <tt>p</tt>
tag depend on the layout type:

<p>TODO refine, e.g. list accepted abbreviations for matrix etc; what if x,y are missing; delta args are optional; etc

<p><ul>
  <li> Row: <tt>p=<i>x</i>,<i>y</i>,r,<i>deltaX</i></tt> (A row of modules with <i>deltaX</i> units between the modules)
  <li> Column: <tt>p=<i>x</i>,<i>y</i>,c,<i>deltaY</i></tt> (A column of modules with <i>deltaY</i> units between the modules)
  <li> Matrix: <tt>p=<i>x</i>,<i>y</i>,m,<i>numCols</i>,<i>deltaX</i>,<i>deltaY</i></tt> (A matrix with <i>numCols</i> columns, with
            <i>deltaX</i> and <i>deltaY</i> units between rows and columns)
  <li> Ring <tt>p=<i>x</i>,<i>y</i>,ri,<i>rx</i>,<i>ry</i></tt> (A ring (oval) with <i>rx</i> and <i>ry</i> as the horizontal and vertical radius.)
  <li> Exact (default): <tt>p=<i>x</i>,<i>y</i>,x,<i>deltaX</i>,<i>deltaY</i></tt> (Place each module at <i>(x+deltaX, y+deltaY)</i>.
            The coordinates are often set at runtime.)
</ul>

<p>A matrix layout for a module vector (note that the first two arguments, <i>x</i>
and <i>y</i> are omitted, so the submodule matrix as a whole will be placed by
the layouter algorithm):

<pre class="ned">
host[20]: Host {
    @display("p=,,m,4,50,50");
}
</pre>
<p>

<p>  <center>
    <img src="graphics-ptag.png">
    <center><div class="caption"><i>Figure: Matrix arrangement using the <i>p</i> tag</i></div></center>
    <a name="fig:graphics-ptag"></a>
  </center>

<p>

<p><h4><a name="sec:graphics:submodule-layout-group"/>8.4.3.5 Layout Group<a class="headerlink" href="#sec:graphics:submodule-layout-group" title="Permalink to this headline">¶</a></h4>

<p>Layout groups allow modules that are not part of the same submodule vector to be
arranged in a row, column, matrix, or ring formation as described in the <tt>p</tt>
tag's third (and further) parameters.

<p>The <tt>g</tt> tag expects a single string parameter, the group name. All sibling
modules that share the same group name are treated for layouting purposes as if
they were part of the same submodule vector, with the &#8220;index&#8221; being the order of
submodules within their parent.

<p>
<h4><a name="sec:graphics:submodule-wireless-range"/>8.4.3.6 Wireless Range<a class="headerlink" href="#sec:graphics:submodule-wireless-range" title="Permalink to this headline">¶</a></h4>

<p>In wireless simulations, it is often useful to display a circle or disc around
the module to indicate transmission range, reception range, or interference
range. This can be done with the <tt>r</tt> tag.

<p>In the following example, the module will have a circle with a radius of 90
units as a range indicator:

<pre class="ned">
submodules:
    ap: AccessPoint {
        @display("p=50,79;r=90");
    }
</pre>
<p>

<p>  <center>
    <img src="graphics-rtag.png">
    <center><div class="caption"><i>Figure: Range indicator using the <i>r</i> tag</i></div></center>
    <a name="fig:graphics-rtag"></a>
  </center>

<p>
<h4><a name="sec:graphics:submodule-queue-length"/>8.4.3.7 Queue Length<a class="headerlink" href="#sec:graphics:submodule-queue-length" title="Permalink to this headline">¶</a></h4>

<p>If a module contains a queue object (<tt>cQueue</tt>), it is possible to display
the queue length next to the module icon in the graphical user interface. To
achieve this, one needs to specify the queue object's name (the string set via
the <tt>setName()</tt> method) in the <tt>q</tt> display string tag. OMNeT++ finds
the queue object by traversing the object tree inside the module.

<p>The following example displays the length of the queue named <tt>"jobQueue"</tt>:

<pre class="ned">
@display("q=jobQueue");
</pre>
<p>
<center>
<img src="graphics-qtag.png">
</center>

<p><h4><a name="sec:graphics:submdule-text-and-tooltip"/>8.4.3.8 Text and Tooltip<a class="headerlink" href="#sec:graphics:submdule-text-and-tooltip" title="Permalink to this headline">¶</a></h4>

<p>It is possible to display a short text next to or above the module icon or shape
using the <tt>t</tt> tag in the display string. The tag allows one to specify the
placement (left, right, above) and the color of the text. To display text in a
tooltip, use the <tt>tt</tt> tag.

<p>The following example displays text above the module icon and also adds tooltip
text that can be seen by hovering over the module icon with the mouse:

<pre class="ned">
@display("t=Packets sent: 18;tt=Additional tooltip information");
</pre>
<p>
<center>
<img src="graphics-ttag.png">
</center>

<p><ul class="note"><b>NOTE</b><br>
  The <tt>t</tt> and <tt>tt</tt> tags, when set at runtime, can be used to display
  information about the module's state. The <tt>setTagArg()</tt> method
  of <tt>cDisplayString</tt> can be used to update the text:
  <tt>getDisplayString().setTagArg("t", 0, str);</tt>
</ul>

<p>For a detailed descripton of the display string tags, check
Appendix <a href="chap25.html#cha:display-strings">[25]</a>.

<p>
<h3><a name="sec:graphics:background-displaystring-tags"/>8.4.4 Background Tags<a class="headerlink" href="#sec:graphics:background-displaystring-tags" title="Permalink to this headline">¶</a></h3>

<p>The following tags of the module display string are in effect when the
module itself is opened in a GUI. These tags mostly deal with the visual
properties of the background rectangle.

<p><ul>
  <li> <tt>bgb</tt> -- size, color and border of the background rectangle
  <li> <tt>bgi</tt> -- background image and its display mode
  <li> <tt>bgtt</tt> -- tooltip above the background
  <li> <tt>bgg</tt> -- background grid: color, spacing, etc.
  <li> <tt>bgu</tt> -- measurement unit of coordinates/distances
</ul>

<p>In the following example, the background area is defined to be 6000x4500
units, and the map of Europe is used as a background, stretched to fill the
whole area. A grid is also drawn, with 1000 units between major ticks,
and 2 minor ticks per major tick.

<pre class="ned">
network EuropePlayground
{
    @display("bgb=6000,4500;bgi=maps/europe,s;bgg=1000,2,grey95;bgu=km");
</pre>
<p>

<p>  <center>
    <img src="graphics-bgtags.png">
    <center><div class="caption"><i>Figure: Background image and grid</i></div></center>
    <a name="fig:graphics-bgtags"></a>
  </center>

<p>
The <tt>bgu</tt> tag deserves special attention. It does not affect
the visual appearance, but instead it is a hint for model code
on how to interpret coordinates and distances in this compound
module. The above example specifies <tt>bgu=km</tt>, which means
that if the model attaches physical meaning to coordinates and
distances, then those numbers should be interpreted as kilometers.

<p>More detailed information, such as what each tag argument means, is
available in Appendix <a href="chap25.html#cha:display-strings">[25]</a>.

<p>
<h3><a name="sec:graphics:connection-displaystrings"/>8.4.5 Connection Display Strings<a class="headerlink" href="#sec:graphics:connection-displaystrings" title="Permalink to this headline">¶</a></h3>

<p>Connections may also have display strings. Connections inherit the
display string property from their channel types, in the same way as
submodules inherit theirs from module types. The default display
strings are empty.

<p>Connections support the following tags:

<p><ul>
  <li> <tt>ls</tt> -- line style and color
  <li> <tt>t</tt> -- text
  <li> <tt>tt</tt> -- tooltip
  <li> <tt>m</tt> -- orientation and positioning
</ul>

<p>Example of a thick, red connection:
<pre class="ned">
source1.out --&gt; { @display("ls=red,3"); } --&gt; queue1.in++;
</pre>

<p><center>
<img src="graphics-lstag.png">
</center>

<p><ul class="note"><b>NOTE</b><br>
To hide a connection, specify zero line width in the display string:
<tt>"ls=,0"</tt>.
</ul>

<p>More detailed information, such as what each tag argument means, is
available in Appendix <a href="chap25.html#cha:display-strings">[25]</a>.

<p>
<h3><a name="sec:graphics:message-displaystrings"/>8.4.6 Message Display Strings<a class="headerlink" href="#sec:graphics:message-displaystrings" title="Permalink to this headline">¶</a></h3>

<p>Message display strings affect how messages are shown during animation.
By default, they are displayed as a small filled circle, in one of
8 basic colors (the color is determined as <i>message kind modulo 8</i>),
and with the message class and/or name displayed under it.
The latter is configurable in the Preferences dialog of Qtenv,
and message kind dependent coloring can also be turned off there.

<p><h4><a name="sec:graphics:specifying-message-displaystrings"/>8.4.6.1 How to Specify<a class="headerlink" href="#sec:graphics:specifying-message-displaystrings" title="Permalink to this headline">¶</a></h4>

<p>Message objects do not store a display string by default. Instead,
<tt>cMessage</tt> defines a virtual <tt>getDisplayString()</tt> method
that one can override in subclasses to return an arbitrary string.
The following example adds a display string to a new message class:

<pre class="cpp">
class Job : public cMessage
{
  public:
    const char *getDisplayString() const {return "i=msg/packet;is=vs";}
    //...
};
</pre>
<p>
Since message classes are often defined in <tt>msg</tt> files (see chapter
<a href="chap6.html#cha:msg-def">[6]</a>), it is often convenient to let the message compiler
generate the <tt>getDisplayString()</tt> method. To achieve that, add a
string field named <tt>displayString</tt> with an initializer to the message
definition. The message compiler will generate <tt>setDisplayString()</tt>
and <tt>getDisplayString()</tt> methods into the new class, and also set the
initial value in the constructor.

<p>An example message file:

<pre class="msg">
message Job
{
    string displayString = "i=msg/package_s,kind";
    //...
}
</pre>
<p>
<h4><a name="sec:graphics:message-displaystring-tags"/>8.4.6.2 Tags<a class="headerlink" href="#sec:graphics:message-displaystring-tags" title="Permalink to this headline">¶</a></h4>

<p>The following tags can be used in message display strings:

<p><ul>
  <li> <tt>b</tt> -- shape, color
  <li> <tt>i</tt> -- icon
  <li> <tt>is</tt> -- icon size
</ul>

<p><ul class="note"><b>NOTE</b><br>
   In message display strings, <tt>kind</tt> is accepted as a special color name.
   It will cause the color to be derived from <i>message kind</i> field in the message.
</ul>

<p>The following example displays a small red box icon:

<pre class="ned">
@display("i=msg/box,red;is=s");
</pre>
<p>
The next one displays a 15x15 rectangle, with while fill, and with a border
color dependent on the message kind:

<pre class="ned">
@display("b=15,15,rect,white,kind,5");
</pre>
<p>
More detailed information, such as what each tag argument means, is
available in Appendix <a href="chap25.html#cha:display-strings">[25]</a>.

<p>
<h3><a name="sec:graphics:displaystring-parameter-substitution"/>8.4.7 Parameter Substitution<a class="headerlink" href="#sec:graphics:displaystring-parameter-substitution" title="Permalink to this headline">¶</a></h3>

<p>In addition to literal values, display strings may also contain embedded NED
expressions and references to module/channel parameters, made available with the
<tt>${...}</tt> and <tt>$foo</tt> syntaxes, respectively. To add a literal
dollar sign to a display string value, double it.

<p>Here is an example for referencing module/channel parameters:

<pre class="ned">
simple MobileNode
{
    parameters:
        double xpos;
        double ypos;
        string fillColor;
        // get the values from the module parameters xpos,ypos,fillcolor
        @display("p=$xpos,$ypos;b=60,10,rect,$fillColor,black,2");
}
</pre>
<p>
There is also a fallback to the parameters of the parent component.

<p><h3><a name="sec:graphics:displaystring-embedded-expressions"/>8.4.8 Embedded Expressions<a class="headerlink" href="#sec:graphics:displaystring-embedded-expressions" title="Permalink to this headline">¶</a></h3>

<p>Arbitrary NED expressions can be embedded in display strings using the
<tt>${...}</tt> notation. These expressions are evaluated in the context of the
display string's owner component, which means that identifiers refer to the
parameters of the component.

<p>As opposed to the <tt>$foo</tt> syntax, there is no fallback to the parameters of
the parent module. To refer to the parent module's <tt>foo</tt> parameter, the
parameter name must be qualified with the <b><tt>parent</tt></b> keyword:
<tt>${parent.foo}</tt>.

<pre class="ned">
  @display("p=${parent.xpos + r*cos(phi)},${$parent.ypos + r*sin(phi)}");
</pre>
<p>
These expressions are evaluated every time the appearance of the component is refreshed,
so volatile parameters and random numbers will take effect at every display refresh.

<p>
<h3><a name="sec:graphics:displaystring-colors"/>8.4.9 Colors<a class="headerlink" href="#sec:graphics:displaystring-colors" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:graphics:displaystring-color-names"/>8.4.9.1 Color Names<a class="headerlink" href="#sec:graphics:displaystring-color-names" title="Permalink to this headline">¶</a></h4>

<p>A color may be given in several forms. One form is English names: <tt>blue</tt>,
<tt>lightgrey</tt>, <tt>wheat</tt>, etc. The list includes all standard SVG color
names.

<p>Another acceptable form is the HTML RGB syntax: <i>#rgb</i> or
<i>#rrggbb</i>, where <i>r</i>, <i>g</i>, <i>b</i> are hexadecimal
digits.

<p>Colors can also be specified in HSB (hue-saturation-brightness) as
<i>@hhssbb</i> (with <i>h</i>, <i>s</i>, <i>b</i> being hexadecimal
digits). HSB makes it easier to scale colors, e.g., from white to bright red.

<p>One can produce a transparent background by specifying a hyphen (<i>"-"</i>)
as the background color.

<p>In message display strings, <tt>kind</tt> can also be used as a special color name.
It will map the message kind to a color. (See the <tt>getKind()</tt> method of
<tt>cMessage</tt>.)

<p><h4><a name="sec:graphics:displaystring-icon-colorization"/>8.4.9.2 Icon Colorization<a class="headerlink" href="#sec:graphics:displaystring-icon-colorization" title="Permalink to this headline">¶</a></h4>

<p>The <tt>"i="</tt> display string tag allows for colorization of icons. It accepts a
target color and a percentage as the degree of colorization. The percentage has
no effect if the target color is missing. The brightness of the icon is also
affected. To keep the original brightness, specify a color with about 50%
brightness (e.g., <tt>#808080</tt> mid-grey, <tt>#008000</tt> mid-green).

<p>Examples:

<p><ul>
  <li> <tt>"i=device/server,gold"</tt> creates a gold server icon
  <li> <tt>"i=misc/globe,#808080,100"</tt> makes the icon greyscale
  <li> <tt>"i=block/queue,white,100"</tt> yields a "burnt-in" black-and-white icon
</ul>

<p>Colorization works with both submodule and message icons.

<p>
<h3><a name="sec:graphics:icon-library"/>8.4.10 Icons<a class="headerlink" href="#sec:graphics:icon-library" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:graphics:image-path"/>8.4.10.1 The Image Path<a class="headerlink" href="#sec:graphics:image-path" title="Permalink to this headline">¶</a></h4>

<p>In the current OMNeT++ version, module icons are PNG or GIF files. The icons shipped
with OMNeT++ are in the <tt>images/</tt> subdirectory. The IDE and Qtenv
need the exact location of this directory to be able to load the icons.

<p>Icons are loaded from all directories in the <i>image path</i>,
a semicolon-separated list of directories.
The default image path is compiled into Qtenv with the value
<tt>"<i>&lt;omnetpp&gt;</i>/images;./images"</tt>. This works fine (unless the
OMNeT++ installation is moved), and the <tt>./images</tt> part also allows
icons to be loaded from the <tt>images/</tt> subdirectory of the current
directory. As users typically run simulation models from the model's
directory, this practically means that custom icons placed in the
<tt>images/</tt> subdirectory of the model's directory are automatically
loaded.

<p>The compiled-in image path can be overridden with the <tt>OMNETPP_IMAGE_PATH</tt>
environment variable. The way of setting environment variables is system
specific. In Unix, if one is using the bash shell, adding a line

<pre class="commandline">
export OMNETPP_IMAGE_PATH="$HOME/omnetpp/images;./images"
</pre>
<p>
to <tt>~/.bashrc</tt> or <tt>~/.bash_profile</tt> will
do. On Windows, environment variables can be set via the <i>My Computer --&gt;
<a href="../api/classomnetpp_1_1nedxml_1_1MsgTypeTable_1_1Properties.html">Properties</a></i> dialog.

<p>One can extend the image path from <tt>omnetpp.ini</tt> with the
<tt>image-path</tt> option, which is prepended to the environment
variable's value.

<pre class="inifile">
[General]
image-path = "/home/you/model-framework/images;/home/you/extra-images"
</pre>
<p>

<p><h4><a name="sec:graphics:categorized-icons"/>8.4.10.2 Categorized Icons<a class="headerlink" href="#sec:graphics:categorized-icons" title="Permalink to this headline">¶</a></h4>

<p>Icons are organized into several categories, represented by folders.
These categories include:

<p><ul>
  <li> <tt>abstract/</tt> - symbolic icons for various devices
  <li> <tt>background/</tt> - images useful as background, such as terrain maps
  <li> <tt>block/</tt> - icons for subcomponents (queues, protocols, etc.)
  <li> <tt>device/</tt> - network device icons: servers, hosts, routers, etc.
  <li> <tt>misc/</tt> - icons for nodes, subnets, clouds, buildings, towns, cities, etc.
  <li> <tt>msg/</tt> - icons that can be used for messages
  <li> <tt>status/</tt> - status icons such as up, down, busy, etc.
</ul>

<p>Icon names to be used with the <tt>i</tt>, <tt>bgi</tt>, and other tags should contain
the subfolder (category) name but not the file extension. For example,
<tt>/opt/omnetpp/images/block/sink.png</tt> should be referred to as
<tt>block/sink</tt>.

<p>
<h4><a name="sec:graphics:icon-size"/>8.4.10.3 Icon Size<a class="headerlink" href="#sec:graphics:icon-size" title="Permalink to this headline">¶</a></h4>

<p>Icons come in various sizes: normal, large, small, very small, and very large.
Sizes are encoded into the icon name's suffix: <tt>_vl</tt>, <tt>_l</tt>, <tt>_s</tt>,
<tt>_vs</tt>. In display strings, one can either use the suffix
(<tt>"i=device/router_l"</tt>) or the <tt>"is"</tt> (icon size) display string tag
(<tt>"i=device/router;is=l"</tt>), but not both at the same time (we recommend
using the <tt>is</tt> tag).

<p><h3><a name="sec:graphics:compound-module-layouting"/>8.4.11 Layouting<a class="headerlink" href="#sec:graphics:compound-module-layouting" title="Permalink to this headline">¶</a></h3>

<p>OMNeT++ implements an automatic layouting feature using a variation of the Spring
Embedder algorithm. Modules that have not been assigned explicit positions via
the <tt>"p="</tt> tag will be automatically placed by the algorithm.

<p>Spring Embedder is a graph layouting algorithm based on a physical model. Graph
nodes (modules) repel each other like electric charges of the same sign, and
connections act as springs that pull nodes together. There is also friction
built in to prevent oscillation of the nodes. The layouting algorithm simulates
this physical system until it reaches equilibrium (or times out). The physical
rules mentioned earlier have been slightly tweaked to achieve better results.

<p>The algorithm doesn't move any module that has fixed coordinates. Modules
that are part of a predefined arrangement (row, matrix, ring, etc., defined
via the 3rd and further args of the <tt>"p="</tt> tag) will be moved together
to preserve their relative positions.

<p><ul class="note"><b>NOTE</b><br>
The positions of modules placed by the layouting algorithm are not available
from simulation models. Consider what positions OMNeT++ should report if the
model is run under Cmdenv or under Qtenv but the compound module was never
opened in the GUI. The absence of explicit coordinates in the NED file
conceptually means that the modeler doesn't care about the position of that
module.
</ul>

<p>Caveats:

<p><ul>
  <li> If the full graph is too big after layouting, it will be scaled back to
    fit on the screen, unless it contains any fixed-position modules. To prevent
    rescaling, one can specify a sufficiently large bounding box in the background
    display string, e.g., "b=2000,3000".
  <li> Submodule size is ignored by the present layouter, so modules with
    elongated shapes may not be placed ideally.
  <li> The algorithm may produce erratic results, especially for small graphs
    when the number of submodules is small or when using predefined (matrix, row,
    ring, etc.) layouts. In such cases, the <i>Relayout</i> toolbar button can
    be useful. Larger networks usually produce satisfactory results.
  <li> The algorithm starts by placing the nodes randomly, and this initial
    arrangement greatly affects the end result. The algorithm has its own random
    number generator (RNG) that starts from a default seed. The <i>Relayout</i>
    button changes this seed, and the seed is persistently stored so that later
    runs of the model will produce the same layout.
</ul>

<p>
<h3><a name="sec:graphics:changing-displaystrings-at-runtime"/>8.4.12 Changing Display Strings at Runtime<a class="headerlink" href="#sec:graphics:changing-displaystrings-at-runtime" title="Permalink to this headline">¶</a></h3>

<p>It is often useful to manipulate the display string at runtime. Changing colors,
icons, or text may convey status changes, and changing a module's position is
useful when simulating mobile networks.

<p>Display strings are stored in <tt>cDisplayString</tt> objects inside channels,
modules, and gates. <tt>cDisplayString</tt> also allows one to manipulate the
string.

<p>As far as <tt>cDisplayString</tt> is concerned, a display string (e.g.,
<tt>"p=100,125;i=cloud"</tt>) is a string that consists of several <i>tags</i>
separated by semicolons, and each tag has a <i>name</i> and zero or more
<i>arguments</i> separated by commas.

<p>The class facilitates tasks such as finding out what tags a display string has,
adding new tags, adding arguments to existing tags, removing tags, or replacing
arguments. The internal storage method allows very fast operation, which is
generally faster than direct string manipulation. The class doesn't try to
interpret the display string in any way, nor does it know the meaning of the
different tags. It merely parses the string as data elements separated by
semicolons, equal signs, and commas.

<p>To get a pointer to a <tt>cDisplayString</tt> object, one can call
the component's <tt>getDisplayString()</tt> method.

<p><ul class="note"><b>NOTE</b><br>
The connection display string is stored in the channel object, but it
can also be accessed via the source gate of the connection.
</ul>

<p>The display string can be overwritten using the <tt>parse()</tt> method.
Tag arguments can be set with <tt>setTagArg()</tt>, and tags removed
with <tt>removeTag()</tt>.

<p>The following example sets a module's position, icon, and status icon
in one step:

<pre class="cpp">
cDisplayString& dispStr = getDisplayString();
dispStr.parse("p=40,20;i=device/cellphone;i2=status/disconnect");
</pre>
<p>
Setting an outgoing connection's color to red:

<pre class="cpp">
cDisplayString& connDispStr = gate("out")-&gt;getDisplayString();
connDispStr.parse("ls=red");
</pre>
<p>
Setting module background and grid with background display string tags:

<pre class="cpp">
cDisplayString& parentDispStr = getParentModule()-&gt;getDisplayString();
parentDispStr.parse("bgi=maps/europe;bgg=1000,2");
</pre>
<p>
The following example updates a display string to contain the <tt>p=40,20</tt> and
<tt>i=device/cellphone</tt> tags:

<pre class="cpp">
dispStr.setTagArg("p", 0, 40);
dispStr.setTagArg("p", 1, 20);
dispStr.setTagArg("i", 0, "device/cellphone");
</pre>
<p>
<h2><a name="sec:graphics:bubbles"/>8.5 Bubbles<a class="headerlink" href="#sec:graphics:bubbles" title="Permalink to this headline">¶</a></h2>

<p>Modules can display a transient bubble with a short message (e.g. "Going
down" or "Connection established") by calling the <tt>bubble()</tt> method of
<tt>cComponent</tt>. The method takes the string to be displayed as a
<tt>const char *</tt> pointer.

<p>An example:
<pre class="cpp">
bubble("Going down!");
</pre>

<p><center>
<img src="graphics-bubble.png">
</center>

<p>If the module often displays bubbles, it is recommended to make the
corresponding code conditional on <tt>hasGUI()</tt>. The <tt>hasGUI()</tt>
method returns <i>false</i> if the simulation is running under Cmdenv.

<pre class="cpp">
if (hasGUI()) {
    char text[32];
    sprintf(text, "Collision! (%s frames)", numCollidingFrames);
    bubble(text);
}
</pre>
<p>

<p>
<h2><a name="sec:graphics:canvas"/>8.6 The Canvas<a class="headerlink" href="#sec:graphics:canvas" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:graphics:canvas-overview"/>8.6.1 Overview<a class="headerlink" href="#sec:graphics:canvas-overview" title="Permalink to this headline">¶</a></h3>

<p>The canvas is the 2D drawing API of OMNeT++. It allows users to display lines,
curves, polygons, images, text items, and combinations of these elements. The
canvas API provides features such as color, transparency, geometric
transformations, antialiasing, and more. Drawings created with the canvas API
can be viewed when running the simulation under a graphical user interface like
Qtenv.

<p>The canvas API can be used for various purposes, such as displaying textual
annotations, status information, live statistics in the form of plots, charts,
gauges, counters, etc. In different types of simulations, the canvas API can be
used to draw different types of graphical presentations. For example, in mobile
and wireless simulations, the canvas API can be used to draw the scene including
a background (such as a street map or floor plan), mobile objects (vehicles,
people), obstacles (trees, buildings, hills), antennas with orientation, and
additional information like connectivity graphs, movement trails, and individual
transmissions.

<p>Multiple canvases can be created, and each module already has a default canvas.
The default canvas is the one on which the module's submodules and internal
connections are displayed. The default canvas can be enhanced using the canvas
API to enrich the default presentation of a compound module.

<p>In OMNeT++, the items that appear on a canvas are called <i>figures</i>. The
corresponding C++ types for figures are <tt>cCanvas</tt> and <tt>cFigure</tt>.
<tt>cFigure</tt> is an abstract base class, and different types of figures are
represented by various subclasses of <tt>cFigure</tt>.

<p>Figures can be defined statically in NED files using <b><tt>@figure</tt></b> properties,
and can also be accessed, created, and manipulated programmatically at runtime.

<p>
<h3><a name="sec:graphics:creating-accessing-and-viewing-canvases"/>8.6.2 Creating, Accessing, and Viewing Canvases<a class="headerlink" href="#sec:graphics:creating-accessing-and-viewing-canvases" title="Permalink to this headline">¶</a></h3>

<p>A canvas is represented by the <tt>cCanvas</tt> C++ class. The default canvas of
a module can be accessed with the <tt>getCanvas()</tt> method of
<tt>cModule</tt>. For example, a toplevel submodule can obtain the network's
canvas with the following line of code:

<pre class="cpp">
cCanvas *canvas = getParentModule()-&gt;getCanvas();
</pre>
<p>
By using the canvas pointer, it is possible to check the figures it contains,
add new figures, manipulate existing ones, and perform other operations.

<p>New canvases can be created by instantiating new <tt>cCanvas</tt> objects. For example:

<pre class="cpp">
cCanvas *canvas = new cCanvas("liveStatistics");
</pre>
<p>
To view the contents of additional canvases in Qtenv, one needs to navigate to
the owner object of the canvas (usually the module that created the canvas),
view the list of objects it contains, and double-click the canvas in the list.
Giving meaningful names to extra canvas objects can simplify the process of
locating them in the Qtenv GUI.

<p>
<h3><a name="sec:graphics:figure-classes"/>8.6.3 Figure Classes<a class="headerlink" href="#sec:graphics:figure-classes" title="Permalink to this headline">¶</a></h3>

<p>The base class of all figure classes is <tt>cFigure</tt>. The class hierarchy is
shown in figure <a href="chap8.html#fig:figure-inheritance">below</a>.

<p>
  <center>
    <img src="figure-inheritance.svg">
    <center><div class="caption"><i>Figure: cFigure class hierarchy</i></div></center>
    <a name="fig:figure-inheritance"></a>
  </center>

<p>
In the following sections, we will first describe features that are common to
all figures, then briefly cover each figure class, and finally discuss how one
can define new figure types.

<p><ul class="note"><b>NOTE</b><br>
Figures are only data storage classes. The actual drawing code is implemented in
Qtenv, which might involve a parallel data structure, figure renderer classes,
etc. When the canvas is not viewed, corresponding objects in Qtenv do not exist.
Therefore, the data flow is largely one-directional -- from figures to GUI.
</ul>

<p>
<h3><a name="sec:graphics:figure-tree"/>8.6.4 The Figure Tree<a class="headerlink" href="#sec:graphics:figure-tree" title="Permalink to this headline">¶</a></h3>

<p>Figures on a canvas are organized into a tree structure. The canvas has a hidden
<i>root figure</i>, and all top-level figures are its children. Any figure can
contain child figures, not just dedicated ones like <tt>cGroupFigure</tt>.

<p>Every figure has a name string, inherited from <tt>cNamedObject</tt>. Since
figures are organized in a tree, every figure also has a <i>hierarchical
name</i>. It consists of the names of figures in the path from the root figure down
to the figure, joined with dots. (The name of the root figure itself is
omitted.)

<p>Child figures can be added to a figure using the <tt>addFigure()</tt> method, or
inserted into the child list relative to a sibling using the
<tt>insertBefore()</tt> and <tt>insertAfter()</tt> methods. <tt>addFigure()</tt>
has two variants: one for appending and one for inserting at a specific
position. Child figures can be accessed by name using <tt>getFigure(name)</tt>,
or enumerated by index in the child list using <tt>getFigure(k)</tt> and
<tt>getNumFigures()</tt>. The index of a child figure can be obtained using
<tt>findFigure()</tt>. The <tt>removeFromParent()</tt> method can be used to
remove a figure from its parent.

<p>For convenience, <tt>cCanvas</tt> also provides methods like
<tt>addFigure()</tt>, <tt>getFigure()</tt>, and <tt>getNumFigures()</tt> for
managing top-level figures without the need to go through the root figure.

<p>The following code enumerates the children of a figure named <tt>"group1"</tt>:

<pre class="cpp">
cFigure *parent = canvas-&gt;getFigure("group1");
ASSERT(parent != nullptr);
for (int i = 0; i &lt; parent-&gt;getNumFigures(); i++)
    EV &lt;&lt; parent-&gt;getFigure(i)-&gt;getName() &lt;&lt; endl;
</pre>
<p>
It is also possible to locate a figure by its hierarchical name
(<tt>getFigureByPath()</tt>) and to find a figure by its non-hierarchical name
anywhere in a figure subtree (<tt>findFigureRecursively()</tt>).

<p>The <tt>dup()</tt> method of figure classes only duplicates the figure it is
called on. (The duplicate will not have any children.) To clone a figure
including its children, use the <tt>dupTree()</tt> method.

<p>
<h3><a name="sec:graphics:creating-and-manipulating-figures"/>8.6.5 Creating and Manipulating Figures from NED and C++<a class="headerlink" href="#sec:graphics:creating-and-manipulating-figures" title="Permalink to this headline">¶</a></h3>

<p>As mentioned earlier, figures can be defined in the NED file, so they do not
always need to be created programmatically. This possibility is useful for
creating static backgrounds or statically defining placeholders for dynamically
displayed items, among other use cases. Figures defined from NED can be accessed
and manipulated from C++ code in the same way as dynamically created ones.

<p>Figures are defined in NED by adding <b><tt>@figure</tt></b> properties to a module
definition. The hierarchical name of the figure goes into the property index,
enclosed in square brackets after <tt>@figure</tt>. The parent of the figure must
already exist. For example, when defining <tt>foo.bar.baz</tt>, both <tt>foo</tt> and
<tt>foo.bar</tt> must have already been defined in the NED file.

<p>The type and various attributes of the figure are specified in the property body
as key-value pairs. For example, <tt>type=line</tt> creates a <tt>cLineFigure</tt>,
<tt>type=rectangle</tt> creates a <tt>cRectangleFigure</tt>, <tt>type=text</tt>
creates a <tt>cTextFigure</tt>, and so on. The list of accepted types is
provided in appendix <a href="chap26.html#cha:figure-definitions">[26]</a>. Additional attributes
correspond to getters and setters of the C++ class denoted by the <tt>type</tt>
attribute.

<p>The following example creates a green rectangle and the text
<i>"placeholder"</i> inside it in NED. The subsequent C++ code changes the
text to <i>"Hello World!"</i>.

<p>NED part:

<pre class="ned">
module Foo
{
    @display("bgb=800,500");
    @figure[box](type=rectangle; coords=10,50; size=200,100; fillColor=green);
    @figure[box.label](type=text; coords=20,80; text=placeholder);
}
</pre>
<p>
And the corresponding C++ code:

<pre class="cpp">
// We assume this code runs in a submodule of the "Foo" module.
cCanvas *canvas = getParentModule()-&gt;getCanvas();

// Obtain the figure pointer by hierarchical name and change the text.
cFigure *figure = canvas-&gt;getFigureByPath("box.label");
cTextFigure *textFigure = check_and_cast&lt;cTextFigure *&gt;(figure);
textFigure-&gt;setText("Hello World!");
</pre>
<p>

<h3><a name="sec:graphics:canvas-stacking-order"/>8.6.6 Stacking Order<a class="headerlink" href="#sec:graphics:canvas-stacking-order" title="Permalink to this headline">¶</a></h3>

<p>The stacking order (also known as Z-order) of figures is determined jointly by
the child order and the <tt>cFigure</tt> attribute called Z-index, with the
latter taking priority. The Z-index is not used directly, but instead an
<i>effective Z-index</i> is computed as the <i>sum</i> of the Z-index values
of the figure and all its ancestors up to the root figure.

<p>A figure with a larger effective Z-index will be displayed above figures with
smaller effective Z-indices, regardless of their positions in the figure tree.
Among figures with equal effective Z-indices, the child order determines the
stacking order. If two such figures are siblings, the one that occurs later in
the child list will be drawn above the other. For figures that are not siblings,
the child order within the first common ancestor matters.

<p>These design decisions, where the effective Z-index is computed as the sum up to
the root and affects the order among all figures (not just siblings), result in
significant flexibility. The Z-order of figures is no longer constrained by the
order of the figure tree.

<p>There are several methods for managing the stacking order of figures, including
<tt>setZIndex()</tt> to set the Z-index of a figure, <tt>getZIndex()</tt> to get
the Z-index of a figure, <tt>getEffectiveZIndex()</tt> to get the effective
Z-index of a figure, <tt>insertAbove()</tt> and <tt>insertBelow()</tt> to insert a
figure above or below another figure, <tt>isAbove()</tt> and <tt>isBelow()</tt> to
check if a figure is above or below another figure, and <tt>raiseAbove()</tt>,
<tt>lowerBelow()</tt>, <tt>raiseToTop()</tt>, and <tt>lowerToBottom()</tt> to raise
or lower a figure in the stack.

<p>
<h3><a name="sec:graphics:canvas-transforms"/>8.6.7 Transforms<a class="headerlink" href="#sec:graphics:canvas-transforms" title="Permalink to this headline">¶</a></h3>

<p>One of the most powerful features of the Canvas API is the ability to apply
geometric transformations to figures. OMNeT++ uses 2D homogeneous transformation
matrices, which can express affine transforms such as translation, scaling,
rotation, and skew (shearing). The transformation matrix used by OMNeT++ has the
following format:


<center>
<div>
<span style="vertical-align: middle;">T&nbsp;=</span>
<table class="matrix">
  <tr><td>a</td><td>c</td><td>t<sub>1</sub></td></tr>
  <tr><td>b</td><td>d</td><td>t<sub>2</sub></td></tr>
  <tr><td>0</td><td>0</td><td>1</td></tr>
</table>
</div>
</center>

<p>


<p>In a nutshell, given a point with its <i>(x, y)</i> coodinates, one can obtain the
transformed version of it by multiplying the transformation matrix by the
<i>(x \ y \ 1)</i> column vector (a.k.a. homogeneous coordinates), and dropping the
third component:


<center>
<div>
<table class="matrix">
  <tr><td>x'</td></tr>
  <tr><td>y'</td></tr>
  <tr><td>1</td></tr>
</table>
<span style="vertical-align: middle;">&nbsp;=&nbsp;</span>
<table class="matrix">
  <tr><td>a</td><td>c</td><td>t<sub>1</sub></td></tr>
  <tr><td>b</td><td>d</td><td>t<sub>2</sub></td></tr>
  <tr><td>0</td><td>0</td><td>1</td></tr>
</table>
<span>&nbsp;</span>
<table class="matrix">
  <tr><td>x</td></tr>
  <tr><td>y</td></tr>
  <tr><td>1</td></tr>
</table>
</div>
</center>

<p>


<p>Given a point with coordinates <i>(x, y)</i>, the transformed version of the point
can be obtained by multiplying the transformation matrix by the column vector
<i>(x, y, 1)</i> (referred to as homogeneous coordinates) and dropping the third
component. The result is <i>(ax + cy + t<sub>1</sub>, bx + dy + t<sub>2</sub>)</i>. The coefficients <i>a</i>,
<i>b</i>, <i>c</i>, <i>d</i> control rotation, scaling, and skew, while <i>t<sub>1</sub></i> and <i>t<sub>2</sub></i> control
translation. Transforming a point by matrix <i>T<sub>1</sub></i> and then by <i>T<sub>2</sub></i> is
equivalent to transforming the point by the matrix <i>T<sub>2</sub> T<sub>1</sub></i> due to the
associativity of matrix multiplication.

<p>
<h4><a name="sec:graphics:the-transform-class"/>8.6.7.1 The Transform Class<a class="headerlink" href="#sec:graphics:the-transform-class" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cFigure::Transform</tt> class represents transformation matrices in OMNeT++.

<p>A <tt>cFigure::Transform</tt> matrix can be initialized using various methods.
One way is to assign values directly to the <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, <tt>d</tt>,
<tt>t1</tt>, and <tt>t2</tt> members. Another way is to use the six-argument
constructor. It is also possible to start from the identity transform (created
by the default constructor) and apply transformations using the <tt>scale()</tt>,
<tt>rotate()</tt>, <tt>skewx()</tt>, <tt>skewy()</tt>, and <tt>translate()</tt>
member functions. These functions update the matrix to reflect the specified
transformation, as if the matrix was left-multiplied by a temporary matrix that
represents the transformation.

<p>To transform a point, represented by the <tt>cFigure::Point</tt> class, one can
use the <tt>applyTo()</tt> method of <tt>cFigure::Transform</tt>. The following
code demonstrates this:

<pre class="cpp">
// Allow Transform and Point to be referenced without the cFigure:: prefix
typedef cFigure::Transform Transform;
typedef cFigure::Point Point;

// Create a matrix that scales by 2, rotates by 45 degrees, and translates by (100,0)
Transform t = Transform().scale(2.0).rotate(M_PI/4).translate(100,0);

// Apply the transform to the point (10, 20)
Point p(10, 20);
Point p2 = t.applyTo(p);
</pre>
<p>

<p><h4><a name="sec:graphics:figure-transforms"/>8.6.7.2 Figure Transforms<a class="headerlink" href="#sec:graphics:figure-transforms" title="Permalink to this headline">¶</a></h4>

<p>Every figure has an associated transformation matrix, which
affects how the figure and its figure subtree are displayed.
In other words, the way a figure displayed is affected by its own
transformation matrix and the transformation matrices of all of its
ancestors, up to the root figure of the canvas. The effective transform
will be the product of those transformation matrices.

<p>A figure's transformation matrix is directly accessible via <tt>cFigure</tt>'s
<tt>getTransform()</tt>, <tt>setTransform()</tt> member functions.
For convenience, <tt>cFigure</tt> also has several <tt>scale()</tt>, <tt>rotate()</tt>,
<tt>skewx()</tt>, <tt>skewy()</tt> and <tt>translate()</tt> member functions,
which directly operate on the internal transformation matrix.

<p>Some figures have visual aspects that are not, or only optionally affected
by the transform. For example, the size and orientation of the text
displayed by <tt>cLabelFigure</tt>, in contrast to that of
<tt>cTextFigure</tt>, is unaffected by transforms (and of manual zoom as
well). Only the position is transformed.

<p><h4><a name="sec:graphics:figure-transform-vs-move"/>8.6.7.3 Transform vs move()<a class="headerlink" href="#sec:graphics:figure-transform-vs-move" title="Permalink to this headline">¶</a></h4>

<p>In addition to the <tt>translate()</tt>, <tt>scale()</tt>, <tt>rotate()</tt>,
etc. functions that update the figure's transformation matrix, figures also
have a <tt>move()</tt> method. <tt>move()</tt>, like <tt>translate()</tt>,
also moves the figure by a <i>dx</i>, <i>dy</i> offset. However, <tt>move()</tt> works
by changing the figure's coordinates, and not by changing the
transformation matrix.

<p>Since every figure class stores and interprets its position differently,
<tt>move()</tt> is defined for each figure class independently. For example,
<tt>cPolylineFigure</tt>'s <tt>move()</tt> changes the coordinates of each point.

<p><tt>move()</tt> is recursive, that is, it not only moves the figure on which
it was called, but also its children. There is also a non-recursive variant,
called <tt>moveLocal()</tt>.

<p>
<h3><a name="sec:graphics:showing-hiding-figures"/>8.6.8 Showing/Hiding Figures<a class="headerlink" href="#sec:graphics:showing-hiding-figures" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:graphics:figure-visibility-flag"/>8.6.8.1 Visibility Flag<a class="headerlink" href="#sec:graphics:figure-visibility-flag" title="Permalink to this headline">¶</a></h4>

<p>Figures have a visibility flag that controls whether the figure is displayed.
Hiding a figure via the flag will also hide its subtree. The flag can be
accessed using the <tt>isVisible()</tt> and <tt>setVisible()</tt> member functions
of <tt>cFigure</tt>.

<p><h4><a name="sec:graphics:figure-tags"/>8.6.8.2 Tags<a class="headerlink" href="#sec:graphics:figure-tags" title="Permalink to this headline">¶</a></h4>

<p>Figures can also be assigned one or more tags, which are textual identifiers.
Tags do not directly affect rendering, but GUIs that display canvas content,
such as Qtenv, provide functionality to show/hide figures based on the tags they
contain. By using figure filters, users can conditionally display figures based
on their tags.

<p>Tag-based filtering and the visibility flag are in AND relationship -- figures hidden
via <tt>setVisible(false)</tt> cannot be displayed using tags. Also, hiding a figure
using the tag filter hides its figure subtree as well.

<p>Tags can be assigned to figures using the <tt>setTags()</tt>
method, which takes a single string of space-separated tags (tags may not
contain spaces). The methods <tt>getTags()</tt> and <tt>setTags()</tt> can
be used to access and modify the tag list.

<p>Tags functionality, when used carefully, allows one to define "layers"
that can be turned on/off from Qtenv.

<p>

<p><h3><a name="sec:graphics:figure-tooltip-associated-object"/>8.6.9 Figure Tooltip, Associated Object<a class="headerlink" href="#sec:graphics:figure-tooltip-associated-object" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:graphics:figure-tooltip"/>8.6.9.1 Tooltip<a class="headerlink" href="#sec:graphics:figure-tooltip" title="Permalink to this headline">¶</a></h4>

<p>Figures can be assigned a tooltip text using the <tt>setTooltip()</tt> method.
The tooltip is shown in the runtime GUI when the user hovers over the figure
with the mouse.

<p><h4><a name="sec:graphics:figure-associated-object"/>8.6.9.2 Associated Object<a class="headerlink" href="#sec:graphics:figure-associated-object" title="Permalink to this headline">¶</a></h4>

<p>In many simulations, certain figures correspond to objects in the simulation
model. For example, a truck image may represent a module that represents a
mobile node in the simulation. To associate a figure with its corresponding
object, the object can be set using the <tt>setAssociatedObject()</tt> method.
The GUI can use this information to provide shortcuts to the associated object,
such as selecting the object in an inspector when the user clicks the figure, or
displaying the object's tooltip over the figure if it does not have its own
tooltip.

<p><ul class="caution"><b>CAUTION</b><br>
The object must exist (i.e. must not be deleted) while it is
associated with the figure. When the object is deleted, the user
is responsible for letting  the figure forget the pointer,
e.g. by a  <tt>setAssociatedObject(nullptr)</tt> call.
</ul>

<p>
<h3><a name="sec:graphics:figure-positions-colors-fonts-etc"/>8.6.10 Specifying Positions, Colors, Fonts and Other <a href="../api/classomnetpp_1_1nedxml_1_1MsgTypeTable_1_1Properties.html">Properties</a><a class="headerlink" href="#sec:graphics:figure-positions-colors-fonts-etc" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:graphics:canvas-points"/>8.6.10.1 Points<a class="headerlink" href="#sec:graphics:canvas-points" title="Permalink to this headline">¶</a></h4>

<p>Points are represented by the <tt>cFigure::Point</tt> struct:

<pre class="cpp">
struct Point {
    double x, y;
    ...
};
</pre>
<p>
In addition to the public <tt>x</tt>, <tt>y</tt> members and a two-argument
constructor for convenient initialization, the struct provides overloaded
operators (+,-,*,/) and some utility functions like <tt>translate()</tt>,
<tt>distanceTo()</tt> and <tt>str()</tt>.

<p><h4><a name="sec:graphics:canvas-rectangles"/>8.6.10.2 Rectangles<a class="headerlink" href="#sec:graphics:canvas-rectangles" title="Permalink to this headline">¶</a></h4>

<p>Rectangles are represented by the <tt>cFigure::Rectangle</tt> struct:

<pre class="cpp">
struct Rectangle {
    double x, y,
    double width, height;
    ...
};
</pre>
<p>
A rectangle is specified with the coordinates of their top-left corner,
their width and height. The latter two are expected to be nonnegative. In
addition to the public <tt>x</tt>, <tt>y</tt>, <tt>width</tt>, <tt>height</tt> members
and a four-argument constructor for convenient initialization, the struct
also has utility functions like <tt>getCenter()</tt>, <tt>getSize()</tt>,
<tt>translate()</tt> and <tt>str()</tt>.

<p><h4><a name="sec:graphics:canvas-colors"/>8.6.10.3 Colors<a class="headerlink" href="#sec:graphics:canvas-colors" title="Permalink to this headline">¶</a></h4>

<p>Colors are represented by the <tt>cFigure::Color</tt> struct as 24-bit RGB colors:

<pre class="cpp">
struct Color {
    uint8_t red, green, blue;
    ...
};
</pre>
<p>
In addition to the public <tt>red</tt>, <tt>green</tt>, <tt>blue</tt> members
and a three-argument constructor for convenient initialization, the struct
also has a string-based constructor and <tt>str()</tt> function.
The string form accepts various notations: HTML colors (<tt>#rrggbb</tt>),
HSB colors in a similar notation (<tt>@hhssbb</tt>), and English color names
(SVG and X11 color names, to be more precise.)

<p>However, one doesn't need to use <tt>Color</tt> directly.
There are also predefined constants for the basic colors (<tt>BLACK</tt>,
<tt>WHITE</tt>, <tt>GREY</tt>, <tt>RED</tt>, <tt>GREEN</tt>, <tt>BLUE</tt>, <tt>YELLOW</tt>,
<tt>CYAN</tt>, <tt>MAGENTA</tt>), as well as a collection of carefully chosen
dark and light colors, suitable for e.g. chart drawing, in the arrays
<tt>GOOD_DARK_COLORS[]</tt> and <tt>GOOD_LIGHT_COLORS[]</tt>; for convenience,
the number of colors in each are in the <tt>NUM_GOOD_DARK_COLORS</tt>
and <tt>NUM_GOOD_LIGHT_COLORS</tt> constants).

<p>The following ways of specifying colors are all valid:

<pre class="cpp">
cFigure::BLACK;
cFigure::Color("steelblue");
cFigure::Color("#3d7a8f");
cFigure::Color("@20ff80");
cFigure::GOOD_DARK_COLORS[2];
cFigure::GOOD_LIGHT_COLORS[intrand(NUM_GOOD_LIGHT_COLORS)];
</pre>
<p>

<p><h4><a name="sec:graphics:canvas-fonts"/>8.6.10.4 Fonts<a class="headerlink" href="#sec:graphics:canvas-fonts" title="Permalink to this headline">¶</a></h4>

<p>The requested font for text figures is represented by the <tt>cFigure::Font</tt>
struct. It stores the typeface, font style and font size in one.

<pre class="cpp">
struct Font {
    std::string typeface;
    int pointSize;
    uint8_t style;
    ...
};
</pre>
<p>
The font does not need to be fully specified, there are some defaults. When
<tt>typeface</tt> is set to the empty string or when <tt>pointSize</tt> is zero
or a negative value, that means that the default font or the default size
should be used, respectively.

<p>The <tt>style</tt> field can be either <tt>FONT_NONE</tt>, or the binary OR of
the following constants: <tt>FONT_BOLD</tt>, <tt>FONT_ITALIC</tt>,
<tt>FONT_UNDERLINE</tt>.

<p>The struct also has a three-argument constructor for convenient
initialization, and an <tt>str()</tt> function that returns a human-readable
text representation of the contents.

<p>Some examples:

<pre class="cpp">
cFigure::Font("Arial");  // default size, normal
cFigure::Font("Arial", 12);  // 12pt, normal
cFigure::Font("Arial", 12, cFigure::FONT_BOLD | cFigure::FONT_ITALIC);
</pre>
<p>

<p><h4><a name="sec:graphics:canvas-line-and-shape-properties"/>8.6.10.5 Other Line and Shape <a href="../api/classomnetpp_1_1nedxml_1_1MsgTypeTable_1_1Properties.html">Properties</a><a class="headerlink" href="#sec:graphics:canvas-line-and-shape-properties" title="Permalink to this headline">¶</a></h4>

<p><tt>cFigure</tt> also contains a number of enums as inner types to describe
various line, shape, text and image properties. Here they are:

<p><b>LineStyle</b>

<p>Values: <tt>LINE_SOLID</tt>, <tt>LINE_DOTTED</tt>, <tt>LINE_DASHED</tt>

<p>This enum (<tt>cFigure::LineStyle</tt>) is used by line and shape figures
to determine their line/border style. The precise graphical interpretation,
e.g. dash lengths for the <i>dashed</i> style, depends on the graphics
library that the GUI was implemented with.

<p><b>CapStyle</b>

<p>Values: <tt>CAP_BUTT</tt>, <tt>CAP_ROUND</tt>, <tt>CAP_SQUARE</tt>

<p>This enum is used by line and path figures, and it indicates the shape to
be used at the end of the lines or open subpaths.

<p><center>
<img src="graphics-linecaps.png">
</center>

<p><b>JoinStyle</b>

<p>Values: <tt>JOIN_BEVEL</tt>, <tt>JOIN_ROUND</tt>, <tt>JOIN_MITER</tt>

<p>This enum indicates the shape to be used when two line segments are joined,
in line or shape figures.

<p><center>
<img src="graphics-linejoins.png">
</center>

<p><b>FillRule</b>

<p>Values: <tt>FILL_EVENODD</tt>, <tt>FILL_NONZERO</tt>.

<p>This enum determines which regions of a self-intersecting shape
should be considered to be inside the shape, and thus be filled.

<p><center>
<img src="graphics-fillrule.png">
</center>

<p><b>Arrowhead</b>

<p>Values: <tt>ARROW_NONE</tt>, <tt>ARROW_SIMPLE</tt>, <tt>ARROW_TRIANGLE</tt>, <tt>ARROW_BARBED</tt>.

<p>Some figures support displaying arrowheads at one or both ends of a line.
This enum determines the style of the arrowhead to be used.

<p><center>
<img src="graphics-arrowheads.png">
</center>

<p><b>Interpolation</b>

<p>Values: <tt>INTERPOLATION_NONE</tt>, <tt>INTERPOLATION_FAST</tt>, <tt>INTERPOLATION_BEST</tt>.

<p>Interpolation is used for rendering an image when it is not displayed at
its native resolution. This enum indicates the algorithm to be used for
interpolation.

<p>The mode <i>none</i> selects the "nearest neighbor" algorithm.
<i>Fast</i> emphasizes speed, and <i>best</i> emphasizes quality;
however, the exact choice of algorithm (bilinear, bicubic, quadratic, etc.)
depends on features of the graphics library that the GUI was implemented with.

<p><b>Anchor</b>

<p>Values:
<tt>ANCHOR_CENTER</tt>, <tt>ANCHOR_N</tt>, <tt>ANCHOR_E</tt>, <tt>ANCHOR_S</tt>, <tt>ANCHOR_W</tt>,
<tt>ANCHOR_NW</tt>, <tt>ANCHOR_NE</tt>, <tt>ANCHOR_SE</tt>, <tt>ANCHOR_SW</tt>;
<tt>ANCHOR_BASELINE_START</tt>, <tt>ANCHOR_BASELINE_MIDDLE</tt>, <br> <tt>ANCHOR_BASELINE_END</tt>.

<p>Some figures like text and image figures are placed by specifying a single
point (<i>position</i>) plus an anchor mode, a value from this enum. The
anchor mode indicates which point of the bounding box of the figure should
be positioned over the specified point. For example, when using
<tt>ANCHOR_N</tt>, the figure is placed so that its top-middle point falls at
the specified point.

<p>The last three, <i>baseline</i> constants are only used with text
figures, and indicate that the start, middle or end of the text's baseline
is the anchor point.

<p>
<h3><a name="sec:graphics:primitive-figures"/>8.6.11 Primitive Figures<a class="headerlink" href="#sec:graphics:primitive-figures" title="Permalink to this headline">¶</a></h3>

<p>Now that we know all about figures in general, we can look into the
specific figure classes provided by OMNeT++.

<p><h4><a name="sec:graphics:abstractlinefigure"/>8.6.11.1 cAbstractLineFigure<a class="headerlink" href="#sec:graphics:abstractlinefigure" title="Permalink to this headline">¶</a></h4>

<p><tt>cAbstractLineFigure</tt> is the common base class for various line
figures, providing line color, style, width, opacity, arrowhead and other
properties for them.

<p>Line color can be set with <tt>setLineColor()</tt>, and line width with
<tt>setLineWidth()</tt>. Lines can be solid, dashed, dotted, etc.; line
style can be set with <tt>setLineStyle()</tt>. The default line color is
black.

<p>Lines can be partially transparent. This property can be controlled with
<tt>setLineOpacity()</tt> that takes a <tt>double</tt> between 0 and 1: a zero
argument means fully transparent, and one means fully opaque.

<p>Lines can have various cap styles: butt, square, round, etc., which can be
selected with <tt>setCapStyle()</tt>. Join style, which is a related
property, is not part of <tt>cAbstractLineFigure</tt> but instead added to
specific subclasses where it makes sense.

<p>Lines may also be augmented with arrowheads at either or both ends.
Arrowheads can be selected with <tt>setStartArrowhead()</tt> and
<tt>setEndArrowhead()</tt>.

<p>Transformations such as scaling or skew do affect the width of the line as it
is rendered on the canvas. Whether zooming (by the user) should also affect
it can be controlled by setting a flag (<tt>setZoomLineWidth()</tt>).
The default is non-zooming lines.

<p>Specifying zero for line width is currently not allowed. To hide the line,
use <tt>setVisible(false)</tt>.<br><ul><font size=-1>[It would make sense to display
zero-width lines as hairlines that are always rendered as one pixel wide
regardless of transforms and zoom level, but that is not possible on all
platforms.]</font></ul>

<p>
<h4><a name="sec:graphics:linefigure"/>8.6.11.2 cLineFigure<a class="headerlink" href="#sec:graphics:linefigure" title="Permalink to this headline">¶</a></h4>

<p><tt>cLineFigure</tt> displays a single straight line segment. The endpoints
of the line can be set with the <tt>setStart()</tt>/<tt>setEnd()</tt>
methods. Other properties such as color and line style are inherited from
<tt>cAbstractLineFigure</tt>.

<p>An example that draws an arrow from (0,0) to (100,100):

<pre class="cpp">
cLineFigure *line = new cLineFigure("line");
line-&gt;setStart(cFigure::Point(0,0));
line-&gt;setEnd(cFigure::Point(100,50));
line-&gt;setLineWidth(2);
line-&gt;setEndArrowhead(cFigure::ARROW_BARBED);
</pre>
<p>
The result:

<p><center>
<img src="figure-line.svg">
</center>

<p>
<h4><a name="sec:graphics:arcfigure"/>8.6.11.3 cArcFigure<a class="headerlink" href="#sec:graphics:arcfigure" title="Permalink to this headline">¶</a></h4>

<p><tt>cArcFigure</tt> displays an axis-aligned arc. (To display a
non-axis-aligned arc, apply a transform to <tt>cArcFigure</tt>, or use
<tt>cPathFigure</tt>.) The arc's geometry is determined by the bounding box
of the circle or ellipse, and a start and end angle; they can be set with
the <tt>setBounds()</tt>, <tt>setStartAngle()</tt> and <tt>setEndAngle()</tt>
methods. Other properties such as color and line style are inherited from
<tt>cAbstractLineFigure</tt>.

<p>For angles, zero points east. Angles that go counterclockwise are
positive, and those that go clockwise are negative.

<p><ul class="note"><b>NOTE</b><br>
Angles are in radians in the C++ API, but in degrees when the figure is
defined in the NED file via <b><tt>@figure</tt></b>.
</ul>

<p>Here is an example that draws a blue arc with an arrowhead that goes
counter-clockwise from 3 hours to 12 hours on the clock:

<pre class="cpp">
cArcFigure *arc = new cArcFigure("arc");
arc-&gt;setBounds(cFigure::Rectangle(10,10,100,100));
arc-&gt;setStartAngle(0);
arc-&gt;setEndAngle(M_PI/2);
arc-&gt;setLineColor(cFigure::BLUE);
arc-&gt;setEndArrowhead(cFigure::ARROW_BARBED);
</pre>
<p>

The result:

<p><center>
<img src="figure-arc.svg">
</center>

<p>
<h4><a name="sec:graphics:polylinefigure"/>8.6.11.4 cPolylineFigure<a class="headerlink" href="#sec:graphics:polylinefigure" title="Permalink to this headline">¶</a></h4>

<p>By default, <tt>cPolylineFigure</tt> displays multiple connecting straight
line segments. The class stores geometry information as a sequence of
points. The line may be <i>smoothed</i>, so the figure can also display
complex curves.

<p>The points can be set with <tt>setPoints()</tt> that takes <tt>std::vector&lt;Point&gt;</tt>,
or added one-by-one using <tt>addPoint()</tt>. Elements in the point list can be
read and overwritten (<tt>getPoint()</tt>, <tt>setPoint()</tt>). One can also
insert and remove points (<tt>insertPoint()</tt> and <tt>removePoint()</tt>.

<p>A smoothed line is drawn as a series of Bezier curves, which touch the
start point of the first line segment, the end point of the last line
segment, and the midpoints of intermediate line segments, while
intermediate points serve as control points. Smoothing can be turned on/off
using <tt>setSmooth()</tt>.

<p>Additional properties such as color and line style are inherited from
<tt>cAbstractLineFigure</tt>. Line join style (which is not part of
<tt>cAbstractLineFigure</tt>) can be set with <tt>setJoinStyle()</tt>.

<p>Here is an example that uses a smoothed polyline to draw a spiral:

<pre class="cpp">
cPolylineFigure *polyline = new cPolylineFigure("polyline");
const double C = 1.1;
for (int i = 0; i &lt; 10; i++)
    polyline-&gt;addPoint(cFigure::Point(5*i*cos(C*i), 5*i*sin(C*i)));
polyline-&gt;move(100, 100);
polyline-&gt;setSmooth(true);
</pre>
<p>

The result, with both <i>smooth=false</i> and <i>smooth=true</i>:

<p><center>
<img src="figure-polylines.svg">
</center>

<p>
<h4><a name="sec:graphics:abstractshapefigure"/>8.6.11.5 cAbstractShapeFigure<a class="headerlink" href="#sec:graphics:abstractshapefigure" title="Permalink to this headline">¶</a></h4>

<p><tt>cAbstractShapeFigure</tt> is an abstract base class for various shapes,
providing line and fill color, line and fill opacity, line style, line
width, and other properties for them.

<p>Both outline and fill are optional, they can be turned on and off
independently with the <tt>setOutlined()</tt> and <tt>setFilled()</tt>
methods. The default is outlined but unfilled shapes.

<p>Similar to <tt>cAbstractLineFigure</tt>, line color can be set with
<tt>setLineColor()</tt>, and line width with <tt>setLineWidth()</tt>.
Lines can be solid, dashed, dotted, etc.; line style can be set with
<tt>setLineStyle()</tt>. The default line color is black.

<p>Fill color can be set with <tt>setFillColor()</tt>. The default fill color
is blue (although it is indifferent until one calls <tt>setFilled(true)</tt>).

<p><ul class="note"><b>NOTE</b><br>
Invoking <tt>setFillColor()</tt> alone does not make the shape filled,
one also needs to call <tt>setFilled(true)</tt> for that.
</ul>

<p>Shapes can be partially transparent, and opacity can be set individually
for the outline and the fill, using <tt>setLineOpacity()</tt> and
<tt>setFillOpacity()</tt>. These functions accept a <tt>double</tt> between 0
and 1: a zero argument means fully transparent, and one means fully opaque.

<p>When the outline is drawn with a width larger than one pixel, it will be
drawn symmetrically, i.e. approximately 50-50% of its width will fall
inside and outside the shape. (This also means that the fill and a wide
outline will partially overlap, but that is only apparent if the
outline is also partially transparent.)

<p>Transformations such as scaling or skew do affect the width of the line as it
is rendered on the canvas. Whether zooming (by the user) should also affect
it can be controlled by setting a flag (<tt>setZoomLineWidth()</tt>).
The default is non-zooming lines.

<p>Specifying zero for line width is currently not allowed. To hide the outline,
<tt>setOutlined(false)</tt> can be used.

<p>
<h4><a name="sec:graphics:rectanglefigure"/>8.6.11.6 cRectangleFigure<a class="headerlink" href="#sec:graphics:rectanglefigure" title="Permalink to this headline">¶</a></h4>

<p><tt>cRectangleFigure</tt> displays an axis-aligned rectangle with
optionally rounded corners. As with all shape figures, drawing of both the
outline and the fill are optional. Line and fill color, and several other
properties are inherited from <tt>cAbstractShapeFigure</tt>.

<p>The figure's geometry can be set with the <tt>setBounds()</tt> method that
takes a <tt>cFigure::Rectangle</tt>. The radii for the rounded corners can
be set independently for the <i>x</i> and <i>y</i> direction using
<tt>setCornerRx()</tt> and <tt>setCornerRy()</tt>, or together with
<tt>setCornerRadius()</tt>.

<p>The following example draws a rounded rectangle of size 160x100, filled with
a "good dark color".

<pre class="cpp">
cRectangleFigure *rect = new cRectangleFigure("rect");
rect-&gt;setBounds(cFigure::Rectangle(100,100,160,100));
rect-&gt;setCornerRadius(5);
rect-&gt;setFilled(true);
rect-&gt;setFillColor(cFigure::GOOD_LIGHT_COLORS[0]);
</pre>
<p>

The result:

<p><center>
<img src="figure-rectangle.svg">
</center>

<p>
<h4><a name="sec:graphics:ovalfigure"/>8.6.11.7 cOvalFigure<a class="headerlink" href="#sec:graphics:ovalfigure" title="Permalink to this headline">¶</a></h4>

<p><tt>cOvalFigure</tt> displays a circle or an axis-aligned ellipse. As with
all shape figures, drawing of both the outline and the fill are optional.
Line and fill color, and several other properties are inherited from
<tt>cAbstractShapeFigure</tt>.

<p>The geometry is specified with the bounding box, and it can be set with the
<tt>setBounds()</tt> method that takes a <tt>cFigure::Rectangle</tt>.

<p>The following example draws a circle of diameter 120 with a wide dotted line.

<pre class="cpp">
cOvalFigure *circle = new cOvalFigure("circle");
circle-&gt;setBounds(cFigure::Rectangle(100,100,120,120));
circle-&gt;setLineWidth(2);
circle-&gt;setLineStyle(cFigure::LINE_DOTTED);
</pre>
<p>

The result:

<p><center>
<img src="figure-oval.svg">
</center>

<p>
<h4><a name="sec:graphics:ringfigure"/>8.6.11.8 cRingFigure<a class="headerlink" href="#sec:graphics:ringfigure" title="Permalink to this headline">¶</a></h4>

<p><tt>cRingFigure</tt> displays a ring, with explicitly controllable
inner/outer radii. The inner and outer circles (or ellipses) form the
outline, and the area between them is filled. As with all shape figures,
drawing of both the outline and the fill are optional. Line and fill color,
and several other properties are inherited from
<tt>cAbstractShapeFigure</tt>.

<p>The geometry is determined by the bounding box that defines the outer
circle, and the <i>x</i> and <i>y</i> radii of the inner oval. They can be set with
the <tt>setBounds()</tt>, <tt>setInnerRx()</tt> and <tt>setInnerRy()</tt>
member functions. There is also a utility method for setting both
inner radii together, named <tt>setInnerRadius()</tt>.

<p>The following example draws a ring with an outer diameter of 50 and
inner diameter of 20.

<pre class="cpp">
cRingFigure *ring = new cRingFigure("ring");
ring-&gt;setBounds(cFigure::Rectangle(100,100,50,50));
ring-&gt;setInnerRadius(10);
ring-&gt;setFilled(true);
ring-&gt;setFillColor(cFigure::YELLOW);
</pre>
<p>

<center>
<img src="figure-ring.svg">
</center>

<p>
<h4><a name="sec:graphics:pieslicefigure"/>8.6.11.9 cPieSliceFigure<a class="headerlink" href="#sec:graphics:pieslicefigure" title="Permalink to this headline">¶</a></h4>

<p><tt>cPieSliceFigure</tt> displays a pie slice, that is, a section of an
axis-aligned disc or filled ellipse.  The outline of the pie slice consists
of an arc and two radii. As with all shape figures, drawing of both the
outline and the fill are optional.

<p>Similar to an arc, a pie slice is determined by the bounding box of the
full disc or ellipse, and a start and an end angle. They can be set with
the <tt>setBounds()</tt>, <tt>setStartAngle()</tt> and <tt>setEndAngle()</tt>
methods.

<p>For angles, zero points east. Angles that go counterclockwise are
positive, and those that go clockwise are negative.

<p><ul class="note"><b>NOTE</b><br>
Angles are in radians in the C++ API, but in degrees when the figure is
defined in the NED file via <b><tt>@figure</tt></b>.
</ul>

<p>Line and fill color, and several other properties are inherited from
<tt>cAbstractShapeFigure</tt>.

<p>The following example draws pie slice that's one third of a whole pie:

<pre class="cpp">
cPieSliceFigure *pieslice = new cPieSliceFigure("pieslice");
pieslice-&gt;setBounds(cFigure::Rectangle(100,100,100,100));
pieslice-&gt;setStartAngle(0);
pieslice-&gt;setEndAngle(2*M_PI/3);
pieslice-&gt;setFilled(true);
pieslice-&gt;setLineColor(cFigure::BLUE);
pieslice-&gt;setFillColor(cFigure::YELLOW);
</pre>
<p>

The result:

<p><center>
<img src="figure-pieslice.svg">
</center>

<p>
<h4><a name="sec:graphics:polygonfigure"/>8.6.11.10 cPolygonFigure<a class="headerlink" href="#sec:graphics:polygonfigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cPolygonFigure</tt> displays a closed polygon, which is determined by a sequence of points.
The polygon can be <i>smoothed</i>. A smoothed polygon is drawn as a series
of cubic Bezier curves, where the curves touch the midpoints of the sides,
and the vertices serve as control points. Smoothing can be turned on/off
using the <tt>setSmooth()</tt> method.

<p>The points can be set using the <tt>setPoints()</tt> method, which takes a <tt>std::vector&lt;Point&gt;</tt>,
or added one-by-one using the <tt>addPoint()</tt> method. Elements in the point list can be
read and overwritten using the <tt>getPoint()</tt> and <tt>setPoint()</tt> methods. One can also
insert and remove points using the <tt>insertPoint()</tt> and <tt>removePoint()</tt> methods.

<p>Like all shape figures, the outline and the fill of the polygon can be optionally drawn.
The drawing of filled self-intersecting polygons is controlled
by the fill rule, which defaults to even-odd (<tt>FILL_EVENODD</tt>), and
can be set using the <tt>setFillRule()</tt> method. The line join style can be set using
the <tt>setJoinStyle()</tt> method.

<p>Line and fill color, and several other properties are inherited from
the <tt>cAbstractShapeFigure</tt>.

<p>Here is an example of a smoothed polygon that also demonstrates
the use of the <tt>setPoints()</tt> method:

<pre class="cpp">
cPolygonFigure *polygon = new cPolygonFigure("polygon");
std::vector&lt;cFigure::Point&gt; points;
points.push_back(cFigure::Point(0, 100));
points.push_back(cFigure::Point(50, 100));
points.push_back(cFigure::Point(100, 100));
points.push_back(cFigure::Point(50, 50));
polygon-&gt;setPoints(points);
polygon-&gt;setLineColor(cFigure::BLUE);
polygon-&gt;setLineWidth(3);
polygon-&gt;setSmooth(true);
</pre>
<p>

The result, with both <i>smooth=false</i> and <i>smooth=true</i>:

<p><center>
<img src="figure-polygons.svg">
</center>

<p>
<h4><a name="sec:graphics:pathfigure"/>8.6.11.11 cPathFigure<a class="headerlink" href="#sec:graphics:pathfigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cPathFigure</tt> displays a &#8220;path&#8221;, which is a complex shape or line modeled after SVG
paths. A path may consist of any number of straight line segments, Bezier
curves, and arcs. The path can be disjoint as well. Closed paths may be filled.
The drawing of filled self-intersecting polygons is controlled by the
<i>fill rule</i> property. Line and fill color, and several other properties
are inherited from <tt>cAbstractShapeFigure</tt>.

<p>A path, when given as a string, looks like this one that draws a triangle:

<p><i>M 150 0 L 75 200 L 225 200 Z</i>

<p>It consists of a sequence of commands (<i>M</i> for <i>moveto</i>,
<i>L</i> for <i>lineto</i>, etc.) that are each followed by numeric
parameters (except <i>Z</i>). All commands can be expressed with
lowercase letters, too. A capital letter means that the target point is
given with <i>absolute</i> coordinates, while a lowercase letter means they are
given <i>relative</i> to the target point of the previous command.

<p>The <tt>cPathFigure</tt> can accept the path in string form (<tt>setPath()</tt>),
or one can assemble the path with a series of method calls like
<tt>addMoveTo()</tt>. The path can be cleared with the <tt>clearPath()</tt>
method.

<p>The commands with argument lists and the corresponding <i>add</i> methods are:

<p><ul>
<li> <b>M</b> <i>x y</i>: move; <tt>addMoveTo()</tt>, <tt>addMoveRel()</tt>
<li> <b>L</b> <i>x y</i>: line; <tt>addLineTo()</tt>, <tt>addLineRel()</tt>
<li> <b>H</b> <i>x</i>: horizontal line; <tt>addHorizontalLineTo()</tt>, <tt>addHorizontalLineRel()</tt>
<li> <b>V</b> <i>y</i>: vertical line; <tt>addVerticalLineTo()</tt>, <tt>addVerticalLineRel()</tt>
<li> <b>A</b> <i>rx ry phi largeArc sweep x y</i>: arc; <tt>addArcTo()</tt>, <tt>addArcRel()</tt>
<li> <b>Q</b> <i>x1 y1 x y</i>: curve; <tt>addCurveTo()</tt>, <tt>addCurveRel()</tt>
<li> <b>T</b> <i>x y</i>: smooth curve; <tt>addSmoothCurveTo()</tt>, <tt>addSmoothCurveRel()</tt>
<li> <b>C</b> <i>x1 y1 x2 y2 x y</i>: cubic Bezier curve; <tt>addCubicBezierCurveTo()</tt>, <tt>addCubicBezierCurveRel()</tt>
<li> <b>S</b> <i>x1 y1 x y</i>: smooth cubic Bezier curve; <tt>addSmoothCubicBezierCurveTo()</tt>, <tt>addSmoothCubicBezierCurveRel()</tt>
<li> <b>Z</b>: close path; <tt>addClosePath()</tt>
</ul>

<p>In the parameter lists, <i>(x,y)</i> are the target points (substitute <i>(dx,dy)</i> for
the lowercase, relative versions.) For the Bezier curves, <i>x1,y1</i> and
<i>(x2,y2)</i> are the control points. For the arc, <i>rx</i> and <i>ry</i> are the radii of the
ellipse, <i>phi</i> is a rotation angle in degrees for the ellipse, and
<i>largeArc</i> and <i>sweep</i> are both booleans (0 or 1) that select which portion
of the ellipse should be taken.<br><ul><font size=-1>[For more details, consult the SVG
specification.]</font></ul>

<p>No matter how the path was created, the string form can be obtained with the
<tt>getPath()</tt> method, and the parsed form with the <tt>getNumPathItems()</tt>,
and <tt>getPathItem(k)</tt> methods. The latter returns a pointer to a
<tt>cPathFigure::PathItem</tt>, which is a base class with subclasses for every
item type.

<p>The line join style, cap style (for open subpaths), and fill rule (for closed
subpaths) can be set with the <tt>setJoinStyle()</tt>,
<tt>setCapStyle()</tt>, and <tt>setFillRule()</tt> methods.

<p>The <tt>cPathFigure</tt> has one more property, an <i>(dx,dy)</i> offset, which
exists to simplify the implementation of the <tt>move()</tt> method. The offset
causes the figure to be translated by the given amount for drawing. For
other figure types, <tt>move()</tt> directly updates the coordinates, so it
is effectively a wrapper for <tt>setPosition()</tt> or <tt>setBounds()</tt>.
For path figures, implementing <tt>move()</tt> so that it updates every path
item would be cumbersome and potentially also confusing for users. Instead,
<tt>move()</tt> updates the offset. The offset can be set with
<tt>setOffset()</tt>.

<p>In the first example, the path is given as a string:

<p>
<pre class="cpp">
cPathFigure *path = new cPathFigure("path");
path-&gt;setPath("M 0 150 L 50 50 Q 20 120 100 150 Z");
path-&gt;setFilled(true);
path-&gt;setLineColor(cFigure::BLUE);
path-&gt;setFillColor(cFigure::YELLOW);
</pre>

<p>
The second example creates the equivalent path programmatically.

<pre class="cpp">
cPathFigure *path2 = new cPathFigure("path");
path2-&gt;addMoveTo(0,150);
path2-&gt;addLineTo(50,50);
path2-&gt;addCurveTo(20,120,100,150);
path2-&gt;addClosePath();
path2-&gt;setFilled(true);
path2-&gt;setLineColor(cFigure::BLUE);
path2-&gt;setFillColor(cFigure::YELLOW);
</pre>
<p>

The result:

<p><center>
<img src="figure-path.svg">
</center>

<p><h4><a name="sec:graphics:abstracttextfigure"/>8.6.11.12 cAbstractTextFigure<a class="headerlink" href="#sec:graphics:abstracttextfigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cAbstractTextFigure</tt> is an abstract base class for figures that
display potentially multi-line text.

<p>The location of the text on the canvas is determined jointly by a
<i>position</i> and an <i>anchor</i>. The anchor tells how to
place the text relative to the positioning point. For example,
if the anchor is <tt>ANCHOR_CENTER</tt>, then the text is centered on the point;
if the anchor is <tt>ANCHOR_N</tt>, then the text will be drawn so that its top
center point is at the positioning point. The values
<tt>ANCHOR_BASELINE_START</tt>, <tt>ANCHOR_BASELINE_MIDDLE</tt>,
<tt>ANCHOR_BASELINE_END</tt> refer to the beginning, middle, and end of the
baseline of the first line of the text as an anchor point. The member
functions to set the positioning point and the anchor are
<tt>setPosition()</tt> and <tt>setAnchor()</tt>. The anchor defaults to
<tt>ANCHOR_CENTER</tt>.

<p>The font can be set with the <tt>setFont()</tt> member function, which takes
<tt>cFigure::Font</tt>, a class that encapsulates typeface, font style, and
size. The color can be set with <tt>setColor()</tt>. The displayed text can
also be partially transparent. This is controlled with the <tt>setOpacity()</tt>
member function, which accepts a <tt>double</tt> in the range of <i>[0,1]</i>, where <i>0</i> means
fully transparent (invisible), and <i>1</i> means fully opaque.

<p>It is also possible to have a partially transparent &#8220;halo&#8221; displayed around
the text. The halo improves readability when the text is displayed over a
background that has a similar color to the text or when it overlaps with other
text items. The halo can be turned on with <tt>setHalo()</tt>.

<p>
<h4><a name="sec:graphics:textfigure"/>8.6.11.13 cTextFigure<a class="headerlink" href="#sec:graphics:textfigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cTextFigure</tt> displays text which is affected by zooming and
transformations. The font, color, position, anchoring, and other properties are
inherited from <tt>cAbstractTextFigure</tt>.

<p>The following example displays a text in dark blue with a font size of 12 points
in bold Arial font.

<pre class="cpp">
cTextFigure *text = new cTextFigure("text");
text-&gt;setText("This is some text.");
text-&gt;setPosition(cFigure::Point(100,100));
text-&gt;setAnchor(cFigure::ANCHOR_BASELINE_MIDDLE);
text-&gt;setColor(cFigure::Color("#000040"));
text-&gt;setFont(cFigure::Font("Arial", 12, cFigure::FONT_BOLD));
</pre>
<p>

The result:

<p><center>
<img src="figure-text.svg">
</center>

<p>
<h4><a name="sec:graphics:labelfigure"/>8.6.11.14 cLabelFigure<a class="headerlink" href="#sec:graphics:labelfigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cLabelFigure</tt> displays text that is unaffected by zooming or
transformations, except its position. The font, color, position, anchoring, and
other properties are inherited from <tt>cAbstractTextFigure</tt>. The angle of
the label can be set with the <tt>setAngle()</tt> method. A zero angle means
horizontal (unrotated) text. Positive values rotate the text counterclockwise,
while negative values rotate the text clockwise.

<p><ul class="note"><b>NOTE</b><br>
Angles are in radians in the C++ API but in degrees when the figure is defined
in the NED file via <b><tt>@figure</tt></b>.
</ul>

<p>The following example displays a label in Courier New with the default size, slightly transparent.

<pre class="cpp">
cLabelFigure *label = new cLabelFigure("label");
label-&gt;setText("This is a label.");
label-&gt;setPosition(cFigure::Point(100,100));
label-&gt;setAnchor(cFigure::ANCHOR_NW);
label-&gt;setFont(cFigure::Font("Courier New"));
label-&gt;setOpacity(0.9);
</pre>
<p>

The result:

<p><center>
<img src="figure-label.svg">
</center>

<p>
<h4><a name="sec:graphics:abstractimagefigure"/>8.6.11.15 cAbstractImageFigure<a class="headerlink" href="#sec:graphics:abstractimagefigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cAbstractImageFigure</tt> is an abstract base class for image figures.

<p>The location of the image on the canvas is determined jointly by a
<i>position</i> and an <i>anchor</i>. The anchor tells how to
place the image relative to the positioning point. For example,
if the anchor is <tt>ANCHOR_CENTER</tt>, the image is centered on the point;
if the anchor is <tt>ANCHOR_N</tt>, the image will be drawn so that its top
center point is at the positioning point. The member functions to set the
positioning point and the anchor are <tt>setPosition()</tt> and
<tt>setAnchor()</tt>. The anchor defaults to <tt>ANCHOR_CENTER</tt>.

<p>By default, the figure's width and height will be taken from the image's
dimensions in pixels. This can be overridden with the <tt>setWidth()</tt> and
<tt>setHeight()</tt> methods, causing the image to be scaled. Using
<tt>setWidth(0)</tt> or <tt>setHeight(0)</tt> will reset the default (automatic) width
and height.

<p>One can choose from several interpolation modes that control how the image
is rendered when it is not drawn in its natural size. The interpolation mode
can be set with the <tt>setInterpolation()</tt> method, which defaults to
<tt>INTERPOLATION_FAST</tt>.

<p>Images can be tinted; this feature is controlled by a tint color and a tint
amount, which is a real number in the range of <i>[0,1]</i>. They can be set with the
<tt>setTintColor()</tt> and <tt>setTintAmount()</tt> methods, respectively.

<p>Images may also be partially transparent, which is controlled by the opacity
property, which is also a real number in the range of <i>[0,1]</i>. Opacity can be set with the
<tt>setOpacity()</tt> method. The rendering process will combine this
property with the transparency information contained within the image, i.e.
the alpha channel.

<p>
<h4><a name="sec:graphics:imagefigure"/>8.6.11.16 cImageFigure<a class="headerlink" href="#sec:graphics:imagefigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cImageFigure</tt> displays an image, typically an icon or a background
image, loaded from the OMNeT++ image path. Positioning and other properties
are inherited from <tt>cAbstractImageFigure</tt>. Unlike <tt>cIconFigure</tt>,
the <tt>cImageFigure</tt> fully obeys transforms and zoom.

<p>The following example displays a map:

<pre class="cpp">
cImageFigure *image = new cImageFigure("map");
image-&gt;setPosition(cFigure::Point(0,0));
image-&gt;setAnchor(cFigure::ANCHOR_NW);
image-&gt;setImageName("maps/europe");
image-&gt;setWidth(600);
image-&gt;setHeight(500);
</pre>
<p>


<p><h4><a name="sec:graphics:iconfigure"/>8.6.11.17 cIconFigure<a class="headerlink" href="#sec:graphics:iconfigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cIconFigure</tt> displays a non-zooming image, loaded from the OMNeT++
image path. Positioning and other properties are inherited from
<tt>cAbstractImageFigure</tt>.

<p>The <tt>cIconFigure</tt> is not affected by transforms or zoom, except its
position. It can still be resized, though, via the <tt>setWidth()</tt> and
<tt>setHeight()</tt> methods.

<p>The following example displays an icon similar to the way the
<tt>"i=block/sink,gold,30"</tt> display string tag would, and makes it slightly
transparent:

<pre class="cpp">
cIconFigure *icon = new cIconFigure("icon");
icon-&gt;setPosition(cFigure::Point(100,100));
icon-&gt;setImageName("block/sink");
icon-&gt;setTintColor(cFigure::Color("gold"));
icon-&gt;setTintAmount(0.6);
icon-&gt;setOpacity(0.8);
</pre>
<p>

The result:

<p><center>
<img src="figure-icon.png">
</center>

<p>
<h4><a name="sec:graphics:pixmapfigure"/>8.6.11.18 cPixmapFigure<a class="headerlink" href="#sec:graphics:pixmapfigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cPixmapFigure</tt> displays a user-defined raster image. A pixmap
figure may be used to display e.g. a heat map. Support for scaling and
various interpolation modes are useful here. Positioning and other
properties are inherited from <tt>cAbstractImageFigure</tt>.

<p>A pixmap itself is represented by the <tt>cFigure::Pixmap</tt> class.

<p>The <tt>cFigure::Pixmap</tt> stores a rectangular array of 32-bit RGBA pixels,
and allows pixels to be manipulated directly. The size ($width x
height$) as well as the default fill can be specified in the constructor.
The pixmap can be resized (i.e. pixels added/removed at the right and/or bottom)
using <tt>setSize()</tt>, and it can be filled with a color using <tt>fill()</tt>.
Pixels can be directly accessed using <tt>pixel(x,y)</tt>.

<p>A pixel is returned as type <tt>cFigure::RGBA</tt>, which is a convenience
struct that, in addition to having the four public <tt>uint8_t</tt> fields
(<tt>red</tt>, <tt>green</tt>, <tt>blue</tt>, <tt>alpha</tt>), is augmented with several
utility methods.

<p>Many <tt>Pixmap</tt> and <tt>RGBA</tt> methods accept or return
<tt>cFigure::Color</tt> and opacity, converting between them and
<tt>RGBA</tt>. (Opacity is a <i>[0,1]</i> real number that is mapped to the
0..255 alpha channel. <i>0</i> means fully transparent, and <i>1</i> means fully
opaque.)

<p>One can set up and manipulate the image that <tt>cPixmapFigure</tt> displays
in two ways. First, one can create and fill a <tt>cFigure::Pixmap</tt>
separately, and set it on <tt>cPixmapFigure</tt> using <tt>setPixmap()</tt>.
This will overwrite the figure's internal pixmap instance that it displays.
The second way is to utilize <tt>cPixmapFigure</tt>'s methods such as
<tt>setPixmapSize()</tt>, <tt>fill()</tt>, <tt>setPixel()</tt>,
<tt>setPixelColor()</tt>, <tt>setPixelOpacity()</tt>, etc. that delegate to
the internal pixmap instance.

<p>The following example displays a small heat map by manipulating the
transparency of the pixels. The 9-by-9 pixel image is stretched to
100 units each direction on the screen.

<pre class="cpp">
cPixmapFigure *pixmapFigure = new cPixmapFigure("pixmap");
pixmapFigure-&gt;setPosition(cFigure::Point(100,100));
pixmapFigure-&gt;setSize(100, 100);
pixmapFigure-&gt;setPixmapSize(9, 9, cFigure::BLUE, 1);
for (int y = 0; y &lt; pixmapFigure-&gt;getPixmapHeight(); y++) {
    for (int x = 0; x &lt; pixmapFigure-&gt;getPixmapWidth(); x++) {
        double opacity = 1 - sqrt((x-4)*(x-4) + (y-4)*(y-4))/4;
        if (opacity &lt; 0) opacity = 0;
        pixmapFigure-&gt;setPixelOpacity(x, y, opacity);
    }
}
pixmapFigure-&gt;setInterpolation(cFigure::INTERPOLATION_FAST);
</pre>
<p>

The result, both with <i>interpolation=NONE</i> and <i>interpolation=FAST</i>:

<p><center>
<img src="figure-pixmaps.png">
</center>

<p>
<h4><a name="sec:graphics:groupfigure"/>8.6.11.19 cGroupFigure<a class="headerlink" href="#sec:graphics:groupfigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cGroupFigure</tt> is for the sole purpose of grouping its children. It
has no visual appearance. The usefulness of a group figure comes from the
fact that elements of a group can be hidden or shown together, and also
transformations are inherited from parent to child. Thus, children of a
group can be moved, scaled, rotated, etc. together by updating the group's
transformation matrix.

<p>The following example creates a group with two subfigures, then moves and
rotates them as one unit.

<pre class="cpp">
cGroupFigure *group = new cGroupFigure("group");

cRectangleFigure *rect = new cRectangleFigure("rect");
rect-&gt;setBounds(cFigure::Rectangle(-50,0,100,40));
rect-&gt;setCornerRadius(5);
rect-&gt;setFilled(true);
rect-&gt;setFillColor(cFigure::YELLOW);

cLineFigure *line = new cLineFigure("line");
line-&gt;setStart(cFigure::Point(-80,50));
line-&gt;setEnd(cFigure::Point(80,50));
line-&gt;setLineWidth(3);

group-&gt;addFigure(rect);
group-&gt;addFigure(line);
group-&gt;translate(100, 100);
group-&gt;rotate(M_PI/6, 100, 100);
</pre>
<p>

The result:

<p><center>
<img src="figure-group.svg">
</center>

<p>
<h4><a name="sec:graphics:panelfigure"/>8.6.11.20 cPanelFigure<a class="headerlink" href="#sec:graphics:panelfigure" title="Permalink to this headline">¶</a></h4>

<p>The <tt>cPanelFigure</tt> is similar to <tt>cGroupFigure</tt> in that it is also
intended for grouping its children and has no visual appearance of its own.
However, it has a special behavior regarding transformations and especially zooming.

<p>The <tt>cPanelFigure</tt> sets up an axis-aligned, unscaled coordinate system for
its children, canceling the effect of any transformation (scaling, rotation,
etc.) inherited from ancestor figures. This allows for pixel-based positioning
of children and makes them immune to zooming.

<p>Unlike <tt>cGroupFigure</tt>, which has its own position attribute,
<tt>cPanelFigure</tt> uses two points for positioning, a <i>position</i> and
an <i>anchor point</i>. The position is interpreted in the coordinate system of
the panel figure's parent, while the anchor point is interpreted in the
coordinate system of the panel figure itself. To place the panel figure on the
canvas, the panel's anchor point is mapped to the position in the parent.

<p>Setting a transformation on the panel figure itself allows for rotation,
scaling, and skewing of its children. The anchor point is also affected by this
transformation.

<p>The following example demonstrates the <tt>cPanelFigure</tt> behavior. It
creates a normal group figure as the parent for the panel and sets up a
skewed coordinate system on it. A reference image is also added to it,
to make the effect of skew visible. The panel figure is also
added to it as a child. The panel contains an image (showing the same icon
as the reference image) and a border around it.

<pre class="cpp">
cGroupFigure *layer = new cGroupFigure("parent");
layer-&gt;skewx(-0.3);

cImageFigure *referenceImg = new cImageFigure("ref");
referenceImg-&gt;setImageName("block/broadcast");
referenceImg-&gt;setPosition(cFigure::Point(200,200));
referenceImg-&gt;setOpacity(0.3);
layer-&gt;addFigure(referenceImg);

cPanelFigure *panel = new cPanelFigure("panel");

cImageFigure *img = new cImageFigure("img");
img-&gt;setImageName("block/broadcast");
img-&gt;setPosition(cFigure::Point(0,0));
panel-&gt;addFigure(img);

cRectangleFigure *border = new cRectangleFigure("border");
border-&gt;setBounds(cFigure::Rectangle(-25,-25,50,50));
border-&gt;setLineWidth(3);
panel-&gt;addFigure(border);

layer-&gt;addFigure(panel);
panel-&gt;setAnchorPoint(cFigure::Point(0,0));
panel-&gt;setPosition(cFigure::Point(210,200));
</pre>
<p>

The screenshot shows the result at an approximate 4x zoom level. The large
semi-transparent image is the reference image, and the smaller one is the image within the panel
figure. Note that neither the skew nor the zoom has affected the panel figure's children.

<p><center>
<img src="figure-panel.svg">
</center>

<p>
<h3><a name="sec:graphics:compound-figures"/>8.6.12 Compound Figures<a class="headerlink" href="#sec:graphics:compound-figures" title="Permalink to this headline">¶</a></h3>

<p>Any graphics can be built using primitive (i.e., elementary) figures
alone. However, when the graphical presentation of a simulation
grows complex, it is often convenient to be able to group certain
figures and treat them as a single unit. For example, although
a bar chart can be displayed using several independent rectangles,
lines, and text items, there are clear benefits to being able to
handle them together as a single bar chart object.

<p><i>Compound figures</i> are <tt>cFigure</tt> subclasses that
are made up of several figures themselves, but can be instantiated
and manipulated as a single figure. Compound figure classes
can be used from C++ code like normal figures, and can also
be instantiated from <b><tt>@figure</tt></b> properties.

<p>Compound figure classes usually subclass from <tt>cGroupFigure</tt>.
The class would typically maintain pointers to its subfigures in
class members and have methods (getters, setters, etc.) that operate
on the subfigures.

<p>To enable the new C++ class to be used with <b><tt>@figure</tt></b>,
it needs to be registered using the <tt>Register_Figure()</tt> macro.
The macro takes two arguments: the type name by which the figure
is known to <b><tt>@figure</tt></b> (the string to be used with the <tt>type</tt> property key),
and the C++ class name. For example, if you want to instantiate
a class named <tt>FooFigure</tt> with <tt>@figure[...](type=foo;...)</tt>,
you need to add the following line to the C++ source:

<pre class="cpp">
Register_Figure("foo", FooFigure);
</pre>
<p>
If the figure should be able to take values from <b><tt>@figure</tt></b> properties,
the class needs to override the <tt>parse(cProperty*)</tt> method,
and possibly also <tt>getAllowedPropertyKeys()</tt>. We recommend
examining the code of the figure classes built into OMNeT++ for
implementation hints.

<p>

<p><h3><a name="sec:graphics:self-refreshing-figures"/>8.6.13 Self-Refreshing Figures<a class="headerlink" href="#sec:graphics:self-refreshing-figures" title="Permalink to this headline">¶</a></h3>

<p>Most figures are entirely passive objects. When they need to be moved
or updated during the course of the simulation, there must be an
active component in the simulation that does it for them. Usually, it is the
<tt>refreshDisplay()</tt> method of some simple module (or modules) that
contain the code that updates various properties of the figures.

<p>However, certain figures can benefit from being able to refresh themselves
during the simulation. For example, consider a compound figure (see
previous section) that displays a line chart, which is continually
updated with new data as the simulation progresses. The <tt>LineChartFigure</tt>
class may contain an <tt>addDataPoint(x,y)</tt> method, which is called
from other parts of the simulation to add new data to the chart.
The question is when to update the subfigures that make up the chart: the
lines, axis ticks and labels, etc. It is clearly not very efficient
to do it in every <tt>addDataPoint(x,y)</tt> call, especially when the
simulation is running in Express mode when the screen is not refreshed
very often. Luckily, our hypothetical <tt>LineChartFigure</tt> class
can do better and only refresh its subfigures when it matters, i.e.,
when the result can actually be seen in the GUI. To do that, the class
needs to override <tt>cFigure</tt>'s <tt>refreshDisplay()</tt> method and
place the subfigure updating code there.

<p>Figure classes that override <tt>refreshDisplay()</tt> to refresh their
own contents are called <i>self-refreshing figures</i>. Self-refreshing
figures as a feature are available since OMNeT++ version 5.1.

<p><tt>refreshDisplay()</tt> is declared in <tt>cFigure</tt> as:

<pre class="cpp">
virtual void refreshDisplay();
</pre>
<p>
The default implementation does nothing.

<p>Like <tt>cModule</tt>'s <tt>refreshDisplay()</tt>, <tt>cFigure</tt>'s
<tt>refreshDisplay()</tt> is invoked only under graphical user interfaces
(Qtenv), and right before display updates. However, it is only invoked for
figures on canvases that are currently displayed. This makes it possible for
canvases that are never viewed to have zero refresh overhead.

<p>Since <tt>cFigure</tt>'s <tt>refreshDisplay()</tt> is only invoked when the
canvas is visible, it should only be used to update local state, i.e. only
local members and local subfigures. The code should certainly not access
other canvases, let alone change the state of the simulation.

<p>
<h3><a name="sec:graphics:figures-with-custom-renderers"/>8.6.14 Figures with Custom Renderers<a class="headerlink" href="#sec:graphics:figures-with-custom-renderers" title="Permalink to this headline">¶</a></h3>

<p>In rare cases, it might be necessary to create figure types where the rendering
is entirely custom and not based on already existing figures. The
difficulty arises from the point that figures are only data storage classes.
Actual drawing takes place in the GUI library such as Qtenv.
Thus, in addition to writing the new figure class, one also needs to extend
Qtenv with the corresponding rendering code.
We won't go into full details on how to extend Qtenv here, just give
you a few pointers in case you need it.

<p>In Qtenv, rendering is done with the help of figure renderer
classes that have a class hierarchy roughly parallel to the
<tt>cFigure</tt> inheritance tree. The base classes are incidentally called
<tt>FigureRenderer</tt>. How figure renderers do their job may be different in
various graphical runtime interfaces. In Qtenv, they create and manipulate
<tt>QGraphicsItem</tt>s on a <tt>QGraphicsView</tt>. To render a
new figure type, one needs to create the appropriate figure renderer
classes for Qtenv.

<p>The names of the renderer classes are provided by the figures themselves,
by their <tt>getRendererClassName()</tt> methods. For example,
<tt>cLineFigure</tt>'s <tt>getRendererClassName()</tt> returns
<tt>LineFigureRenderer</tt>. Qtenv qualifies that with its own namespace and
looks for a registered class named
<tt>omnetpp::qtenv::LineFigureRenderer</tt>. If such a class exists and is a
Qtenv figure renderer (the appropriate <tt>dynamic_cast</tt> succeeds), an
instance of that class will be used to render the figure. Otherwise, an
error message will be issued.

<p>
<h2><a name="sec:graphics:osg"/>8.7 3D Visualization<a class="headerlink" href="#sec:graphics:osg" title="Permalink to this headline">¶</a></h2>

<p><h3><a name="sec:graphics:osg-introduction"/>8.7.1 Introduction<a class="headerlink" href="#sec:graphics:osg-introduction" title="Permalink to this headline">¶</a></h3>

<p>OMNeT++ enables advanced 3D visualization for simulation models. 3D visualization
is useful for a wide range of simulations, including mobile wireless networks,
transportation models, factory floorplan simulations, and more. It allows users
to visualize terrain, roads, urban street networks, indoor environments,
satellites, and more. The 3D scene can also be augmented with various
annotations. For wireless network simulations, for example, users can create a
scene that displays not only the faithful representation of the physical world,
but also the transmission range of wireless nodes, their connectivity graph,
various statistics, individual wireless transmissions, and traffic intensity.

<p>In OMNeT++, 3D visualization is completely separate from display string-based and
canvas-based visualization. The scene appears on a separate GUI area.

<p>OMNeT++'s 3D visualization is based on the open-source OpenSceneGraph and
osgEarth libraries. These libraries provide high-level functionality, such as
the ability to use 3D model files directly, access and render online map and
satellite imagery data sources, and more.

<p><h4><a name="sec:graphics:osg-and-osgearth"/>8.7.1.1 OpenSceneGraph and osgEarth<a class="headerlink" href="#sec:graphics:osg-and-osgearth" title="Permalink to this headline">¶</a></h4>

<p>OpenSceneGraph (openscenegraph.org), or OSG for short, is the base library.
According to their website:

<p><blockquote>
&#8220;OpenSceneGraph is an open-source high-performance 3D graphics toolkit used by
application developers in fields such as visual simulation, games, virtual
reality, scientific visualization, and modeling. Written entirely in standard
C++ and OpenGL, it runs on all Windows platforms, OS X, GNU/Linux, IRIX,
Solaris, HP-UX, AIX, and FreeBSD operating systems. OpenSceneGraph is now well
established as the world-leading scene graph technology, used widely in the
vis-sim, space, scientific, oil-gas, games, and virtual reality industries.&#8221;
</blockquote>

<p>On the other hand, osgEarth (osgearth.org) is a geospatial SDK and terrain
engine built on top of OpenSceneGraph, not unlike Google Earth. It has many
attractive features:

<p><ul>
  <li> It can use various street map providers, satellite imaging providers, and
    elevation data sources, both online and offline.
  <li> Data from online sources can be exported into a file suitable for offline use.
  <li> The scene can be annotated with various types of graphical objects.
  <li> It includes conversion between various geographical coordinate systems.
</ul>

<p>In OMNeT++, osgEarth can be very useful for simulations involving maps, terrain, or satellites.

<p><h3><a name="sec:graphics:opp-api-for-osg"/>8.7.2 The OMNeT++ API for OpenSceneGraph<a class="headerlink" href="#sec:graphics:opp-api-for-osg" title="Permalink to this headline">¶</a></h3>

<p>For 3D visualization, OMNeT++ essentially exposes the OpenSceneGraph API. Users
need to assemble an OSG scene graph in the model and give it to OMNeT++ for
display. The scene graph can be updated at runtime, and any changes will be
reflected in the display.

<p><ul class="note"><b>NOTE</b><br>
<b>What is a scene graph?</b> A scene graph is a tree-like directed graph data
structure that describes a 3D scene. The root node represents the entire virtual
world. The world is then broken down into a hierarchy of nodes representing
spatial groupings of objects, settings of the position of objects, animations of
objects, or definitions of logical relationships between objects. The leaves of
the graph represent the physical objects themselves, the drawable geometry, and
their material properties.
</ul>

<p>Once a scene graph has been built by the simulation model, it needs to be given
to a <tt>cOsgCanvas</tt> object to let the OMNeT++ GUI know about it.
<tt>cOsgCanvas</tt> wraps a scene graph, along with hints for the GUI on how to
best display the scene, such as the default camera position. In the GUI, users
can use the mouse to manipulate the camera to view the scene from various angles
and distances, look at various parts of the scene, and so on.

<p>It is important to note that the simulation model can only manipulate the scene
graph and cannot directly access the viewer in the GUI. This is due to a
technical reason. The viewer may not even exist or may be displaying a different
scene graph when the model tries to access it. The model may even be running
under a non-GUI user interface (e.g., Cmdenv) where a viewer is not part of the
program. The viewer can only be influenced through viewer hints in
<tt>cOsgCanvas</tt>.

<p>
<h4><a name="sec:graphics:creating-and-accessing-osgcanvas-objects"/>8.7.2.1 Creating and Accessing cOsgCanvas Objects<a class="headerlink" href="#sec:graphics:creating-and-accessing-osgcanvas-objects" title="Permalink to this headline">¶</a></h4>

<p>Every module has a built-in (default) <tt>cOsgCanvas</tt>, which can be accessed
using the <tt>getOsgCanvas()</tt> method of <tt>cModule</tt>. For example, a
toplevel submodule can get the network's OSG canvas using the following line:

<pre class="cpp">
cOsgCanvas *osgCanvas = getParentModule()-&gt;getOsgCanvas();
</pre>
<p>
Additional <tt>cOsgCanvas</tt> instances can be created using the <tt>new</tt> keyword:

<pre class="cpp">
cOsgCanvas *osgCanvas = new cOsgCanvas("scene2");
</pre>
<p>
<h4><a name="sec:graphics:osgcanvas-and-scene-graphs"/>8.7.2.2 cOsgCanvas and Scene Graphs<a class="headerlink" href="#sec:graphics:osgcanvas-and-scene-graphs" title="Permalink to this headline">¶</a></h4>

<p>Once a scene graph has been assembled, it can be set on the <tt>cOsgCanvas</tt>
using the <tt>setScene()</tt> method.

<pre class="cpp">
osg::Node *scene = ...
osgCanvas-&gt;setScene(scene);
</pre>
<p>
Subsequent changes in the scene graph will be automatically reflected in the
visualization. There is no need to call <tt>setScene()</tt> again or let OMNeT++
know about the changes in any other way.

<p><h4><a name="sec:graphics:osgcanvas-viewer-hints"/>8.7.2.3 Viewer Hints<a class="headerlink" href="#sec:graphics:osgcanvas-viewer-hints" title="Permalink to this headline">¶</a></h4>

<p>There are several hints that the 3D viewer can take into account when displaying
the scene graph. It is important to note that these hints are only suggestions
and the viewer may choose to ignore them. Additionally, users can interactively
override these hints using the mouse, context menu, hotkeys, or any other means.

<p><ul>

<p>  <li> <b>Viewer style:</b> The viewer style can be set using the
    <tt>setViewerStyle()</tt> method. It determines the default hints for a
    scene. The choices are <tt>STYLE_GENERIC</tt>, which should be set for generic
    (non-osgEarth) scenes (default), and <tt>STYLE_EARTH</tt> for osgEarth scenes.
    As a rule of thumb, <tt>STYLE_EARTH</tt> should only be used when the model is
    loading <tt>.earth</tt> files.

<p>  <li> <b>Camera manipulators:</b> The OSG viewer makes use of camera
    manipulators, which map mouse and keyboard gestures to camera movement.
    Users can specify a manipulator using the <tt>setCameraManipulatorType()</tt>
    method. Several camera manipulators are available: <tt>CAM_TERRAIN</tt>, which
    is suitable for flying above an object or terrain; <tt>CAM_OVERVIEW</tt>, which
    is similar to the terrain manipulator but does not allow rolling or looking
    up (users can only see the object from above); <tt>CAM_TRACKBALL</tt>, which
    allows unrestricted movement centered around an object; and <tt>CAM_EARTH</tt>,
    which should be used when viewing the whole Earth is useful (e.g., modeling
    satellites). By default, the manipulator is automatically chosen
    (<tt>CAM_AUTO</tt>) based on the viewer style (<tt>CAM_OVERVIEW</tt> or
    <tt>CAM_EARTH</tt>).

<p>  <li> <b>Scene rendering:</b> Users can set the default background color for
    non-osgEarth scenes using the <tt>setClearColor()</tt> method. It is also
    possible to set the distances of the near and far clipping planes using the
    <tt>setZNear()</tt> and <tt>setZFar()</tt> methods. These distances determine
    the range within which objects in the scene will be displayed. Everything in the
    scene will be truncated to fit between these two planes. If parts of
    objects are being clipped away from the scene, users can try adjusting these
    values.<br><ul><font size=-1>[OSG renders the scene using a <i>Z-buffer</i>, which
    compares the depth (i.e., distance from the camera) of each pixel to the
    last drawn pixel in the same position. If the new pixel is closer, its color
    will be updated, otherwise, it will be ignored. The limited precision of the
    depth values can cause some pixels to be considered equidistant from the
    camera even if they are not, resulting in visual glitches (flashing objects) called
    <i>Z-fighting</i>. <i>zNear</i> and <i>zFar</i> should be chosen such that no
    important objects are left out of the rendering, and to minimize Z-fighting,
    the <i>zFar/zNear</i> ratio should not exceed about 10,000, regardless of their absolute value.]</font></ul>

<p>  <li> <b>Viewpoint and field of view:</b> Users can set default viewpoints
    using the <tt>setGenericViewpoint()</tt> method by specifying the camera
    position, focal point, and &#8220;up&#8221; direction as parameters. For osgEarth
    scenarios, users can use the <tt>setEarthViewpoint()</tt> method to set the
    location of the observer and focal point using geographic coordinates. It is
    also possible to set the camera's field of view angle using the
    <tt>setFieldOfViewAngle()</tt> method.
</ul>

<p>Here is an example code fragment that sets some viewer hints:

<pre class="cpp">
osgCanvas-&gt;setViewerStyle(cOsgCanvas::STYLE_GENERIC);
osgCanvas-&gt;setCameraManipulatorType(cOsgCanvas::CAM_OVERVIEW);
osgCanvas-&gt;setClearColor(cOsgCanvas::Color("skyblue"));
osgCanvas-&gt;setGenericViewpoint(cOsgCanvas::Viewpoint(
        cOsgCanvas::Vec3d(20, -30, 30), // observer
        cOsgCanvas::Vec3d(30, 20, 0),   // focal point
        cOsgCanvas::Vec3d(0, 0, 1)));   // UP
</pre>
<p>

<p><h4><a name="sec:graphics:making-osg-nodes-selectable"/>8.7.2.4 Making Nodes Selectable<a class="headerlink" href="#sec:graphics:making-osg-nodes-selectable" title="Permalink to this headline">¶</a></h4>

<p>If a 3D object in the scene represents a C++ object in the simulation, it would
often be convenient to select that object for inspection by clicking on it with
the mouse.

<p>OMNeT++ provides a wrapper node, <tt>cObjectOsgNode</tt>, that associates its
children with a particular OMNeT++ object (a descendant of <tt>cObject</tt>),
making them selectable in the 3D viewer. To use <tt>cObjectOsgNode</tt>, create
a new instance and add your node(s) as children:

<pre class="cpp">
auto objectNode = new cObjectOsgNode(myModule);
objectNode-&gt;addChild(myNode);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
It is important to ensure that the OMNeT++ object exists as long as the wrapper
node exists. Otherwise, clicking child nodes with the mouse may result in a
crash.
</ul>

<p><h4><a name="sec:graphics:finding-resources"/>8.7.2.5 Finding Resources<a class="headerlink" href="#sec:graphics:finding-resources" title="Permalink to this headline">¶</a></h4>

<p>Often, 3D visualizations need to load external resources from disk, such as
images or 3D models. By default, OSG tries to load these files from the current
working directory unless an absolute path is given. However, it is often more
convenient to load files from the folder of the current OMNeT++ module, the
folder of the ini file, or the image path. To accomplish this, OMNeT++ provides a
<tt>resolveResourcePath()</tt> method.

<p>The <tt>resolveResourcePath()</tt> method of modules and channels accepts a file
name (or relative path) as input and looks into a number of convenient locations
to find the file. The search folders include the current working directory, the
folder of the main ini file, and the folder of the NED file that defined the
module or channel. If the resource is found, the function returns the full path;
otherwise, it returns an empty string.

<p>The function also looks into folders on the NED path and the image path, i.e.,
the roots of the NED and image folder trees. These search locations allow users
to load files using full NED package names (but using slashes instead of dots),
or access an icon with its full name (e.g., <tt>block/sink</tt>).

<p>Here is an example that attempts to load a <tt>car.osgb</tt> model file:

<pre class="cpp">
std::string fileLoc = resolveResourcePath("car.osgb");
if (fileLoc == "")
    throw cRuntimeError("car.osgb not found");
auto node = osgDB::readNodeFile(fileLoc); // use the resolved path
</pre>
<p>

<p><h4><a name="sec:graphics:osg-conditional-compilation"/>8.7.2.6 Conditional Compilation<a class="headerlink" href="#sec:graphics:osg-conditional-compilation" title="Permalink to this headline">¶</a></h4>

<p>OSG and osgEarth are optional in OMNeT++ and may not be available in all
installations. However, simulation models should still compile even if the
particular OMNeT++ installation does not contain the OSG and osgEarth libraries.
This can be achieved using conditional compilation.

<p>OMNeT++ detects the OSG and osgEarth libraries and defines the <tt>WITH_OSG</tt>
macro if they are present. OSG-specific code should be surrounded by
<tt>#ifdef WITH_OSG</tt>.

<p>Here is an example:

<pre class="cpp">
...
#ifdef WITH_OSG
#include &lt;osgDB/ReadFile&gt;
#endif

void DemoModule::initialize()
{
#ifdef WITH_OSG
    cOsgCanvas *osgCanvas = getParentModule()-&gt;getOsgCanvas();
    osg::Node *scene = ... // assemble scene graph here
    osgCanvas-&gt;setScene(scene);
    osgCanvas-&gt;setClearColor(cOsgCanvas::Color(0,0,64)); // hint
#endif
}
</pre>
<p>
<h4><a name="sec:graphics:using-additional-osg-libraries"/>8.7.2.7 Using Additional Libraries<a class="headerlink" href="#sec:graphics:using-additional-osg-libraries" title="Permalink to this headline">¶</a></h4>

<p>OSG and osgEarth consist of several libraries. By default, OMNeT++ links
simulations with only a subset of these libraries, including <tt>osg</tt>,
<tt>osgGA</tt>, <tt>osgViewer</tt>, <tt>osgQt</tt>, <tt>osgEarth</tt>, and
<tt>osgEarthUtil</tt>. If additional OSG and osgEarth libraries are needed, they
must be linked to the model as well. To link these libraries, add the following
code fragment to the <tt>makefrag</tt> file of the project:

<pre class="filelisting">
ifneq ($(OSG_LIBS),)
LIBS += $(OSG_LIBS) -losgDB -losgAnimation ... # additional OSG libs
endif
ifneq ($(OSGEARTH_LIBS),)
LIBS += $(OSGEARTH_LIBS) -losgEarthFeatures -losgEarthSymbology ...
endif
</pre>
<p>
The <tt>ifneq()</tt> statements ensure that <tt>LIBS</tt> is only updated if OMNeT++
has detected the presence of OSG/osgEarth.

<p><h3><a name="sec:graphics:using-osg"/>8.7.3 Using OSG<a class="headerlink" href="#sec:graphics:using-osg" title="Permalink to this headline">¶</a></h3>

<p>OpenScenegraph is a large library with 16+ namespaces and 40+ <tt>osg::Node</tt>
subclasses. Due to size constraints, it is not possible to fully document it
here. Instead, we have provided some practical advice and useful code snippets
to help users get started. For more information, please refer to the
openscenegraph.org website, dedicated OpenSceneGraph books (some of which are
freely available), and other online resources. We have included a list of
OSG-related resources at the end of this chapter.

<p><h4><a name="sec:graphics:osg-loading-models"/>8.7.3.1 Loading Models<a class="headerlink" href="#sec:graphics:osg-loading-models" title="Permalink to this headline">¶</a></h4>

<p>To display a 3D model in the canvas of a compound module, an <tt>osg::Node</tt>
must be provided as the root of the scene.

<p>One method of obtaining such a <tt>Node</tt> is to load it from a file containing
the model. This can be done using the <tt>osgDB::readNodeFile()</tt> method (or
one of its variants). The method takes a string as an argument and, based on the
protocol specification and extensions, finds a suitable loader for the file. It
then loads the file and returns a pointer to the newly created
<tt>osg::Node</tt> instance.

<p>The returned node can be set as the scene of the canvas for display using the
<tt>setScene()</tt> method. Here is an example:

<pre class="cpp">
osg::Node *model = osgDB::readNodeFile("model.osgb");
getParentModule()-&gt;getOsgCanvas()-&gt;setScene(model);
</pre>
<p>
<ul class="note"><b>NOTE</b><br>
<b>Where to get model files:</b> While OpenSceneGraph recognizes and can load a
wide range of formats, many 3D modeling tools can export the edited scene or
part of it in OSG's native file format (osgt) with the help of exporter plugins.
One such plugin for Blender has been used to develop some of the OSG demos for
OMNeT++, and it has proven to be reliable.
</ul>

<p>OSG also provides support for &#8220;pseudo loaders&#8221; that allow for basic operations
to be performed on loaded models. These operations are specified by appending
parameters to the file name upon loading. For example:

<pre class="inifile">
*.cow[*].modelURL = "cow.osgb.2.scale.0,0,90.rot.0,0,-15e-1.trans"
</pre>
<p>
This line scales the original cow model in <tt>cow.osgb</tt> to 200%, rotates it
90 degrees around the Z-axis, and translates it 1.5 units downwards. The
floating-point values are represented in scientific notation to prevent the decimal
points or commas from causing conflicts with operator or parameter separators.

<p>Note that these modifiers operate directly on the model data and are independent
of any subsequent dynamic transformations applied to the node when it is placed
in the scene. For further information, refer to the OSG knowledge base.

<p><h4><a name="sec:graphics:osg-creating-shapes"/>8.7.3.2 Creating Shapes<a class="headerlink" href="#sec:graphics:osg-creating-shapes" title="Permalink to this headline">¶</a></h4>

<p>Shapes can also be built programmatically using the <tt>osg::Geode</tt>,
<tt>osg::ShapeDrawable</tt>, and <tt>osg::Shape</tt> classes.

<p>To create a shape, start by creating an <tt>osg::Shape</tt>. The
<tt>osg::Shape</tt> class is abstract and has several subclasses, such as
<tt>osg::Box</tt>, <tt>osg::Sphere</tt>, <tt>osg::Cone</tt>,
<tt>osg::Cylinder</tt>, and <tt>osg::Capsule</tt>. This object represents the
abstract definition of the shape and cannot be rendered on its own. To render
the shape, create an <tt>osg::ShapeDrawable</tt> for it. However, an
<tt>osg::ShapeDrawable</tt> by itself cannot be added to the scene as it is not
an <tt>osg::Node</tt>. To add it to the scene, the <tt>osg::ShapeDrawable</tt>
must be added to an <tt>osg::Geode</tt> (a &#8220;geometry node&#8221;). Finally, add the
<tt>osg::Geode</tt> to the scene.

<p>For example, to create a cone shape and add it to the scene:

<pre class="cpp">
auto cone = new osg::Cone(osg::Vec3(0, 0, -coneRadius*0.75),
                          coneHeight, coneRadius);
auto coneDrawable = new osg::ShapeDrawable(cone);
auto coneGeode = new osg::Geode;
coneGeode-&gt;addDrawable(coneDrawable);
locatorNode-&gt;addChild(coneGeode);
</pre>
<p>
Note that the same <tt>osg::Shape</tt> instance can be used to create multiple
<tt>osg::ShapeDrawable</tt>s, and a single <tt>osg::ShapeDrawable</tt> can be
added to multiple <tt>osg::Geode</tt>s to display it in multiple places or sizes
in the scene. This can improve rendering performance.

<p><h4><a name="sec:graphics:osg-placing-and-orienting-models"/>8.7.3.3 Placing and Orienting Models in a Scene<a class="headerlink" href="#sec:graphics:osg-placing-and-orienting-models" title="Permalink to this headline">¶</a></h4>

<p>Models can be positioned and oriented by making them children of an
<tt>osg::PositionAttitudeTransform</tt>. This node provides methods to set the
position, orientation, and scale of its children. Orientation is done using
quaternions (<tt>osg::Quat</tt>). To construct a quaternion, specify an axis of
rotation and a rotation angle around the axis.

<p>For example, to position and orient a node:

<pre class="cpp">
osg::Node *objectNode = ...;
auto transformNode = new osg::PositionAttitudeTransform();
transformNode-&gt;addChild(objectNode);
transformNode-&gt;setPosition(osg::Vec3d(x, y, z));
double heading = ...; // in radians
transformNode-&gt;setAttitude(osg::Quat(heading, osg::Vec3d(0, 0, 1)));
</pre>
<p>
<h4><a name="sec:graphics:osg-adding-labels-and-annotations"/>8.7.3.4 Adding Labels and Annotations<a class="headerlink" href="#sec:graphics:osg-adding-labels-and-annotations" title="Permalink to this headline">¶</a></h4>

<p>OSG allows the display of text or image labels in the scene. Labels are rotated
to be always parallel to the screen and scaled to appear in a constant size.
Here is an example of creating and displaying a label relative to a node:

<p>First, create the label:

<pre class="cpp">
auto label = new osgText::Text();
label-&gt;setCharacterSize(18);
label-&gt;setBoundingBoxColor(osg::Vec4(1.0, 1.0, 1.0, 0.5)); // RGBA
label-&gt;setColor(osg::Vec4(0.0, 0.0, 0.0, 1.0)); // RGBA
label-&gt;setAlignment(osgText::Text::CENTER_BOTTOM);
label-&gt;setText("Hello World");
label-&gt;setDrawMode(osgText::Text::FILLEDBOUNDINGBOX | osgText::Text::TEXT);
</pre>
<p>
Alternatively, a textured rectangle with an image can be used:

<pre class="cpp">
auto image = osgDB::readImageFile("myicon.png");
auto texture = new osg::Texture2D();
texture-&gt;setImage(image);
auto icon = osg::createTexturedQuadGeometry(osg::Vec3(0.0, 0.0, 0.0),
    osg::Vec3(image-&gt;s(), 0.0, 0.0), osg::Vec3(0.0, image-&gt;t(), 0.0),
    0.0, 0.0, 1.0, 1.0);
icon-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture);
icon-&gt;getOrCreateStateSet()-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::ON);
</pre>
<p>
If the image has transparent parts, the following lines should be added:<br><ul><font size=-1>[These lines
enable blending, and places <tt>icon</tt> in the <tt>TRANSPARENT_BIN</tt>. Normally there are
two bins, <i>opaque</i> and <i>transparent</i>. When a scene is rendered, OSG first
renders the objects in the opaque bin, then the objects in the transparent bin. More bits
can be created, but that is rarely necessary.]</font></ul>

<pre class="cpp">
icon-&gt;getOrCreateStateSet()-&gt;setMode(GL_BLEND, osg::StateAttribute::ON);
icon-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
</pre>
<p>
The icon and/or label needs an <tt>osg::Geode</tt> to be placed in the scene.
It is advisable to disable lighting for the label.

<pre class="cpp">
auto geode = new osg::Geode();
geode-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING,
            osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
double labelSpacing = 2;
label-&gt;setPosition(osg::Vec3(0.0, labelSpacing, 0.0));
geode-&gt;addDrawable(label);
geode-&gt;addDrawable(icon);
</pre>
<p>
The <tt>osg::Geode</tt> should be made a child of an
<tt>osg::AutoTransform</tt>, which applies the correct transformations for the
desired label-like behavior:

<pre class="cpp">
auto autoTransform = new osg::AutoTransform();
autoTransform-&gt;setAutoScaleToScreen(true);
autoTransform-&gt;setAutoRotateMode(osg::AutoTransform::ROTATE_TO_SCREEN);
autoTransform-&gt;addChild(geode);
</pre>
<p>
The <tt>autoTransform</tt> can now be made a child of the <tt>modelToTransform</tt>
and moved with it. Alternatively, both can be added to a new <tt>osg::Group</tt>
as siblings and handled together.

<p>We want the label to appear relative to an object called <tt>modelNode</tt>.
One way would be to make <tt>autoTransform</tt> the child of <tt>modelNode</tt>,
but here we rather place both of them under an <tt>osg::Group</tt>. The group should
be inserted

<pre class="cpp">
auto modelNode = ... ;
auto group = new osg::Group();
group-&gt;addChild(modelNode);
group-&gt;addChild(autoTransform);
</pre>
<p>
To place the label above the object, we set its position to <i>(0,0,z)</i>, where <i>z</i>
is the radius of the object's bounding sphere.

<pre class="cpp">
auto boundingSphere = modelNode-&gt;getBound();
autoTransform-&gt;setPosition(osg::Vec3d(0.0, 0.0, boundingSphere.radius()));
</pre>
<p>

<p>
<h4><a name="sec:graphics:osg-drawing-lines"/>8.7.3.5 Drawing Lines<a class="headerlink" href="#sec:graphics:osg-drawing-lines" title="Permalink to this headline">¶</a></h4>

<p>To draw a line between two points in the scene, create a <tt>osg::Vec3Array</tt>
to store the points, an <tt>osg::DrawArrays</tt> to specify the part of the
array to be drawn, and an <tt>osg::Geometry</tt> to connect them.

<pre class="cpp">
auto vertices = new osg::Vec3Array();
vertices-&gt;push_back(osg::Vec3(begin_x, begin_y, begin_z));
vertices-&gt;push_back(osg::Vec3(end_x, end_y, end_z));

auto drawArrays = new osg::DrawArrays(osg::PrimitiveSet::LINE_STRIP);
drawArrays-&gt;setFirst(0);
drawArrays-&gt;setCount(vertices-&gt;size());

auto geometry = new osg::Geometry();
geometry-&gt;setVertexArray(vertices);
geometry-&gt;addPrimitiveSet(drawArrays);
</pre>
<p>
The resulting <tt>osg::Geometry</tt> must be added to an <tt>osg::Geode</tt>
(<i>geometry node</i>), which makes it possible to add it to the scene.

<pre class="cpp">
auto geode = new osg::Geode();
geode-&gt;addDrawable(geometry);
</pre>
<p>
To change the visual properties of the line, modify the <tt>osg::StateSet</tt>
of the <tt>osg::Geometry</tt>. For example, to change the line width:

<pre class="cpp">
float width = ...;
auto stateSet = geode-&gt;getOrCreateStateSet();
auto lineWidth = new osg::LineWidth();
lineWidth-&gt;setWidth(width);
stateSet-&gt;setAttributeAndModes(lineWidth, osg::StateAttribute::ON);
</pre>
<p>
Because of how <tt>osg::Geometry</tt> is rendered, the specified line width
will always be constant on the screen (measured in pixels), and will not vary
based on the distance from the camera. To achieve that effect, a long and thin
<tt>osg::Cylinder</tt> could be used instead.

<p>It is recommended to set an appropriate <tt>osg::Material</tt> to control the
color of the line. Additionally, disabling lighting is advisable to ensure
consistent colors regardless of the viewing angle.<br><ul><font size=-1>[Since no normals
were specified for the vertices upon creation, they are undefined
(and wouldn't make much sense for a one-dimensional object),
but still would be used for lighting.]</font></ul>

<pre class="cpp">
auto material = new osg::Material();
osg::Vec4 colorVec(red, green, blue, opacity); // RGBA, all between 0.0 and 1.0
material-&gt;setAmbient(Material::FRONT_AND_BACK, colorVec);
material-&gt;setDiffuse(Material::FRONT_AND_BACK, colorVec);
material-&gt;setAlpha(Material::FRONT_AND_BACK, opacity);
stateSet-&gt;setAttribute(material);
stateSet-&gt;setMode(GL_LIGHTING,
            osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
</pre>
<p>
<h4><a name="sec:graphics:osg-organizing-a-scene"/>8.7.3.6 How to Organize a Scene<a class="headerlink" href="#sec:graphics:osg-organizing-a-scene" title="Permalink to this headline">¶</a></h4>

<p>Regardless of how the scene has been constructed, it is always important to keep
track of the relationship between individual nodes in the scene graph. This is
because any modification made to an <tt>osg::Node</tt> is by default propagated
to all of its children, including transformations, render state variables, and
other flags.

<p>For simple scenes, having an <tt>osg::Group</tt> as the root node and making
every other object a direct child of it can be sufficient. This simplifies the
scene and avoids unexpected issues with state inheritance. However, for more
complex scenes, it is advisable to follow the logical hierarchy of the displayed
objects in the scene graph.

<p>Once the desired object has been created and added to the scene, it can be
easily moved and oriented to represent the state of the simulation by making it
a child of an <tt>osg::PositionAttitudeTransform</tt> node.

<p><h4><a name="sec:graphics:osg-using-animations"/>8.7.3.7 Using Animations<a class="headerlink" href="#sec:graphics:osg-using-animations" title="Permalink to this headline">¶</a></h4>


If the node loaded by <tt>readNodeFile()</tt> contains animations (sometimes
called actions), the <tt>osgAnimation</tt> module is capable of playing them back.

<p>In simple cases, when there is only a single animation, and it is set up to play
in a loop automatically (like the walking man in the osg-indoor sample
simulation), there is no need to explicitly control it (assuming it is the
desired behavior).

<p>Otherwise, the individual actions can be controlled by an
<tt>osgAnimation::AnimationManager</tt>, with methods such as
<tt>playAnimation()</tt>, <tt>stopAnimation()</tt>, <tt>isPlaying()</tt>, etc.
Animation managers can be found among the descendants of the loaded
<tt>osg::Node</tt>s that are animated using a custom <tt>osg::NodeVisitor</tt>:

<pre class="cpp">
osg::Node *objectNode = osgDB::readNodeFile( ... );

struct AnimationManagerFinder : public osg::NodeVisitor {
    osgAnimation::BasicAnimationManager *result = nullptr;
    AnimationManagerFinder()
      : osg::NodeVisitor(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN) {}
    void apply(osg::Node& node) {
        if (result) return; // already found it
        if (osgAnimation::AnimationManagerBase* b =
              dynamic_cast&lt;osgAnimation::AnimationManagerBase*&gt;(
                node.getUpdateCallback())) {
            result = new osgAnimation::BasicAnimationManager(*b);
            return;
        }
        traverse(node);
    }
} finder;

objectNode-&gt;accept(finder);
animationManager = finder.result;
</pre>
<p>
This visitor simply finds the first node in the subtree that has an update
callback of type <tt>osgAnimation::AnimationManagerBase</tt>. Its result is a
new <tt>osgAnimation::BasicAnimationManager</tt> created from the base.

<p>This new <tt>animationManager</tt> must be set as an update callback on the
<tt>objectNode</tt> to be able to drive the animations. Then, any animation in the
list returned by <tt>getAnimationList()</tt> can be set up as needed and played.

<pre class="cpp">
objectNode-&gt;setUpdateCallback(animationManager);
auto animation = animationManager-&gt;getAnimationList().front();
animation-&gt;setPlayMode(osgAnimation::Animation::STAY);
animation-&gt;setDuration(2);
animationManager-&gt;playAnimation(animation);
</pre>
<p>
<h4><a name="sec:graphics:osg-state-sets"/>8.7.3.8 State Sets<a class="headerlink" href="#sec:graphics:osg-state-sets" title="Permalink to this headline">¶</a></h4>

<p>Every <tt>osg::Drawable</tt> can have an <tt>osg::StateSet</tt> attached to it.
An easy way to access it is via the <tt>getOrCreateStateSet()</tt> method of the
drawable node. An <tt>osg::StateSet</tt> encapsulates a subset of the OpenGL
state and can be used to modify various rendering parameters, such as the used
textures, shader programs and their parameters, color and material, face
culling, depth and stencil options, and many more <tt>osg::StateAttributes</tt>.

<p>The following example enables blending for a node and sets up a transparent,
colored material to be used for rendering it through its <tt>osg::StateSet</tt>.

<pre class="cpp">
auto stateSet = node-&gt;getOrCreateStateSet();
stateSet-&gt;setMode(GL_BLEND, osg::StateAttribute::ON);
auto matColor = osg::Vec4(red, green, blue, alpha); // all between 0.0 and 1.0
auto material = new osg::Material;
material-&gt;setEmission(osg::Material::FRONT, matColor);
material-&gt;setDiffuse(osg::Material::FRONT, matColor);
material-&gt;setAmbient(osg::Material::FRONT, matColor);
material-&gt;setAlpha(osg::Material::FRONT, alpha);
stateSet-&gt;setAttributeAndModes(material, osg::StateAttribute::OVERRIDE);
</pre>
<p>
To help OSG correctly render objects with transparency, they should be placed in the
<tt>TRANSPARENT_BIN</tt> by setting a rendering hint on their
<tt>osg::StateSet</tt>. This ensures that they will be drawn after all fully
opaque objects, and in decreasing order of their distance from the camera. When
multiple transparent objects intersect each other in the scene (like the
transmission &#8220;bubbles&#8221; in the BostonPark configuration of the osg-earth sample
simulation), there is no correct order in which they would appear. One solution
for these cases is to disable writing to the depth buffer during their rendering
using the <tt>osg::Depth</tt> attribute.

<pre class="cpp">
stateSet-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
osg::Depth* depth = new osg::Depth;
depth-&gt;setWriteMask(false);
stateSet-&gt;setAttributeAndModes(depth, osg::StateAttribute::ON);
</pre>
<p>
Please note that this still does not guarantee a completely physically accurate
look, as that is a much harder problem to solve, but it at least minimizes
obvious visual artifacts. Also, using too many transparent objects might
decrease performance, so it is best to avoid excessive use of them.

<p><h3><a name="sec:graphics:using-osgearth"/>8.7.4 Using osgEarth<a class="headerlink" href="#sec:graphics:using-osgearth" title="Permalink to this headline">¶</a></h3>

<p>osgEarth is a cross-platform terrain and mapping SDK built on top of
OpenSceneGraph. The most visible feature of osgEarth is that it adds support for
loading <tt>.earth</tt> files to <tt>osgDB::readNodeFile()</tt>. An <tt>.earth</tt> file
specifies the content and appearance of the displayed globe. This can be as
simple as a single image textured over a sphere or as complex as realistic
terrain data and satellite images complete with street and building information
dynamically streamed over the internet from a publicly available provider,
thanks to the flexibility of osgEarth. osgEarth also defines additional APIs to
help with coordinate conversions and other tasks. Other than that, OSG knowledge
can also be applied when building osgEarth scenes.

<p>The following sections contain some tips and code fragments to help the reader
get started with osgEarth. There are also numerous other sources of information,
both in print and online, that can provide more details if needed.

<p><h4><a name="sec:graphics:earth-files"/>8.7.4.1 Earth Files<a class="headerlink" href="#sec:graphics:earth-files" title="Permalink to this headline">¶</a></h4>

<p>When using the osgEarth plugin to display a map as the visual environment of the
simulation, its appearance can be described in an .earth file.

<p>It can be loaded using the <tt>osgDB::readNodeFile()</tt> method, just like any
other regular model. The resulting <tt>osg::Node</tt> will contain a node with a
type of <tt>osgEarth::MapNode</tt>, which can be easily found using the
<tt>osgEarth::MapNode::findMapNode()</tt> function. This node serves as the data
model that contains all the data specified in the <tt>.earth</tt> file.

<pre class="cpp">
auto earth = osgDB::readNodeFile("example.earth");
auto mapNode = osgEarth::MapNode::findMapNode(earth);
</pre>
<p>
An .earth file can specify a wide variety of options. The <tt>type</tt> attribute
of the <tt>map</tt> tag (which is always the root of the document) lets the user
select whether the terrain should be projected onto a flat plane
(<tt>projected</tt>) or rendered as a geoid (<tt>geocentric</tt>).

<p>The source of the terrain's texture is specified by <tt>image</tt> tags. Many
different kinds of sources are supported, including local files and popular
online map sources with open access like MapQuest or OpenStreetMap. These can
display different kinds of graphics, such as satellite imagery, street or
terrain maps, or other features provided by the given online service.

<p>The following example .earth file will set up a spherical rendering of Earth
with textures from openstreetmap.org:

<p><pre class="xml">
&lt;map name="OpenStreetMap" type="geocentric" version="2" &gt;
    &lt;image name="osm_mapnik" driver="xyz" &gt;
        &lt;url&gt;http://[abc].tile.openstreetmap.org/z/x/y.png&lt;/url&gt;
    &lt;/image&gt;
&lt;/map&gt;
</pre>

<p>Elevation data can also be acquired in a similarly simple fashion using the
<tt>elevation</tt> tag. The next snippet demonstrates this:

<p><pre class="xml">
&lt;map name="readymap.org" type="geocentric" version="2" &gt;
    &lt;image name="readymap_imagery" driver="tms" &gt;
        &lt;url&gt;http://readymap.org/readymap/tiles/1.0.0/7/&lt;/url&gt;
    &lt;/image&gt;
    &lt;elevation name="readymap_elevation" driver="tms" &gt;
        &lt;url&gt;http://readymap.org/readymap/tiles/1.0.0/9/&lt;/url&gt;
    &lt;/elevation&gt;
&lt;/map&gt;
</pre>

<p>For a detailed description of the available image and elevation source drivers,
refer to the online references of osgEarth or use one of the sample <tt>.earth</tt> files
included with it.

<p>The following partial <tt>.earth</tt> file places a label over Los Angeles, an extruded
ellipse (a hollow cylinder) next to it, and a big red flag nearby.

<p><pre class="xml">
&lt;map ... &gt;
    ...
    &lt;external&gt;
        &lt;annotations&gt;
            &lt;label text="Los Angeles" &gt;
                &lt;position lat="34.051" long="-117.974" alt="100" mode="relative"/&gt;
            &lt;/label&gt;

            &lt;ellipse name="ellipse extruded" &gt;
                &lt;position lat="32.73" long="-119.0"/&gt;
                &lt;radius_major value="50" units="km"/&gt;
                &lt;radius_minor value="20" units="km"/&gt;
                &lt;style type="text/css" &gt;
                    fill:             #ff7f007f;
                    stroke:           #ff0000ff;
                    extrusion-height: 5000;
                &lt;/style&gt;
            &lt;/ellipse&gt;

            &lt;model name="flag model" &gt;
                &lt;url&gt;flag.osg.18000.scale&lt;/url&gt;
                &lt;position lat="33" long="-117.75" hat="0"/&gt;
            &lt;/model&gt;
        &lt;/annotations&gt;
    &lt;/external&gt;
&lt;/map&gt;
</pre>

<p>
<h4><a name="sec:graphics:offline-tiles"/>8.7.4.2 Creating Offline Tile Packages<a class="headerlink" href="#sec:graphics:offline-tiles" title="Permalink to this headline">¶</a></h4>

<p>Although using online map providers is convenient, there are times when it is
more desirable to use an offline map resource. By doing so, the simulation can
be used without internet access, map loading is faster, and the simulation is
not affected by changes in the online environment (such as availability,
content, and configuration changes of map servers).

<p>There are two ways to obtain map data from the local disk: caching and using a
self-contained offline map package. In this section, we will cover the latter
and show how to create an offline map package from online sources using the
command line tool called <tt>osgearth_package</tt>. The resulting package,
unlike map cache, will also be redistributable.

<p>With the appropriate arguments, <tt>osgearth_package</tt> can download the tiles
that make up the map and arrange them in a standardized, self-contained package.
It also creates a corresponding <tt>.earth</tt> file that can be used later, just like
any other.

<p>For example, the osg-earth sample simulation uses a tile package that has been
created with a command similar to the following:

<pre class="commandline">
$ osgearth_package --tms boston.earth --out offline-tiles \
    --bounds -71.0705566406 42.350425122434 -71.05957031 42.358543917497 \
    --max-level 18 --out-earth boston_offline.earth --mt --concurrency 8
</pre>
<p>
The <tt>--tms boston.earth</tt> arguments indicate that we want to create a
package in TMS format from the input file boston.earth. The <tt>--out
offline-tiles</tt> argument specifies the output directory.

<p>The <tt>--bounds</tt> argument specifies the rectangular area of the map to
include in the package, using the <i>xmin ymin xmax ymax</i> format in
standard WGS84 datum (longitude/latitude). These example coordinates include the
Boston Common area used in some samples. The size of this rectangle has a
significant impact on the size of the resulting package.

<p>The <tt>--max-level 18</tt> argument sets the maximum level of detail to be
saved. This allows adjusting the tradeoff between quality and required disk
space. Values between 15 and 20 are generally suitable, depending on the size of
the target area and the available storage capacity.

<p>The <tt>--out-earth boston_offline.earth</tt> option instructs the utility to
generate an .earth file with the given name in the output directory that
references the prepared tile package as an image source.

<p>The <tt>--mt --concurrency 8</tt> arguments run the process in multithreaded
mode using 8 threads, potentially speeding it up.

<p>The tool also has a few more options for controlling the image format and
compression mode, among others. Refer to the documentation for details or use
the <tt>-h</tt> switch for a brief usage help.

<p><ul class="hint"><b>HINT</b><br>
There is also a GUI frontend for <tt>osgearth_package</tt> called
<tt>osgearth_package_qt</tt>. This tool provides an easy way to select the
bounding rectangle on the actual map using the mouse. It allows the user to
choose the input and output files, export options, and performs the exporting
without requiring the use of a command line interface.
</ul>

<p>
<h4><a name="sec:graphics:osgearth-placing-objects"/>8.7.4.3 Placing Objects on a Map<a class="headerlink" href="#sec:graphics:osgearth-placing-objects" title="Permalink to this headline">¶</a></h4>

<p>To easily position a part of the scene together at a specific geographical
location, an <tt>osgEarth::GeoTransform</tt> is very helpful. It takes
geographic coordinates (longitude/latitude/altitude) and creates a simple
Cartesian coordinate system centered on the given location. All of its children
can be positioned within this local system without worrying about further
coordinate transformations between Cartesian and geographic systems. The
<tt>osg::PositionAttitudeTransform</tt> can be used to move and orient the
children within this local system.

<pre class="cpp">
osgEarth::GeoTransform *geoTransform = new osgEarth::GeoTransform();
osg::PositionAttitudeTransform *localTransform = new osg::PositionAttitudeTransform();

mapNode-&gt;getModelLayerGroup()-&gt;addChild(geoTransform);
geoTransform-&gt;addChild(localTransform);
localTransform-&gt;addChild(objectNode);

geoTransform-&gt;setPosition(osgEarth::GeoPoint(mapNode-&gt;getMapSRS(), longitude, latitude, altitude));
localTransform-&gt;setAttitude(osg::Quat(heading, osg::Vec3d(0, 0, 1)));
</pre>
<p>
<h4><a name="sec:graphics:osgearth-adding-annotations"/>8.7.4.4 Adding Annotations on a Map<a class="headerlink" href="#sec:graphics:osgearth-adding-annotations" title="Permalink to this headline">¶</a></h4>

<p>To display additional information on top of the terrain, annotations can be
used. These are special objects that can adapt to the shape of the surface.
Annotations can take many forms, such as simple geometric shapes like circles,
ellipses, rectangles, lines, and polygons (which can be extruded upwards to
create solids); texts or labels; arbitrary 3D models; or images projected onto
the surface.

<p>All annotations that can be created declaratively from an <tt>.earth</tt> file can also
be programmatically generated at runtime.

<p>This example shows how the circular transmission ranges of the cows in the
osg-earth sample are created as a <tt>osgEarth::Annotation::CircleNode</tt>
annotation. Some basic styling is applied to it using an
<tt>osgEarth::Style</tt>, and the rendering technique is also specified.

<pre class="cpp">
auto scene = ...;
auto mapNode = osgEarth::MapNode::findMapNode(scene);
auto geoSRS = mapNode-&gt;getMapSRS()-&gt;getGeographicSRS();
osgEarth::Style rangeStyle;
rangeStyle.getOrCreate&lt;PolygonSymbol&gt;()-&gt;fill()-&gt;color() =
                                        osgEarth::Color(rangeColor);
rangeStyle.getOrCreate&lt;AltitudeSymbol&gt;()-&gt;clamping() =
                                        AltitudeSymbol::CLAMP_TO_TERRAIN;
rangeStyle.getOrCreate&lt;AltitudeSymbol&gt;()-&gt;technique() =
                                        AltitudeSymbol::TECHNIQUE_DRAPE;
rangeNode = new osgEarth::Annotation::CircleNode(mapNode.get(),
    osgEarth::GeoPoint(geoSRS, longitude, latitude),
    osgEarth::Linear(radius, osgEarth::Units::METERS), rangeStyle);
mapNode-&gt;getModelLayerGroup()-&gt;addChild(rangeNode);
</pre>
<p>

<p><h3><a name="sec:graphics:osg-osgearth-programming-resources"/>8.7.5 OpenSceneGraph/osgEarth Programming Resources<a class="headerlink" href="#sec:graphics:osg-osgearth-programming-resources" title="Permalink to this headline">¶</a></h3>

<p><h4><a name="sec:graphics:osg-osgearth-online-resources"/>8.7.5.1 Online resources<a class="headerlink" href="#sec:graphics:osg-osgearth-online-resources" title="Permalink to this headline">¶</a></h4>

<p>Loading and manipulating OSG models:
<ul>
<li> http://trac.openscenegraph.org/projects/osg/wiki/Support/UserGuides/Plugins
<li> http://trac.openscenegraph.org/projects/osg/wiki/Support/Tutorials/FileLoadingAndTransforms
<li> http://trac.openscenegraph.org/projects/osg/wiki/Support/KnowledgeBase/PseudoLoader
</ul>

<p>Creating 3D models for OpenSceneGraph using Blender:
<ul>
<li> https://github.com/cedricpinson/osgexport
</ul>

<p>osgEarth online documentation:
<ul>
<li> http://docs.osgearth.org/en/latest/references/earthfile.html
<li> http://docs.osgearth.org/en/latest/index.html
</ul>

<p><h4><a name="sec:graphics:osg-osgearth-samples"/>8.7.5.2 Sample code<a class="headerlink" href="#sec:graphics:osg-osgearth-samples" title="Permalink to this headline">¶</a></h4>

<p>Make sure to check the samples that come with the OpenSceneGraph installation,
as they contain valuable information.

<p><ul>
<li> https://github.com/openscenegraph/osg/tree/master/examples
<li> https://github.com/openscenegraph/osg-data
</ul>

<p><h4><a name="sec:graphics:osg-osgearth-books"/>8.7.5.3 Books<a class="headerlink" href="#sec:graphics:osg-osgearth-books" title="Permalink to this headline">¶</a></h4>

<p>The following books can be useful for more complex visualization tasks:

<p><ul>
<li> <i>OpenSceneGraph Quick Start Guide</i> by Paul Martz.

<p>This book is a concise introduction to the OpenSceneGraph API. It can be
purchased from http://www.osgbooks.com and is also available as a free PDF
download.

<p><li> <i>OpenSceneGraph 3.0: Beginners Guide</i> by Wang Rui. Packt Publishing, 2010.

<p>This book is a concise introduction to the main features of OpenSceneGraph that
leads the reader into the fundamentals of developing virtual reality
applications. Practical instructions and explanations accompany every step.

<p><li> <i>OpenSceneGraph 3.0 Cookbook</i> by Wang Rui and Qian Xuelei. Packt Publishing, 2010.

<p>This book contains 100 recipes in 9 chapters, focusing on different fields
including installation, nodes, geometries, camera manipulation, animations,
effects, terrain building, data management, and GUI integration.

<p></ul>

<p>
<hr class='pgbr'><p><hr><b><a href="chap7.html">[Prev]</A>&nbsp;<a href="chap9.html">[Next]</A>&nbsp;<a href="toc.html#toc_8.">[TOC]</a>&nbsp;<a href="usman.html">[Chapters]</a></b><hr></p>

</body>
</html>
